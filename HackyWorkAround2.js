const env = {NODE_ENV: 'production'};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$4=globalThis,e$5=t$4.ShadowRoot&&(void 0===t$4.ShadyCSS||t$4.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),o$4=new WeakMap;let n$4 = class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$5&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o$4.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o$4.set(s,t));}return t}toString(){return this.cssText}};const r$6=t=>new n$4("string"==typeof t?t:t+"",void 0,s$3),i$4=(t,...e)=>{const o=1===t.length?t[0]:e.reduce(((e,s,o)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(s)+t[o+1]),t[0]);return new n$4(o,t,s$3)},S$1=(s,o)=>{if(e$5)s.adoptedStyleSheets=o.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement("style"),n=t$4.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=e.cssText,s.appendChild(o);}},c$3=e$5?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const s of t.cssRules)e+=s.cssText;return r$6(e)})(t):t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{is:i$3,defineProperty:e$4,getOwnPropertyDescriptor:r$5,getOwnPropertyNames:h$2,getOwnPropertySymbols:o$3,getPrototypeOf:n$3}=Object,a$2=globalThis,c$2=a$2.trustedTypes,l$2=c$2?c$2.emptyScript:"",p$2=a$2.reactiveElementPolyfillSupport,d$1=(t,s)=>t,u$3={toAttribute(t,s){switch(s){case Boolean:t=t?l$2:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t);}catch(t){i=null;}}return i}},f$1=(t,s)=>!i$3(t,s),y$1={attribute:!0,type:String,converter:u$3,reflect:!1,hasChanged:f$1};Symbol.metadata??=Symbol("metadata"),a$2.litPropertyMetadata??=new WeakMap;let b$1 = class b extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t);}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y$1){if(s.state&&(s.attribute=!1),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),r=this.getPropertyDescriptor(t,i,s);void 0!==r&&e$4(this.prototype,t,r);}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=r$5(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t;}};return {get(){return e?.call(this)},set(s){const r=e?.call(this);h.call(this,s),this.requestUpdate(t,r,i);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y$1}static _$Ei(){if(this.hasOwnProperty(d$1("elementProperties")))return;const t=n$3(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties);}static finalize(){if(this.hasOwnProperty(d$1("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d$1("properties"))){const t=this.properties,s=[...h$2(t),...o$3(t)];for(const i of s)this.createProperty(i,t[i]);}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i);}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t);}this.elementStyles=this.finalizeStyles(this.styles);}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(c$3(s));}else void 0!==s&&i.push(c$3(s));return i}static _$Eu(t,s){const i=s.attribute;return !1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev();}_$Ev(){this._$ES=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$E_(),this.requestUpdate(),this.constructor.l?.forEach((t=>t(this)));}addController(t){(this._$EO??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.();}removeController(t){this._$EO?.delete(t);}_$E_(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size>0&&(this._$Ep=t);}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S$1(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$EO?.forEach((t=>t.hostConnected?.()));}enableUpdating(t){}disconnectedCallback(){this._$EO?.forEach((t=>t.hostDisconnected?.()));}attributeChangedCallback(t,s,i){this._$AK(t,i);}_$EC(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const r=(void 0!==i.converter?.toAttribute?i.converter:u$3).toAttribute(s,i.type);this._$Em=t,null==r?this.removeAttribute(e):this.setAttribute(e,r),this._$Em=null;}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),r="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u$3;this._$Em=e,this[e]=r.fromAttribute(s,t.type),this._$Em=null;}}requestUpdate(t,s,i){if(void 0!==t){if(i??=this.constructor.getPropertyOptions(t),!(i.hasChanged??f$1)(this[t],s))return;this.P(t,s,i);}!1===this.isUpdatePending&&(this._$ES=this._$ET());}P(t,s,i){this._$AL.has(t)||this._$AL.set(t,s),!0===i.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t);}async _$ET(){this.isUpdatePending=!0;try{await this._$ES;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0;}const t=this.constructor.elementProperties;if(t.size>0)for(const[s,i]of t)!0!==i.wrapped||this._$AL.has(s)||void 0===this[s]||this.P(s,this[s],i);}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$EO?.forEach((t=>t.hostUpdate?.())),this.update(s)):this._$EU();}catch(s){throw t=!1,this._$EU(),s}t&&this._$AE(s);}willUpdate(t){}_$AE(t){this._$EO?.forEach((t=>t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$ES}shouldUpdate(t){return !0}update(t){this._$Ej&&=this._$Ej.forEach((t=>this._$EC(t,this[t]))),this._$EU();}updated(t){}firstUpdated(t){}};b$1.elementStyles=[],b$1.shadowRootOptions={mode:"open"},b$1[d$1("elementProperties")]=new Map,b$1[d$1("finalized")]=new Map,p$2?.({ReactiveElement:b$1}),(a$2.reactiveElementVersions??=[]).push("2.0.4");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3=globalThis,i$2=t$3.trustedTypes,s$2=i$2?i$2.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$3="$lit$",h$1=`lit$${Math.random().toFixed(9).slice(2)}$`,o$2="?"+h$1,n$2=`<${o$2}>`,r$4=document,l$1=()=>r$4.createComment(""),c$1=t=>null===t||"object"!=typeof t&&"function"!=typeof t,a$1=Array.isArray,u$2=t=>a$1(t)||"function"==typeof t?.[Symbol.iterator],d="[ \t\n\f\r]",f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v$1=/-->/g,_=/>/g,m$1=RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),p$1=/'/g,g=/"/g,$$1=/^(?:script|style|textarea|title)$/i,y=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),x=y(1),b=y(2),w=Symbol.for("lit-noChange"),T=Symbol.for("lit-nothing"),A=new WeakMap,E=r$4.createTreeWalker(r$4,129);function C(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s$2?s$2.createHTML(i):i}const P=(t,i)=>{const s=t.length-1,o=[];let r,l=2===i?"<svg>":"",c=f;for(let i=0;i<s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y<s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f?"!--"===u[1]?c=v$1:void 0!==u[1]?c=_:void 0!==u[2]?($$1.test(u[2])&&(r=RegExp("</"+u[2],"g")),c=m$1):void 0!==u[3]&&(c=m$1):c===m$1?">"===u[0]?(c=r??f,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m$1:'"'===u[3]?g:p$1):c===g||c===p$1?c=m$1:c===v$1||c===_?c=f:(c=m$1,r=void 0);const x=c===m$1&&t[i+1].startsWith("/>")?" ":"";l+=c===f?s+n$2:d>=0?(o.push(a),s.slice(0,d)+e$3+s.slice(d)+h$1+x):s+h$1+(-2===d?i:x);}return [C(t,l+(t[s]||"<?>")+(2===i?"</svg>":"")),o]};class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P(t,s);if(this.el=V.createElement(f,n),E.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes);}for(;null!==(r=E.nextNode())&&d.length<u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e$3)){const i=v[a++],s=r.getAttribute(t).split(h$1),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?k:"?"===e[1]?H:"@"===e[1]?I:R}),r.removeAttribute(t);}else t.startsWith(h$1)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($$1.test(r.tagName)){const t=r.textContent.split(h$1),s=t.length-1;if(s>0){r.textContent=i$2?i$2.emptyScript:"";for(let i=0;i<s;i++)r.append(t[i],l$1()),E.nextNode(),d.push({type:2,index:++c});r.append(t[s],l$1());}}}else if(8===r.nodeType)if(r.data===o$2)d.push({type:2,index:c});else {let t=-1;for(;-1!==(t=r.data.indexOf(h$1,t+1));)d.push({type:7,index:c}),t+=h$1.length-1;}c++;}}static createElement(t,i){const s=r$4.createElement("template");return s.innerHTML=t,s}}function N(t,i,s=t,e){if(i===w)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c$1(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N(t,h._$AS(t,i.values),h,e)),i}class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r$4).importNode(i,!0);E.currentNode=e;let h=E.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L(h,this,t)),this._$AV.push(i),l=s[++n];}o!==l?.index&&(h=E.nextNode(),o++);}return E.currentNode=r$4,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0;}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N(this,t,i),c$1(t)?t===T||null==t||""===t?(this._$AH!==T&&this._$AR(),this._$AH=T):t!==this._$AH&&t!==w&&this._(t):void 0!==t._$litType$?this.$(t):void 0!==t.nodeType?this.T(t):u$2(t)?this.k(t):this._(t);}S(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}T(t){this._$AH!==t&&(this._$AR(),this._$AH=this.S(t));}_(t){this._$AH!==T&&c$1(this._$AH)?this._$AA.nextSibling.data=t:this.T(r$4.createTextNode(t)),this._$AH=t;}$(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V.createElement(C(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else {const t=new S(e,this),s=t.u(this.options);t.p(i),this.T(s),this._$AH=t;}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new V(t)),i}k(t){a$1(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.S(l$1()),this.S(l$1()),this,this.options)):s=i[e],s._$AI(h),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t));}}class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T;}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N(this,t,i,0),o=!c$1(t)||t!==this._$AH&&t!==w,o&&(this._$AH=t);else {const e=t;let n,r;for(t=h[0],n=0;n<h.length-1;n++)r=N(this,e[s+n],i,n),r===w&&(r=this._$AH[n]),o||=!c$1(r)||r!==this._$AH[n],r===T?t=T:t!==T&&(t+=(r??"")+h[n+1]),this._$AH[n]=r;}o&&!e&&this.j(t);}j(t){t===T?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"");}}class k extends R{constructor(){super(...arguments),this.type=3;}j(t){this.element[this.name]=t===T?void 0:t;}}class H extends R{constructor(){super(...arguments),this.type=4;}j(t){this.element.toggleAttribute(this.name,!!t&&t!==T);}}class I extends R{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5;}_$AI(t,i=this){if((t=N(this,t,i,0)??T)===w)return;const s=this._$AH,e=t===T&&s!==T||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T&&(s===T||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t);}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){N(this,t);}}const z={P:e$3,A:h$1,C:o$2,M:1,L:P,R:S,D:u$2,V:N,I:M,H:R,N:H,U:I,B:k,F:L},Z=t$3.litHtmlPolyfillSupport;Z?.(V,M),(t$3.litHtmlVersions??=[]).push("3.1.4");const j=(t,i,s)=>{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M(i.insertBefore(l$1(),t),t,void 0,s??{});}return h._$AI(t),h};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */let s$1 = class s extends b$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=j(i,this.renderRoot,this.renderOptions);}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0);}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1);}render(){return w}};s$1._$litElement$=!0,s$1[("finalized")]=!0,globalThis.litElementHydrateSupport?.({LitElement:s$1});const r$3=globalThis.litElementPolyfillSupport;r$3?.({LitElement:s$1});(globalThis.litElementVersions??=[]).push("4.0.6");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2=t=>(e,o)=>{void 0!==o?o.addInitializer((()=>{customElements.define(t,e);})):customElements.define(t,e);};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const o$1={attribute:!0,type:String,converter:u$3,reflect:!1,hasChanged:f$1},r$2=(t=o$1,e,r)=>{const{kind:n,metadata:i}=r;let s=globalThis.litPropertyMetadata.get(i);if(void 0===s&&globalThis.litPropertyMetadata.set(i,s=new Map),s.set(r.name,t),"accessor"===n){const{name:o}=r;return {set(r){const n=e.get.call(this);e.set.call(this,r),this.requestUpdate(o,n,t);},init(e){return void 0!==e&&this.P(o,void 0,t),e}}}if("setter"===n){const{name:o}=r;return function(r){const n=this[o];e.call(this,r),this.requestUpdate(o,n,t);}}throw Error("Unsupported decorator location: "+n)};function n$1(t){return (e,o)=>"object"==typeof o?r$2(t,e,o):((t,e,o)=>{const r=e.hasOwnProperty(o);return e.constructor.createProperty(o,r?{...t,wrapped:!0}:t),r?Object.getOwnPropertyDescriptor(e,o):void 0})(t,e,o)}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function r$1(r){return n$1({...r,state:!0,attribute:!1})}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e$2=t=>(...e)=>({_$litDirective$:t,values:e});let i$1 = class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}};

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const e$1=e$2(class extends i$1{constructor(t){if(super(t),t.type!==t$1.ATTRIBUTE||"class"!==t.name||t.strings?.length>2)throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")}render(t){return " "+Object.keys(t).filter((s=>t[s])).join(" ")+" "}update(s,[i]){if(void 0===this.st){this.st=new Set,void 0!==s.strings&&(this.nt=new Set(s.strings.join(" ").split(/\s/).filter((t=>""!==t))));for(const t in i)i[t]&&!this.nt?.has(t)&&this.st.add(t);return this.render(i)}const r=s.element.classList;for(const t of this.st)t in i||(r.remove(t),this.st.delete(t));for(const t in i){const s=!!i[t];s===this.st.has(t)||this.nt?.has(t)||(s?(r.add(t),this.st.add(t)):(r.remove(t),this.st.delete(t)));}return w}});

var styles$n = i$4`/*@import "@foundry/metal/dist/scss/mixins";
@import "@foundry/metal/dist/scss/lists";
@import "@foundry/metal/dist/scss/utility-classes";*/
.m-avatar {
  --m-avatar-color-background-neutral: var(--foundry-gray-700);
  --m-avatar-color-background-green: var(--success-900);
  --m-avatar-color-background-blue: var(--highlight-900);
  --m-avatar-color-background-yellow: var(--warning-900);
  --m-avatar-color-background-red: var(--error-900);
  --m-avatar-color-background-purple: var(--support-900);
  --m-avatar-color-background-orange: var(--alert-900);
  --m-avatar-color-text-neutral: var(--foundry-gray-300);
  --m-avatar-color-text-yellow: var(--warning-200);
  --m-avatar-color-text-green: var(--success-300);
  --m-avatar-color-text-purple: var(--support-300);
  --m-avatar-color-text-blue: var(--highlight-300);
  --m-avatar-color-text-red: var(--error-300);
  --m-avatar-color-text-orange: var(--alert-300);
}

:root:has(body[data-color-scheme=light]) .m-avatar {
  --m-avatar-color-background-neutral: var(--foundry-gray-200);
  --m-avatar-color-background-green: var(--success-200);
  --m-avatar-color-background-blue: var(--highlight-200);
  --m-avatar-color-background-yellow: var(--warning-200);
  --m-avatar-color-background-red: var(--error-200);
  --m-avatar-color-background-purple: var(--support-200);
  --m-avatar-color-background-orange: var(--alert-200);
  --m-avatar-color-text-neutral: var(--foundry-gray-700);
  --m-avatar-color-text-yellow: var(--warning-900);
  --m-avatar-color-text-green: var(--success-700);
  --m-avatar-color-text-purple: var(--support-700);
  --m-avatar-color-text-blue: var(--highlight-700);
  --m-avatar-color-text-red: var(--error-700);
  --m-avatar-color-text-orange: var(--alert-700);
}

.m-avatar {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  vertical-align: middle;
  overflow: hidden;
  -webkit-user-select: none;
  user-select: none;
  width: var(--size-avatar-m);
  height: var(--size-avatar-m);
  border-radius: var(--radius-m);
}

.m-avatar.is-size-l {
  width: var(--size-avatar-l);
  height: var(--size-avatar-l);
}

.m-avatar.is-size-m {
  width: var(--size-avatar-m);
  height: var(--size-avatar-m);
}

.m-avatar.is-size-default {
  width: var(--size-avatar-m);
  height: var(--size-avatar-m);
}

.m-avatar.is-rounded {
  border-radius: var(--radius-full);
}

.m-avatar-img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: inherit;
}

.m-avatar-fallback {
  font-weight: var(--font-weight-bold);
  margin: unset;
  font-family: var(--font-family);
  line-height: var(--line-height-xs);
  font-size: var(--font-size-xs);
  leading-trim: both;
  text-edge: cap;
  line-height: 1;
  background: var(--m-avatar-color-background-green);
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--m-avatar-color-text-green);
}

.m-avatar.is-size-l .m-avatar-fallback {
  line-height: var(--line-height-s);
  font-size: var(--font-size-s);
}

.m-avatar.is-neutral .m-avatar-fallback {
  background: var(--m-avatar-color-background-neutral);
  color: var(--m-avatar-color-text-neutral);
}

.m-avatar.is-blue .m-avatar-fallback {
  background: var(--m-avatar-color-background-blue);
  color: var(--m-avatar-color-text-blue);
}

.m-avatar.is-green .m-avatar-fallback {
  background: var(--m-avatar-color-background-green);
  color: var(--m-avatar-color-text-green);
}

.m-avatar.is-purple .m-avatar-fallback {
  background: var(--m-avatar-color-background-purple);
  color: var(--m-avatar-color-text-purple);
}

.m-avatar.is-red .m-avatar-fallback {
  background: var(--m-avatar-color-background-red);
  color: var(--m-avatar-color-text-red);
}

.m-avatar.is-yellow .m-avatar-fallback {
  background: var(--m-avatar-color-background-yellow);
  color: var(--m-avatar-color-text-yellow);
}

.m-avatar.is-orange .m-avatar-fallback {
  background: var(--m-avatar-color-background-orange);
  color: var(--m-avatar-color-text-orange);
}`;

var MAvatar_1;
let MAvatar = MAvatar_1 = class MAvatar extends s$1 {
    constructor() {
        super(...arguments);
        this.email = "";
        this.userId = "";
        this.rounded = false;
        this.size = "m";
    }
    getInitials() {
        if (this.email.length < 2) {
            return "UA";
        }
        return this.email[0].toUpperCase() + this.email[1].toUpperCase();
    }
    render() {
        const index = Number(this.userId) % MAvatar_1.colors.length;
        const color = this.email ? MAvatar_1.colors[index] : "neutral";
        const classes = e$1({
            "m-avatar": true,
            "is-rounded": this.rounded,
            [`is-${color}`]: true,
            [`is-size-${this.size}`]: true,
        });
        return x `
            <div class=${classes}>
                <div class="m-avatar-fallback">${this.getInitials()}</div>
            </div>
        `;
    }
};
MAvatar.styles = styles$n;
MAvatar.colors = [
    "blue",
    "purple",
    "yellow",
    "green",
    "orange",
];
__decorate([
    n$1()
], MAvatar.prototype, "email", void 0);
__decorate([
    n$1({ attribute: "user-id" })
], MAvatar.prototype, "userId", void 0);
__decorate([
    n$1({ type: Boolean })
], MAvatar.prototype, "rounded", void 0);
__decorate([
    n$1()
], MAvatar.prototype, "size", void 0);
MAvatar = MAvatar_1 = __decorate([
    t$2("m-avatar")
], MAvatar);

var styles$m = i$4`/*@import "@foundry/metal/dist/scss/mixins";
@import "@foundry/metal/dist/scss/lists";
@import "@foundry/metal/dist/scss/utility-classes";*/
.m-box {
  overflow: hidden;
  display: block;
  box-sizing: border-box;
  border-radius: var(--radius-m);
  padding: var(--space-m);
  background: var(--color-background-secondary);
  box-shadow: var(--shadow-box);
}

.m-box.has-space-3xl {
  padding: var(--space-3xl);
}

.m-box.has-space-2xl {
  padding: var(--space-2xl);
}

.m-box.has-space-xl {
  padding: var(--space-xl);
}

.m-box.has-space-l {
  padding: var(--space-l);
}

.m-box.has-space-m {
  padding: var(--space-m);
}

.m-box.has-space-s {
  padding: var(--space-s);
}

.m-box.has-space-xs {
  padding: var(--space-xs);
}

.m-box.is-variant-ghost {
  background: rgba(0, 0, 0, 0);
  box-shadow: var(--shadow-box-ghost);
}

.m-box.has-space-none {
  padding: 0;
}`;

let MBox = class MBox extends s$1 {
    constructor() {
        super(...arguments);
        this.space = "m";
        this.variant = "classic";
    }
    render() {
        const classes = e$1({
            "m-box": true,
            [`has-space-${this.space}`]: true,
            [`is-variant-${this.variant}`]: true,
        });
        return x `
            <div class=${classes} part="box">
                <slot></slot>
            </div>
        `;
    }
};
MBox.styles = styles$m;
__decorate([
    n$1()
], MBox.prototype, "space", void 0);
__decorate([
    n$1()
], MBox.prototype, "variant", void 0);
MBox = __decorate([
    t$2("m-box")
], MBox);

var styles$l = i$4`:root {
  --m-button-color-background-default: var(--accent-600);
  --m-button-color-background-hover: var(--accent-500);
  --m-button-secondary-color-background-hover: var(--foundry-gray-600);
  --m-button-secondary-color-background: var(--foundry-gray-700);
  --m-button-tertiary-color-background-hover: var(--foundry-gray-700);
  --color-focus: var(--highlight-400);
}

:root:has(body[data-color-scheme=light]) {
  --m-button-secondary-color-background-hover: var(--foundry-gray-300);
  --m-button-secondary-color-background: var(--foundry-gray-200);
  --m-button-tertiary-color-background-hover: var(--foundry-gray-200);
  --color-focus: var(--highlight-500);
}

button.m-button, .m-button[type=button], .m-button[type=reset], .m-button[type=submit], .m-button[role=button] {
  -webkit-appearance: none;
  -moz-appearance: none;
  -webkit-font-smoothing: inherit;
  appearance: none;
  background: none;
  border: 0;
  box-sizing: border-box;
  color: inherit;
  cursor: pointer;
  font: inherit;
  letter-spacing: inherit;
  margin: 0;
  outline: 0;
  overflow: visible;
  padding: 0;
  vertical-align: top;
  width: fit-content;
}

button.m-button, .m-button[type=button], .m-button[type=reset], .m-button[type=submit], .m-button[role=button] {
  font-weight: var(--font-weight-semibold);
  margin: unset;
  font-family: var(--font-family);
  line-height: var(--line-height-s);
  font-size: var(--font-size-s);
  leading-trim: both;
  text-edge: cap;
  align-items: center;
  display: flex;
  gap: var(--space-xs);
  height: var(--size-control-default);
  padding-inline: var(--space-s);
  border-radius: var(--radius-control);
}

button.m-button:disabled, .m-button[type=button]:disabled, .m-button[type=reset]:disabled, .m-button[type=submit]:disabled, .m-button[role=button]:disabled, button.m-button.is-primary:disabled, .m-button[type=button].is-primary:disabled, .m-button[type=reset].is-primary:disabled, .m-button[type=submit].is-primary:disabled, .-button[role=button].is-primary:disabled, button.m-button.is-secondary:disabled, .m-button[type=button].is-secondary:disabled, .m-button[type=reset].is-secondary:disabled, .m-button[type=submit].is-secondary:disabled, .m-button[role=button].is-secondary:disabled, button.m-button.is-tertiary:disabled, .m-button[type=button].is-tertiary:disabled, .m-button[type=reset].is-tertiary:disabled, .m-button[type=submit].is-tertiary:disabled, .m-button[role=button].is-tertiary:disabled, button.m-button.is-destructive:disabled, .m-button[type=button].is-destructive:disabled, .m-button[type=reset].is-destructive:disabled, .m-button[type=submit].is-destructive:disabled, .m-button[role=button].is-destructive:disabled {
  background-color: var(--color-background-tertiary);
  color: var(--color-text-disabled);
  border-color: rgba(0, 0, 0, 0);
}

.m-button.expanded {
  width: 100%;
  text-align: center;
  justify-content: center;
}

button.m-button, .m-button[type=button], .m-button[type=reset], .m-button[type=submit], .m-button[role=button], button.m-button.is-primary, .m-button[type=button].is-primary, .m-button[type=reset].is-primary, .m-button[type=submit].is-primary, .m-button[role=button].is-primary {
  background-color: var(--m-button-color-background-default);
  border: 1px solid rgba(0, 0, 0, 0);
  color: var(--color-text-contrast);
}

button.m-button.is-secondary, .m-button[type=button].is-secondary, .m-button[type=reset].is-secondary, .m-button[type=submit].is-secondary, .m-button[role=button].is-secondary {
  background: var(--m-button-secondary-color-background);
  color: var(--color-text-default);
}

button.m-button.is-tertiary, .m-button[type=button].is-tertiary, .m-button[type=reset].is-tertiary, .m-button[type=submit].is-tertiary, .m-button[role=button].is-tertiary {
  border-color: rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 0);
  color: var(--color-text-default);
}

button.m-button.is-destructive, .m-button[type=button].is-destructive, .m-button[type=reset].is-destructive, .m-button[type=submit].is-destructive, .m-button[role=button].is-destructive {
  background-color: var(--color-background-error-solid);
  color: var(--color-text-contrast);
}

.m-button-icon {
  width: var(--size-icon-m);
  height: var(--unit-6);
  display: flex;
  align-items: center;
}

.m-button-icon svg {
  transform: translate(-1px);
  width: var(--size-icon-m);
  height: var(--size-icon-m);
  stroke-width: 1.5px;
}

.m-button.is-icon-only {
  gap: none;
  padding-inline: var(--space-s);
  border-radius: var(--radius-l);
}

.m-button.is-icon-only svg {
  transform: none;
}

.m-button.is-icon-only .m-button-label {
  display: none;
}

.m-button:focus-visible {
  outline-style: solid;
  outline-color: rgba(0, 0, 0, 0);
  box-shadow: 0 0 0 2px var(--color-background-default), 0 0 0 4px var(--color-focus);
}

@media (pointer: fine) {
  button:hover.m-button, .m-button[type=button]:hover, .m-button[type=reset]:hover, .m-button[type=submit]:hover, .m-button[role=button]:hover {
    background: var(--m-button-color-background-hover);
  }
  button:hover.m-button.is-secondary, .m-button[type=button]:hover.is-secondary, .m-button[type=reset]:hover.is-secondary, .m-button[type=submit]:hover.is-secondary, .m-button[role=button]:hover.is-secondary {
    background: var(--m-button-secondary-color-background-hover);
  }
  button:hover.m-button.is-tertiary, .m-button[type=button]:hover.is-tertiary, .m-button[type=reset]:hover.is-tertiary, .m-button[type=submit]:hover.is-tertiary, .m-button[role=button]:hover.is-tertiary {
    background-color: var(--m-button-tertiary-color-background-hover);
  }
  button:hover.m-button.is-destructive, .m-button[type=button]:hover.is-destructive, .m-button[type=reset]:hover.is-destructive, .m-button[type=submit]:hover.is-destructive, .m-button[role=button]:hover.is-destructive {
    background: var(--error-500);
  }
  button:hover.m-button:disabled, .m-button[type=button]:hover:disabled, .m-button[type=reset]:hover:disabled, .m-button[type=submit]:hover:disabled, .m-button[role=button]:hover:disabled, button:hover.m-button.is-primary:disabled, .m-button[type=button]:hover.is-primary:disabled, .m-button[type=reset]:hover.is-primary:disabled, .m-button[type=submit]:hover.is-primary:disabled, .-button[role=button]:hover.is-primary:disabled, button:hover.m-button.is-secondary:disabled, .m-button[type=button]:hover.is-secondary:disabled, .m-button[type=reset]:hover.is-secondary:disabled, .m-button[type=submit]:hover.is-secondary:disabled, .m-button[role=button]:hover.is-secondary:disabled, button:hover.m-button.is-tertiary:disabled, .m-button[type=button]:hover.is-tertiary:disabled, .m-button[type=reset]:hover.is-tertiary:disabled, .m-button[type=submit]:hover.is-tertiary:disabled, .m-button[role=button]:hover.is-tertiary:disabled, button:hover.m-button.is-destructive:disabled, .m-button[type=button]:hover.is-destructive:disabled, .m-button[type=reset]:hover.is-destructive:disabled, .m-button[type=submit]:hover.is-destructive:disabled, .m-button[role=button]:hover.is-destructive:disabled {
    background-color: var(--color-background-tertiary);
    cursor: default;
  }
}
a.m-button {
  text-decoration: none;
}`;

let MButton = class MButton extends s$1 {
    constructor() {
        super(...arguments);
        this.variant = "primary";
        this.text = "";
        this.expanded = false;
        this.disabled = false;
        this.href = "";
        this.target = "";
        this.icon = "";
        this.iconSize = "m";
        this.iconStyle = "";
        this.alignIcon = "start";
    }
    _getButtonContent() {
        const iconHtml = this.icon
            ? x `<m-icon name=${this.icon} size=${this.iconSize} style=${this.iconStyle}></m-icon>`
            : T;
        return this.alignIcon === "start"
            ? x `${iconHtml}${this.text}`
            : x `${this.text}${iconHtml}`;
    }
    render() {
        const classes = e$1({
            "m-button": true,
            "expanded": this.expanded,
            [`is-${this.variant}`]: true,
            "is-icon-only": this.icon && !this.text,
        });
        const buttonContent = this._getButtonContent();
        if (this.href && !this.disabled) {
            return x `
                <a
                    type="button"
                    class=${classes}
                    href=${this.href}
                    target=${this.target}
                >
                    ${buttonContent}
                </a>
            `;
        }
        return x `
            <button
                type="button"
                class=${classes}
                ?disabled=${this.disabled}
            >
                ${buttonContent}
            </button>
        `;
    }
};
MButton.styles = styles$l;
MButton.shadowRootOptions = Object.assign(Object.assign({}, s$1.shadowRootOptions), { delegatesFocus: true });
__decorate([
    n$1()
], MButton.prototype, "variant", void 0);
__decorate([
    n$1()
], MButton.prototype, "text", void 0);
__decorate([
    n$1({ type: Boolean })
], MButton.prototype, "expanded", void 0);
__decorate([
    n$1({ type: Boolean })
], MButton.prototype, "disabled", void 0);
__decorate([
    n$1()
], MButton.prototype, "href", void 0);
__decorate([
    n$1()
], MButton.prototype, "target", void 0);
__decorate([
    n$1()
], MButton.prototype, "icon", void 0);
__decorate([
    n$1({ attribute: "icon-size" })
], MButton.prototype, "iconSize", void 0);
__decorate([
    n$1({ attribute: "icon-style" })
], MButton.prototype, "iconStyle", void 0);
__decorate([
    n$1({ attribute: "align-icon" })
], MButton.prototype, "alignIcon", void 0);
MButton = __decorate([
    t$2("m-button")
], MButton);

var styles$k = i$4`/*@import "@foundry-uxe/metal/dist/css/_mixins";*/
:root {
  --m-chip-color-background-default: var(--foundry-gray-600);
}

:root:has(body[data-color-scheme=light]) {
  --m-chip-color-background-default: var(--foundry-gray-200);
}

.m-chip {
  font-weight: var(--font-weight-regular);
  margin: unset;
  font-family: var(--font-family);
  font-size: var(--font-size-s);
  line-height: 0;
  leading-trim: both;
  text-edge: cap;
  padding-inline: var(--space-s);
  height: var(--size-avatar-m);
  box-sizing: border-box;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  vertical-align: middle;
  white-space: nowrap;
  min-width: min-content;
  width: fit-content;
  cursor: default;
  background: var(--m-chip-color-background-default);
  color: var(--foundry-gray-700);
  border: 1px solid var(--foundry-gray-200);
  border-radius: var(--radius-full);
  gap: var(--size-gap-s);
}

.m-chip {
  border: none;
  background: var(--m-chip-color-background-default);
  color: var(--color-text-default);
}

.m-chip.is-error {
  background: var(--color-background-error);
}

.m-chip.is-highlight {
  background: var(--color-background-highlight);
}

.m-chip.is-support {
  background: var(--color-background-support);
}

.m-chip.is-success {
  background: var(--color-background-success);
}

.m-chip.is-warning {
  background: var(--color-background-warning);
}

.nu-chip {
  --nu-chip-color-background: var(--color-background-quarterary);
  --nu-chip-color-border: var(--color-border-secondary);
  --nu-chip-label-color-text: var(--color-text-default);
}

.nu-chip.is-warning {
  --nu-chip-color-background: var(--color-background-warning-solid);
  --nu-chip-color-border: var(--color-background-warning-solid);
  --nu-chip-label-color-text: var(--color-text-warning-contrast);
}

.nu-chip.is-error {
  --nu-chip-color-background: var(--color-background-error-solid);
  --nu-chip-color-border: var(--color-background-error-solid);
}

.nu-chip.is-success {
  --nu-chip-color-background: var(--color-background-success-solid);
  --nu-chip-color-border: var(--color-background-success-solid);
}

.nu-chip {
  display: flex;
  height: var(--unit-5);
  font-size: var(--font-size-s);
  cursor: pointer;
  background: none;
  padding: 0;
}

.nu-chip .nu-chip-label, .nu-chip .nu-chip-content {
  padding: var(--space-s) var(--space-s);
  height: 100%;
  display: flex;
  align-items: center;
}

.nu-chip .nu-chip-label {
  background: var(--nu-chip-color-background);
  border-radius: var(--radius-full) 0 0 var(--radius-full);
  color: var(--nu-chip-label-color-text);
}

.nu-chip .nu-chip-content {
  box-shadow: inset 0 0 0 1px var(--nu-chip-color-border);
  border-radius: 0 var(--radius-full) var(--radius-full) 0;
}`;

let MChip = class MChip extends s$1 {
    constructor() {
        super(...arguments);
        this.status = "neutral";
        this.icon = "";
    }
    render() {
        return x `<div class="m-chip is-${this.status}">
            ${this.icon ? x `<m-icon name=${this.icon} class="m-chip-icon"></m-icon>` : T}
            <slot></slot>
        </div>`;
    }
};
MChip.styles = styles$k;
__decorate([
    n$1()
], MChip.prototype, "status", void 0);
__decorate([
    n$1()
], MChip.prototype, "icon", void 0);
MChip = __decorate([
    t$2("m-chip")
], MChip);

var styles$j = i$4`/*@import "@foundry/metal/dist/scss/_mixins";*/
:root {
  --m-container-size-xs: 608px;
  --m-container-size-s: 784px;
  --m-container-size-m: 1040px;
  --m-container-size-l: 1552px;
  --m-container-padding: var(--space-m);
}

.old-container {
  container: old-container/inline-size;
  width: 100%;
  max-inline-size: var(--m-container-size-m);
  padding-inline: var(--m-container-padding);
  margin-inline: auto;
  box-sizing: border-box;
}

.old-container.is-size-xs {
  max-inline-size: var(--m-container-size-xs);
}

.old-container.is-size-s {
  max-inline-size: var(--m-container-size-s);
}

.old-container.is-size-m {
  max-inline-size: var(--m-container-size-m);
}

.old-container.is-size-l {
  max-inline-size: var(--m-container-size-l);
  padding-inline: var(--space-xl);
}

.old-container.is-align-start {
  margin-inline: 0;
  margin-inline-end: auto;
}

.old-container.is-align-end {
  margin-inline: 0;
  margin-inline-start: auto;
}

.old-container.has-space-none {
  padding-inline: 0;
}

.old-container[data-debug] {
  background: #ff5778;
}

.old-container[data-debug]::before, .old-container[data-debug]::after {
  background-image: repeating-linear-gradient(45deg, transparent, transparent 16px, rgb(255, 191, 204) 16px, rgb(255, 191, 204) 24px);
  display: block;
  width: var(--m-container-padding);
  position: absolute;
}

.old-container[data-debug]::before {
  content: "";
  top: 0;
  bottom: 0;
  left: 0;
  border-right: 1px solid #f0002f;
}

.old-container[data-debug]::after {
  content: "";
  top: 0;
  bottom: 0;
  right: 0;
  border-left: 1px solid #f0002f;
}

@media (max-width: 700px) {
  .old-container.is-size-l {
    padding-inline: var(--m-container-padding);
  }
}
.m-container {
  container: m-container/inline-size;
  width: 100%;
  max-inline-size: var(--m-container-size-m);
  padding-inline: var(--space-xl);
  margin-inline: 0;
  margin-inline-end: auto;
  box-sizing: border-box;
}

.m-container.is-size-xs {
  max-inline-size: var(--m-container-size-xs);
}

.m-container.is-size-s {
  max-inline-size: var(--m-container-size-s);
}

.m-container.is-size-m {
  max-inline-size: var(--m-container-size-m);
  padding-inline: var(--space-xl);
}

.m-container.is-size-l {
  max-inline-size: var(--m-container-size-l);
  padding-inline: var(--space-xl);
}

.m-container.is-align-start {
  margin-inline: 0;
  margin-inline-end: auto;
}

.m-container.is-align-center {
  margin-inline: auto;
}

.m-container.is-align-end {
  margin-inline: 0;
  margin-inline-start: auto;
}

.m-container.has-space-none {
  padding-inline: 0;
}

.m-container.expanded {
  max-inline-size: none;
}

.m-container[data-debug] {
  background: #ff5778;
}

.m-container[data-debug]::before, .m-container[data-debug]::after {
  background-image: repeating-linear-gradient(45deg, transparent, transparent 16px, rgb(255, 191, 204) 16px, rgb(255, 191, 204) 24px);
  display: block;
  width: var(--m-container-padding);
  position: absolute;
}

.m-container[data-debug]::before {
  content: "";
  top: 0;
  bottom: 0;
  left: 0;
  border-right: 1px solid #f0002f;
}

.m-container[data-debug]::after {
  content: "";
  top: 0;
  bottom: 0;
  right: 0;
  border-left: 1px solid #f0002f;
}

@media (max-width: 700px) {
  .m-container {
    padding-inline: var(--m-container-padding);
  }
  .m-container.is-size-l {
    padding-inline: var(--m-container-padding);
  }
}`;

let MContainer = class MContainer extends s$1 {
    constructor() {
        super(...arguments);
        this.align = "default";
        this.space = "default";
        this.size = "m";
        this.expanded = false;
    }
    render() {
        const classes = e$1({
            "m-container": true,
            [`is-align-${this.align}`]: true,
            [`has-space-${this.space}`]: true,
            [`is-size-${this.size}`]: true,
            "expanded": this.expanded
        });
        return x `
            <div class=${classes}>
                <slot></slot>
            </div>
        `;
    }
};
MContainer.styles = styles$j;
__decorate([
    n$1()
], MContainer.prototype, "align", void 0);
__decorate([
    n$1()
], MContainer.prototype, "space", void 0);
__decorate([
    n$1()
], MContainer.prototype, "size", void 0);
__decorate([
    n$1({ type: Boolean })
], MContainer.prototype, "expanded", void 0);
MContainer = __decorate([
    t$2("m-container")
], MContainer);

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e=Symbol.for(""),o=t=>{if(t?.r===e)return t?._$litStatic$},i=t=>({_$litStatic$:t,r:e}),a=new Map,l=t=>(r,...e)=>{const i=e.length;let s,l;const n=[],u=[];let c,$=0,f=!1;for(;$<i;){for(c=r[$];$<i&&void 0!==(l=e[$],s=o(l));)c+=s+r[++$],f=!0;$!==i&&u.push(l),n.push(c),$++;}if($===i&&n.push(r[i]),f){const t=n.join("$$lit$$");void 0===(r=a.get(t))&&(n.raw=n,a.set(t,r=n)),e=u;}return t(r,...e)},n=l(x);

var styles$i = i$4`.m-display {
  font-family: var(--font-family-display);
  font-size: var(--font-size-display-m);
  font-weight: var(--font-weight-semibold);
  margin: unset;
}`;

let MDisplay = class MDisplay extends s$1 {
    constructor() {
        super(...arguments);
        this.as = "h1";
    }
    render() {
        return n `
            <${i(this.as)} class="m-display">
                <slot></slot>
            </${i(this.as)}>
        `;
    }
};
MDisplay.styles = styles$i;
__decorate([
    n$1()
], MDisplay.prototype, "as", void 0);
MDisplay = __decorate([
    t$2("m-display")
], MDisplay);

var styles$h = i$4`.m-divider {
  border: 0;
  width: 100%;
  border-top: 1px solid var(--color-border-default);
  margin-block: var(--space-l);
}

.m-divider.has-space-3xl {
  margin-block: var(--space-3xl);
}

.m-divider.has-space-2xl {
  margin-block: var(--space-2xl);
}

.m-divider.has-space-xl {
  margin-block: var(--space-xl);
}

.m-divider.has-space-l {
  margin-block: var(--space-l);
}

.m-divider.has-space-m {
  margin-block: var(--space-m);
}

.m-divider.has-space-s {
  margin-block: var(--space-s);
}

.m-divider.has-space-xs {
  margin-block: var(--space-xs);
}`;

let MDivider = class MDivider extends s$1 {
    constructor() {
        super(...arguments);
        this.space = "xs";
    }
    render() {
        const classes = e$1({
            "m-divider": true,
            [`has-space-${this.space}`]: true,
        });
        return n `
            <div class=${classes}></div>
        `;
    }
};
MDivider.styles = styles$h;
__decorate([
    n$1()
], MDivider.prototype, "space", void 0);
MDivider = __decorate([
    t$2("m-divider")
], MDivider);

var styles$g = i$4`:root {
  --dropdown-menu-color-background: var(--color-background-tertiary);
  --dropdown-menu-hover: var(--foundry-gray-700);
  --dropdown-menu-color-border: var(--foundry-gray-700);
}

:root:has(body[data-color-scheme=light]) {
  --dropdown-menu-color-background: var(--foundry-gray-25);
  --dropdown-menu-hover: var(--foundry-gray-200);
  --dropdown-menu-color-border: var(--foundry-gray-200);
}

.m-dropdown-menu {
  min-width: var(--unit-15);
  max-height: var(--unit-16);
  overflow: auto;
  padding: var(--space-s);
  border-radius: var(--radius-m);
  z-index: var(--index-popover);
  background-color: var(--dropdown-menu-color-background);
  border: 1px solid var(--dropdown-menu-color-border);
}

.m-dropdown-menu .m-menu-item:hover, .m-dropdown-menu .m-menu-item[aria-current=true] {
  background-color: var(--dropdown-menu-hover);
}

.m-dropdown-menu[aria-hidden=true] {
  display: none;
}

.m-dropdown-menu.has-max-height-none {
  max-height: none;
}

.m-dropdown-menu .m-divider {
  border-top: 1px solid var(--dropdown-menu-color-border);
}`;

let MDropdownMenu = class MDropdownMenu extends s$1 {
    constructor() {
        super(...arguments);
        this.hidden = false;
        this.maxHeight = "default";
    }
    render() {
        const classes = e$1({
            "m-dropdown-menu": true,
            [`has-max-height-${this.maxHeight}`]: true,
        });
        return n `
            <div class=${classes} aria-hidden=${this.hidden}>
                <slot></slot>
            </div>
        `;
    }
};
MDropdownMenu.styles = styles$g;
__decorate([
    n$1({ type: Boolean })
], MDropdownMenu.prototype, "hidden", void 0);
__decorate([
    n$1()
], MDropdownMenu.prototype, "maxHeight", void 0);
MDropdownMenu = __decorate([
    t$2("m-dropdown-menu")
], MDropdownMenu);

var styles$f = i$4`.m-heading {
  margin: unset;
  font-family: var(--font-family);
  font-weight: var(--font-weight-bold);
  font-size: var(--font-size-m);
  line-height: var(--line-height-m);
  color: var(--color-text-default);
}

.m-heading.is-size-2xl {
  font-size: var(--font-size-2xl);
  line-height: var(--line-height-2xl);
}

.m-heading.is-size-xl {
  font-size: var(--font-size-xl);
  line-height: var(--line-height-xl);
}

.m-heading.is-size-l {
  font-size: var(--font-size-l);
  line-height: var(--line-height-l);
}

.m-heading.is-size-m {
  font-size: var(--font-size-m);
  line-height: var(--line-height-m);
}

.m-heading.is-size-s {
  font-size: var(--font-size-s);
  line-height: var(--line-height-s);
}

.m-heading.is-size-xs {
  font-size: var(--font-size-xs);
  line-height: var(--line-height-xs);
}

.m-heading.is-secondary, .m-heading > .is-secondary {
  color: var(--color-text-secondary);
}

.m-heading.is-tertiary, .m-heading > .is-tertiary {
  color: var(--color-text-tertiary);
}

.m-heading.is-quarterary, .m-heading > .is-quarterary {
  color: var(--color-text-quarterary);
}

.m-heading.is-accent {
  color: var(--color-text-accent);
}

.m-heading.is-link {
  color: var(--color-text-link);
}

.m-heading.is-alert {
  color: var(--color-text-alert);
}

.m-heading.is-error {
  color: var(--color-text-error);
}

.m-heading.is-warning {
  color: var(--color-text-warning);
}

.m-heading.is-success {
  color: var(--color-text-success);
}

.m-heading.has-measure-l {
  max-inline-size: var(--size-measure-heading-l);
}

.m-heading.has-measure-m {
  max-inline-size: var(--size-measure-heading-m);
}

.m-heading.has-measure-s {
  max-inline-size: var(--size-measure-heading-s);
}

.m-heading.is-truncated {
  display: inline-block;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  word-wrap: normal;
}

.m-heading a {
  text-decoration: none;
  color: var(--color-text-link);
}

.m-heading a:hover {
  text-decoration: underline;
  text-decoration-style: solid;
  text-decoration-thickness: 1px;
  text-underline-offset: calc(0.025em + 2px);
  text-decoration-color: var(--accent-6);
}`;

let MHeading = class MHeading extends s$1 {
    constructor() {
        super(...arguments);
        this.as = "h3";
        this.size = "s";
        this.variant = "primary";
    }
    render() {
        const classes = e$1({
            "m-heading": true,
            [`is-size-${this.size}`]: true,
            [`is-${this.variant}`]: true,
        });
        return n `
            <${i(this.as)} class=${classes}>
                <slot></slot>
            </${i(this.as)}>
        `;
    }
};
MHeading.styles = styles$f;
__decorate([
    n$1()
], MHeading.prototype, "as", void 0);
__decorate([
    n$1()
], MHeading.prototype, "size", void 0);
__decorate([
    n$1()
], MHeading.prototype, "variant", void 0);
MHeading = __decorate([
    t$2("m-heading")
], MHeading);

var styles$e = i$4`/*@import '@foundry/metal/dist/scss/mixins';
@import '@foundry/metal/dist/scss/lists';
@import '@foundry/metal/dist/scss/utility-classes';*/
.m-icon {
  width: var(--size-icon-default);
  height: var(--size-icon-default);
}

.m-icon.is-size-xl {
  width: var(--size-icon-xl);
  height: var(--size-icon-xl);
}

.m-icon.is-size-l {
  width: var(--size-icon-l);
  height: var(--size-icon-l);
}

.m-icon.is-size-m {
  width: var(--size-icon-m);
  height: var(--size-icon-m);
}

.m-icon.is-size-s {
  width: var(--size-icon-s);
  height: var(--size-icon-s);
}

.m-icon.is-success {
  stroke: var(--color-icon-success);
}

.m-icon.is-warning {
  stroke: var(--color-icon-warning);
}

.m-icon.is-error {
  stroke: var(--color-icon-error);
}

:host {
  display: block;
}

.m-icon {
  display: block;
}`;

let MIcon = class MIcon extends s$1 {
    constructor() {
        super(...arguments);
        this.name = null;
        this.size = "m";
        this.status = "neutral";
    }
    render() {
        let icon = this.name !== null ? ICON_MAP[this.name] : undefined;
        if (typeof icon === "undefined") {
            throw new Error(this.name + " is not a supported icon.");
        }
        const classes = e$1({
            "m-icon": true,
            [`is-size-${this.size}`]: true,
            [`is-${this.status}`]: true,
        });
        return x `<svg
            part="svg"
            class=${classes}
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
        >
            ${icon}
        </svg>`;
    }
};
MIcon.styles = styles$e;
__decorate([
    n$1()
], MIcon.prototype, "name", void 0);
__decorate([
    n$1()
], MIcon.prototype, "size", void 0);
__decorate([
    n$1()
], MIcon.prototype, "status", void 0);
MIcon = __decorate([
    t$2("m-icon")
], MIcon);
const ICON_MAP = {
    "activity-square": b `
        <rect width="18" height="18" x="3" y="3" rx="2" />
        <path d="M17 12h-2l-2 5-2-10-2 5H7" />
    `,
    "arrow-left": b `
        <path d="m12 19-7-7 7-7" />
        <path d="M19 12H5" />
    `,
    "arrow-right": b `
        <path d="M5 12h14" />
        <path d="m12 5 7 7-7 7" />
    `,
    "arrow-up": b `
        <path d="m5 12 7-7 7 7" />
        <path d="M12 19V5" />
    `,
    "arrow-up-right": b `
        <path d="M7 7h10v10" />
        <path d="M7 17 17 7" />
    `,
    "arrow-down": b `
        <path d="M12 5v14" />
        <path d="m19 12-7 7-7-7" />
    `,
    "arrow-up-right-square": b `
        <rect width="18" height="18" x="3" y="3" rx="2" />
        <path d="M8 8h8v8" />
        <path d="m8 16 8-8" />
    `,
    ban: b `
        <circle cx="12" cy="12" r="10" />
        <path d="m4.9 4.9 14.2 14.2" />
    `,
    "building-2": b `
        <path d="M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z" />
        <path d="M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2" />
        <path d="M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2" />
        <path d="M10 6h4" />
        <path d="M10 10h4" />
        <path d="M10 14h4" />
        <path d="M10 18h4" />
    `,
    calendar: b `
        <path d="M8 2v4" />
        <path d="M16 2v4" />
        <rect width="18" height="18" x="3" y="4" rx="2" />
        <path d="M3 10h18" />
    `,
    "calendar-clock": b `
        <path d="M21 7.5V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3.5" />
        <path d="M16 2v4" />
        <path d="M8 2v4" />
        <path d="M3 10h5" />
        <path d="M17.5 17.5 16 16.3V14" />
        <circle cx="16" cy="16" r="6" />
    `,
    "check": b `
        <path d="M20 6 9 17l-5-5"/>
    `,
    "check-circle": b `
        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
        <path d="m9 11 3 3L22 4" />
    `,
    "chevron-down": b `<path d="m6 9 6 6 6-6" /> `,
    "chevron-left": b `<path d="m15 18-6-6 6-6" /> `,
    "chevron-right": b `<path d="m9 18 6-6-6-6" /> `,
    "chevrons-up-down": b `
        <path d="m7 15 5 5 5-5" />
        <path d="m7 9 5-5 5 5" />
    `,
    "chevron-up": b `  <path d="m18 15-6-6-6 6" /> `,
    "circle-dot": b `
        <circle cx="12" cy="12" r="10" />
        <circle cx="12" cy="12" r="1" />
    `,
    "circle-off": b `
        <path d="m2 2 20 20" />
        <path d="M8.35 2.69A10 10 0 0 1 21.3 15.65" />
        <path d="M19.08 19.08A10 10 0 1 1 4.92 4.92" />
    `,
    "clipboard-list": b `
        <rect width="8" height="4" x="8" y="2" rx="1" ry="1" />
        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
        <path d="M12 11h4" />
        <path d="M12 16h4" />
        <path d="M8 11h.01" />
        <path d="M8 16h.01" />
    `,
    clock: b `
        <circle cx="12" cy="12" r="10" />
        <polyline points="12 6 12 12 16 14" />
    `,
    cog: b `
        <path d="M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z" />
        <path d="M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" />
        <path d="M12 2v2" />
        <path d="M12 22v-2" />
        <path d="m17 20.66-1-1.73" />
        <path d="M11 10.27 7 3.34" />
        <path d="m20.66 17-1.73-1" />
        <path d="m3.34 7 1.73 1" />
        <path d="M14 12h8" />
        <path d="M2 12h2" />
        <path d="m20.66 7-1.73 1" />
        <path d="m3.34 17 1.73-1" />
        <path d="m17 3.34-1 1.73" />
        <path d="m11 13.73-4 6.93" />
    `,
    copy: b `
        <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
        <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" />
    `,
    cpu: b `
        <rect x="4" y="4" width="16" height="16" rx="2" />
        <rect x="9" y="9" width="6" height="6" />
        <path d="M15 2v2" />
        <path d="M15 20v2" />
        <path d="M2 15h2" />
        <path d="M2 9h2" />
        <path d="M20 15h2" />
        <path d="M20 9h2" />
        <path d="M9 2v2" />
        <path d="M9 20v2" />
    `,
    download: b `
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
        <polyline points="7 10 12 15 17 10" />
        <line x1="12" x2="12" y1="15" y2="3" />
    `,
    empty: b `
        <path d="M21.5 3L3.5 21M21.5 12C21.5 16.9706 17.4706 21 12.5 21C7.52944 21 3.5 16.9706 3.5 12C3.5 7.02944 7.52944 3 12.5 3C17.4706 3 21.5 7.02944 21.5 12Z" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round"/>
    `,
    eye: b `
        <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" />
        <circle cx="12" cy="12" r="3" />
    `,
    "eye-off": b `
        <path d="M9.88 9.88a3 3 0 1 0 4.24 4.24" />
        <path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68" />
        <path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61" />
        <line x1="2" x2="22" y1="2" y2="22" />
    `,
    "file-pie-chart": b `
        <path d="M16 22h2a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v3" />
        <path d="M14 2v4a2 2 0 0 0 2 2h4" />
        <path d="M4 11.5a6.02 6.02 0 1 0 8.5 8.5" />
        <path d="M14 16c0-3.3-2.7-6-6-6v6Z" />
    `,
    gauge: b `
        <path d="m12 14 4-4" />
        <path d="M3.34 19a10 10 0 1 1 17.32 0" />
    `,
    home: b `
        <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
        <polyline points="9 22 9 12 15 12 15 22" />
    `,
    info: b `
        <circle cx="12" cy="12" r="10" />
        <path d="M12 16v-4" />
        <path d="M12 8h.01" />
    `,
    "layers-2": b `
        <path d="m16.02 12 5.48 3.13a1 1 0 0 1 0 1.74L13 21.74a2 2 0 0 1-2 0l-8.5-4.87a1 1 0 0 1 0-1.74L7.98 12" />
        <path d="M13 13.74a2 2 0 0 1-2 0L2.5 8.87a1 1 0 0 1 0-1.74L11 2.26a2 2 0 0 1 2 0l8.5 4.87a1 1 0 0 1 0 1.74Z" />
    `,
    "layout-grid": b `
        <rect width="7" height="7" x="3" y="3" rx="1" />
        <rect width="7" height="7" x="14" y="3" rx="1" />
        <rect width="7" height="7" x="14" y="14" rx="1" />
        <rect width="7" height="7" x="3" y="14" rx="1" />
    `,
    list: b `
        <line x1="8" x2="21" y1="6" y2="6" />
        <line x1="8" x2="21" y1="12" y2="12" />
        <line x1="8" x2="21" y1="18" y2="18" />
        <line x1="3" x2="3.01" y1="6" y2="6" />
        <line x1="3" x2="3.01" y1="12" y2="12" />
        <line x1="3" x2="3.01" y1="18" y2="18" />
    `,
    "loader-2": b `<path d="M21 12a9 9 0 1 1-6.219-8.56" /> `,
    "log-out": b `
        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
        <polyline points="16 17 21 12 16 7" />
        <line x1="21" x2="9" y1="12" y2="12" />
    `,
    "map-pin": b `
        <path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z" />
        <circle cx="12" cy="10" r="3" />
    `,
    menu: b `
        <line x1="4" x2="20" y1="12" y2="12" />
        <line x1="4" x2="20" y1="6" y2="6" />
        <line x1="4" x2="20" y1="18" y2="18" />
    `,
    "message-square-plus": b `
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
        <path d="M12 7v6" />
        <path d="M9 10h6" />
    `,
    "minus-circle": b `
        <circle cx="12" cy="12" r="10" />
        <path d="M8 12h8" />
    `,
    "more-vertical": b `
        <circle cx="12" cy="12" r="1" />
        <circle cx="12" cy="5" r="1" />
        <circle cx="12" cy="19" r="1" />
    `,
    pencil: b `
        <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" />
        <path d="m15 5 4 4" />
    `,
    "plug-zap": b `
        <path d="M6.3 20.3a2.4 2.4 0 0 0 3.4 0L12 18l-6-6-2.3 2.3a2.4 2.4 0 0 0 0 3.4Z" />
        <path d="m2 22 3-3" />
        <path d="M7.5 13.5 10 11" />
        <path d="M10.5 16.5 13 14" />
        <path d="m18 3-4 4h6l-4 4" />
    `,
    plus: b `
        <path d="M5 12h14" />
        <path d="M12 5v14" />
    `,
    "plus-circle": b `
        <circle cx="12" cy="12" r="10" />
        <path d="M8 12h8" />
        <path d="M12 8v8" />
    `,
    "plus-square": b `
        <rect width="18" height="18" x="3" y="3" rx="2" />
        <path d="M8 12h8" />
        <path d="M12 8v8" />
    `,
    "refresh-cw": b `
        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" />
        <path d="M21 3v5h-5" />
        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" />
        <path d="M8 16H3v5" />
    `,
    rocket: b `
        <path d="M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z" />
        <path d="m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z" />
        <path d="M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0" />
        <path d="M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5" />
    `,
    "rotate-ccw": b `
        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" />
        <path d="M3 3v5h5" />
    `,
    "scroll-text": b `
        <path d="M8 21h12a2 2 0 0 0 2-2v-2H10v2a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v3h4" />
        <path d="M19 17V5a2 2 0 0 0-2-2H4" />
        <path d="M15 8h-5" />
        <path d="M15 12h-5" />
    `,
    search: b `
        <circle cx="11" cy="11" r="8" />
        <path d="m21 21-4.3-4.3" />
    `,
    siren: b `
        <path d="M7 18v-6a5 5 0 1 1 10 0v6" />
        <path d="M5 21a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-1a2 2 0 0 0-2-2H7a2 2 0 0 0-2 2z" />
        <path d="M21 12h1" />
        <path d="M18.5 4.5 18 5" />
        <path d="M2 12h1" />
        <path d="M12 2v1" />
        <path d="m4.929 4.929.707.707" />
        <path d="M12 12v6" />
    `,
    tag: b `
        <path d="M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z"/><circle cx="7.5" cy="7.5" r=".5" fill="currentColor"/>
    `,
    ticket: b `
        <path d="M2 9a3 3 0 0 1 0 6v2a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-2a3 3 0 0 1 0-6V7a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2Z" />
        <path d="M13 5v2" />
        <path d="M13 17v2" />
        <path d="M13 11v2" />
    `,
    "trash-2": b `
        <path d="M3 6h18" />
        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
        <line x1="10" x2="10" y1="11" y2="17" />
        <line x1="14" x2="14" y1="11" y2="17" />
    `,
    "triangle-alert": b `
        <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3" />
        <path d="M12 9v4" />
        <path d="M12 17h.01" />
    `,
    user: b `
        <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
        <circle cx="12" cy="7" r="4" />
    `,
    wifi: b `
        <path d="M12 20h.01" />
        <path d="M2 8.82a15 15 0 0 1 20 0" />
        <path d="M5 12.859a10 10 0 0 1 14 0" />
        <path d="M8.5 16.429a5 5 0 0 1 7 0" />
    `,
    "wifi-off": b `
        <path d="M12 20h.01" />
        <path d="M8.5 16.429a5 5 0 0 1 7 0" />
        <path d="M5 12.859a10 10 0 0 1 5.17-2.69" />
        <path d="M19 12.859a10 10 0 0 0-2.007-1.523" />
        <path d="M2 8.82a15 15 0 0 1 4.177-2.643" />
        <path d="M22 8.82a15 15 0 0 0-11.288-3.764" />
        <path d="m2 2 20 20" />
    `,
    x: b `
        <path d="M18 6 6 18" />
        <path d="m6 6 12 12" />
    `,
    "x-circle": b `
        <circle cx="12" cy="12" r="10" />
        <path d="m15 9-6 6" />
        <path d="m9 9 6 6" />
    `,
    "zap-off": b `
        <path d="M10.513 4.856 13.12 2.17a.5.5 0 0 1 .86.46l-1.377 4.317" />
        <path d="M15.656 10H20a1 1 0 0 1 .78 1.63l-1.72 1.773" />
        <path d="M16.273 16.273 10.88 21.83a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14H4a1 1 0 0 1-.78-1.63l4.507-4.643" />
        <path d="m2 2 20 20" />
    `,
    "zoom-in": b `
        <circle cx="11" cy="11" r="8"/>
        <line x1="21" x2="16.65" y1="21" y2="16.65"/>
        <line x1="11" x2="11" y1="8" y2="14"/>
        <line x1="8" x2="14" y1="11" y2="11"/>
    `,
};

var styles$d = i$4`:root {
  --m-nav-item-hover: var(--foundry-gray-800);
  --m-nav-item-selected: var(--foundry-gray-800);
}

:root:has(body[data-color-scheme=light]) {
  --m-nav-item-hover: var(--foundry-gray-25);
  --m-nav-item-selected: var(--foundry-gray-25);
}

.m-nav {
  display: grid;
  grid-row-gap: var(--unit-2);
  grid-template-columns: 100%;
}

.m-nav-item {
  font-family: var(--font-family-display);
  font-size: var(--font-size-s);
  font-weight: var(--font-weight-bold);
  line-height: var(--line-height-s);
  display: flex;
  overflow-wrap: break-word;
  hyphens: auto;
  margin: unset;
  text-transform: capitalize;
  color: var(--color-text-tertiary);
  box-sizing: border-box;
  padding: var(--space-s) var(--space-m);
  height: 2.25rem;
  user-select: none;
  text-decoration: none;
  border-radius: var(--radius-m);
  gap: var(--size-gap-l);
  white-space: nowrap;
}

.m-nav-item svg, .m-nav-item m-icon::part(svg) {
  stroke: var(--color-icon-default);
}

.m-nav-item[aria-current] {
  background-color: var(--m-nav-item-selected);
  color: var(--color-text-default);
}

.m-nav-item[aria-current] svg, .m-nav-item[aria-current] m-icon::part(svg) {
  stroke: var(--color-icon-accent);
}

.m-nav-group.is-open .m-nav-group-section {
  display: flex;
}

.m-nav-group .m-nav-group-header {
  -webkit-appearance: none;
  -moz-appearance: none;
  -webkit-font-smoothing: inherit;
  appearance: none;
  background: none;
  border: 0;
  box-sizing: border-box;
  color: inherit;
  cursor: pointer;
  font: inherit;
  letter-spacing: inherit;
  margin: 0;
  outline: 0;
  overflow: visible;
  vertical-align: top;
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-s) var(--space-m);
}

.m-nav-group .m-nav-group-header svg, .m-nav-group .m-nav-group-header m-icon::part(svg) {
  stroke: var(--color-icon-default);
}

.m-nav-group .m-nav-group-header.is-active .m-nav-group-label {
  color: var(--color-text-default);
}

.m-nav-group .m-nav-group-header.is-active .m-nav-group-label svg, .m-nav-group .m-nav-group-header.is-active .m-nav-group-label m-icon::part(svg) {
  stroke: var(--color-icon-hover);
}

.m-nav-group .m-nav-group-header .m-nav-group-label {
  font-family: var(--font-family-display);
  font-size: var(--font-size-s);
  font-weight: var(--font-weight-bold);
  line-height: var(--line-height-s);
  display: flex;
  overflow-wrap: break-word;
  hyphens: auto;
  margin: unset;
  text-transform: capitalize;
  color: var(--color-text-tertiary);
  box-sizing: border-box;
  user-select: none;
  text-decoration: none;
  border-radius: var(--radius-m);
  gap: var(--size-gap-l);
  white-space: nowrap;
}

.m-nav-group .m-nav-group-header svg, .m-nav-group .m-nav-group-header m-icon::part(svg) {
  stroke: var(--color-icon-default);
  width: var(--size-icon-l);
  height: var(--size-icon-l);
}

.m-nav-group .m-nav-group-header .m-nav-chevron {
  width: var(--size-icon-m);
  height: var(--size-icon-m);
}

.m-nav-group .m-nav-group-header .m-nav-chevron svg, .m-nav-group .m-nav-group-header .m-nav-chevron m-icon::part(svg) {
  width: var(--size-icon-m);
  height: var(--size-icon-m);
}

.m-nav-group .m-nav-group-section {
  display: none;
  padding-inline: var(--space-m);
}

.m-nav-group .m-nav-group-section .m-nav-group-item-icons {
  display: flex;
  flex-direction: column;
  margin-block: 14px;
  padding-left: 6px;
}

.m-nav-group .m-nav-group-section .m-nav-group-items {
  width: 100%;
}

.m-nav-group .m-nav-group-section .m-nav-group-items .m-nav-item {
  font-weight: var(--font-weight-regular);
  padding: var(--space-s) var(--space-m) var(--space-s) var(--space-s);
  margin-left: var(--space-m);
}

.m-nav-group .m-nav-group-section .m-nav-group-items .m-nav-item[aria-current]:has(> .m-nav-group-items) {
  background-color: #000;
}

@media (pointer: fine) {
  .m-nav-item:hover {
    background-color: var(--m-nav-item-hover);
    cursor: pointer;
    color: var(--color-text-default);
    -webkit-user-select: none;
    user-select: none;
  }
  .m-nav-item[aria-current]:hover {
    background-color: var(--m-nav-item-selected);
  }
  .m-nav-group-header:hover {
    cursor: pointer;
  }
  .m-nav-group-header:hover .m-nav-group-label {
    color: var(--color-text-default);
  }
}`;

let MNavItem = class MNavItem extends s$1 {
    constructor() {
        super(...arguments);
        this.href = "";
        this.icon = null;
        this.label = "";
    }
    render() {
        return x `
            <a href=${this.href} class="m-nav-item">
                ${this.icon ? x `<m-icon name=${this.icon} size="l"></m-icon>` : T}
                ${this.label}
            </a>
        `;
    }
};
MNavItem.styles = styles$d;
__decorate([
    n$1()
], MNavItem.prototype, "href", void 0);
__decorate([
    n$1()
], MNavItem.prototype, "icon", void 0);
__decorate([
    n$1()
], MNavItem.prototype, "label", void 0);
MNavItem = __decorate([
    t$2("m-nav-item")
], MNavItem);

var styles$c = i$4`/*@import '@foundry/metal/dist/scss/mixins';
@import '@foundry/metal/dist/scss/lists';
@import '@foundry/metal/dist/scss/utility-classes';*/
.m-section {
  height: 100%;
  padding-block: var(--space-l);
}

.m-section.has-space-3xl {
  padding-block: var(--space-3xl);
}

.m-section.has-space-2xl {
  padding-block: var(--space-2xl);
}

.m-section.has-space-xl {
  padding-block: var(--space-xl);
}

.m-section.has-space-l {
  padding-block: var(--space-l);
}

.m-section.has-space-m {
  padding-block: var(--space-m);
}

.m-section.has-space-s {
  padding-block: var(--space-s);
}

.m-section.has-space-xs {
  padding-block: var(--space-xs);
}`;

let MSection = class MSection extends s$1 {
    constructor() {
        super(...arguments);
        this.space = "m";
    }
    render() {
        const classes = e$1({
            "m-section": true,
            [`has-space-${this.space}`]: true,
        });
        return x `
            <section class=${classes}>
                <slot></slot>
            </section>
        `;
    }
};
MSection.styles = styles$c;
__decorate([
    n$1()
], MSection.prototype, "space", void 0);
MSection = __decorate([
    t$2("m-section")
], MSection);

var styles$b = i$4`.m-stack {
  display: grid;
  grid-row-gap: var(--space-m);
  grid-template-columns: 100%;
}

.m-stack.is-align-center {
  align-items: center;
}

.m-stack.is-horizontal {
  display: flex;
  gap: var(--space-s);
}

.m-stack.has-space-between {
  justify-content: space-between;
}

.m-stack.has-space-3xl {
  grid-row-gap: var(--space-3xl);
}

.m-stack.is-horizontal.has-space-3xl {
  gap: var(--space-3xl);
}

.m-stack.has-space-2xl {
  grid-row-gap: var(--space-2xl);
}

.m-stack.is-horizontal.has-space-2xl {
  gap: var(--space-2xl);
}

.m-stack.has-space-xl {
  grid-row-gap: var(--space-xl);
}

.m-stack.is-horizontal.has-space-xl {
  gap: var(--space-xl);
}

.m-stack.has-space-l {
  grid-row-gap: var(--space-l);
}

.m-stack.is-horizontal.has-space-l {
  gap: var(--space-l);
}

.m-stack.has-space-m {
  grid-row-gap: var(--space-m);
}

.m-stack.is-horizontal.has-space-m {
  gap: var(--space-m);
}

.m-stack.has-space-s {
  grid-row-gap: var(--space-s);
}

.m-stack.is-horizontal.has-space-s {
  gap: var(--space-s);
}

.m-stack.has-space-xs {
  grid-row-gap: var(--space-xs);
}

.m-stack.is-horizontal.has-space-xs {
  gap: var(--space-xs);
}

.m-stack.has-space-none {
  grid-row-gap: 0;
}

.m-stack.is-horizontal.has-space-none {
  gap: 0;
}`;

let MStack = class MStack extends s$1 {
    constructor() {
        super(...arguments);
        this.horizontal = false;
        this.spaceBetween = false;
        this.alignCenter = false;
        this.space = "s";
    }
    render() {
        const classes = e$1({
            "m-stack": true,
            "is-horizontal": this.horizontal,
            "has-space-between": this.spaceBetween,
            "is-align-center": this.alignCenter,
            [`has-space-${this.space}`]: true,
        });
        return x `
            <div part="stack" class=${classes}>
                <slot></slot>
            </div>
        `;
    }
};
MStack.styles = styles$b;
__decorate([
    n$1({ type: Boolean })
], MStack.prototype, "horizontal", void 0);
__decorate([
    n$1({ type: Boolean, attribute: "space-between" })
], MStack.prototype, "spaceBetween", void 0);
__decorate([
    n$1({ type: Boolean, attribute: "align-center" })
], MStack.prototype, "alignCenter", void 0);
__decorate([
    n$1()
], MStack.prototype, "space", void 0);
MStack = __decorate([
    t$2("m-stack")
], MStack);

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const {I:t}=z,s=()=>document.createComment(""),r=(o,i,n)=>{const e=o._$AA.parentNode,l=void 0===i?o._$AB:i._$AA;if(void 0===n){const i=e.insertBefore(s(),l),c=e.insertBefore(s(),l);n=new t(i,c,o,o.options);}else {const t=n._$AB.nextSibling,i=n._$AM,c=i!==o;if(c){let t;n._$AQ?.(o),n._$AM=o,void 0!==n._$AP&&(t=o._$AU)!==i._$AU&&n._$AP(t);}if(t!==l||c){let o=n._$AA;for(;o!==t;){const t=o.nextSibling;e.insertBefore(o,l),o=t;}}}return n},v=(o,t,i=o)=>(o._$AI(t,i),o),u$1={},m=(o,t=u$1)=>o._$AH=t,p=o=>o._$AH,h=o=>{o._$AP?.(!1,!0);let t=o._$AA;const i=o._$AB.nextSibling;for(;t!==i;){const o=t.nextSibling;t.remove(),t=o;}};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const u=(e,s,t)=>{const r=new Map;for(let l=s;l<=t;l++)r.set(e[l],l);return r},c=e$2(class extends i$1{constructor(e){if(super(e),e.type!==t$1.CHILD)throw Error("repeat() can only be used in text expressions")}dt(e,s,t){let r;void 0===t?t=s:void 0!==s&&(r=s);const l=[],o=[];let i=0;for(const s of e)l[i]=r?r(s,i):i,o[i]=t(s,i),i++;return {values:o,keys:l}}render(e,s,t){return this.dt(e,s,t).values}update(s,[t,r$1,c]){const d=p(s),{values:p$1,keys:a}=this.dt(t,r$1,c);if(!Array.isArray(d))return this.ut=a,p$1;const h$1=this.ut??=[],v$1=[];let m$1,y,x=0,j=d.length-1,k=0,w$1=p$1.length-1;for(;x<=j&&k<=w$1;)if(null===d[x])x++;else if(null===d[j])j--;else if(h$1[x]===a[k])v$1[k]=v(d[x],p$1[k]),x++,k++;else if(h$1[j]===a[w$1])v$1[w$1]=v(d[j],p$1[w$1]),j--,w$1--;else if(h$1[x]===a[w$1])v$1[w$1]=v(d[x],p$1[w$1]),r(s,v$1[w$1+1],d[x]),x++,w$1--;else if(h$1[j]===a[k])v$1[k]=v(d[j],p$1[k]),r(s,d[x],d[j]),j--,k++;else if(void 0===m$1&&(m$1=u(a,k,w$1),y=u(h$1,x,j)),m$1.has(h$1[x]))if(m$1.has(h$1[j])){const e=y.get(a[k]),t=void 0!==e?d[e]:null;if(null===t){const e=r(s,d[x]);v(e,p$1[k]),v$1[k]=e;}else v$1[k]=v(t,p$1[k]),r(s,d[x],t),d[e]=null;k++;}else h(d[j]),j--;else h(d[x]),x++;for(;k<=w$1;){const e=r(s,v$1[w$1+1]);v(e,p$1[k]),v$1[k++]=e;}for(;x<=j;){const e=d[x++];null!==e&&h(e);}return this.ut=a,m(s,v$1),w}});

/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
// type Person = {
//   firstName: string
//   lastName: string
//   age: number
//   visits: number
//   status: string
//   progress: number
//   createdAt: Date
//   nested: {
//     foo: [
//       {
//         bar: 'bar'
//       }
//     ]
//     bar: { subBar: boolean }[]
//     baz: {
//       foo: 'foo'
//       bar: {
//         baz: 'baz'
//       }
//     }
//   }
// }

// const test: DeepKeys<Person> = 'nested.foo.0.bar'
// const test2: DeepKeys<Person> = 'nested.bar'

// const helper = createColumnHelper<Person>()

// helper.accessor('nested.foo', {
//   cell: info => info.getValue(),
// })

// helper.accessor('nested.foo.0.bar', {
//   cell: info => info.getValue(),
// })

// helper.accessor('nested.bar', {
//   cell: info => info.getValue(),
// })

function createColumnHelper() {
  return {
    accessor: (accessor, column) => {
      return typeof accessor === 'function' ? {
        ...column,
        accessorFn: accessor
      } : {
        ...column,
        accessorKey: accessor
      };
    },
    display: column => column,
    group: column => column
  };
}

// Is this type a tuple?

// If this type is a tuple, what indices are allowed?

///

function functionalUpdate(updater, input) {
  return typeof updater === 'function' ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return updater => {
    instance.setState(old => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d) {
  return d instanceof Function;
}
function isNumberArray(d) {
  return Array.isArray(d) && d.every(val => typeof val === 'number');
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = subArr => {
    subArr.forEach(item => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return depArgs => {
    let depTime;
    if (opts.key && opts.debug) depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug) resultTime = Date.now();
    result = fn(...newDeps);
    opts == null || opts.onChange == null || opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = ' ' + str;
          }
          return str;
        };
        console.info(`%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key: env.NODE_ENV === 'development' ,
    onChange
  };
}

function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table, column, row, cell) => ({
      table,
      column,
      row,
      cell: cell,
      getValue: cell.getValue,
      renderValue: cell.renderValue
    }), getMemoOptions(table.options, 'debugCells'))
  };
  table._features.forEach(feature => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}

function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === 'function' ? accessorKey.replaceAll('.', '_') : accessorKey.replace(/\./g, '_') : undefined) != null ? _ref : typeof resolvedColumnDef.header === 'string' ? resolvedColumnDef.header : undefined;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    // Support deep accessor keys
    if (accessorKey.includes('.')) {
      accessorFn = originalRow => {
        let result = originalRow;
        for (const key of accessorKey.split('.')) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
        }
        return result;
      };
    } else {
      accessorFn = originalRow => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    throw new Error();
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent: parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];
    }, getMemoOptions(table.options, 'debugColumns')),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], orderColumns => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap(column => column.getLeafColumns());
        return orderColumns(leafColumns);
      }
      return [column];
    }, getMemoOptions(table.options, 'debugColumns'))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }

  // Yes, we have to convert table to unknown, because we know more than the compiler here.
  return column;
}

const debug = 'debugHeaders';
//

function createHeader(table, column, options) {
  var _options$id;
  const id = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = h => {
        if (h.subHeaders && h.subHeaders.length) {
          h.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header: header,
      column
    })
  };
  table._features.forEach(feature => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
const Headers = {
  createTable: table => {
    // Header Groups

    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, getMemoOptions(table.options, debug));
    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      leafColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, 'center');
    }, getMemoOptions(table.options, debug));
    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'left');
    }, getMemoOptions(table.options, debug));
    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'right');
    }, getMemoOptions(table.options, debug));

    // Footer Groups

    table.getFooterGroups = memo(() => [table.getHeaderGroups()], headerGroups => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug));
    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], headerGroups => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug));
    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], headerGroups => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug));
    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], headerGroups => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug));

    // Flat Headers

    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], headerGroups => {
      return headerGroups.map(headerGroup => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug));
    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], left => {
      return left.map(headerGroup => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug));
    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], left => {
      return left.map(headerGroup => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug));
    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], left => {
      return left.map(headerGroup => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug));

    // Leaf Headers

    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], flatHeaders => {
      return flatHeaders.filter(header => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, getMemoOptions(table.options, debug));
    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], flatHeaders => {
      return flatHeaders.filter(header => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, getMemoOptions(table.options, debug));
    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], flatHeaders => {
      return flatHeaders.filter(header => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, getMemoOptions(table.options, debug));
    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...((_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : []), ...((_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : []), ...((_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : [])].map(header => {
        return header.getLeafHeaders();
      }).flat();
    }, getMemoOptions(table.options, debug));
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  // Find the max depth of the columns:
  // build the leaf column row
  // build each buffer row going up
  //    placeholder for non-existent level
  //    real column for existing level

  let maxDepth = 0;
  const findMaxDepth = function (columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter(column => column.getIsVisible()).forEach(column => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    // The header group we are creating
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),
      headers: []
    };

    // The parent columns we're going to scan next
    const pendingParentHeaders = [];

    // Scan each column for parents
    headersToGroup.forEach(headerToGroup => {
      // What is the latest (last) parent column?

      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        // The parent header is new
        column = headerToGroup.column.parent;
      } else {
        // The parent header is repeated
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        // This column is repeated. Add it as a sub header to the next batch
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        // This is a new header. Let's create it
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join('_'),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter(d => d.column === column).length}` : undefined,
          depth,
          index: pendingParentHeaders.length
        });

        // Add the headerToGroup as a subHeader of the new header
        header.subHeaders.push(headerToGroup);
        // Add the new header to the pendingParentHeaders to get grouped
        // in the next batch
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {
    depth: maxDepth,
    index
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();

  // headerGroups = headerGroups.filter(headerGroup => {
  //   return !headerGroup.headers.every(header => header.isPlaceholder)
  // })

  const recurseHeadersForSpans = headers => {
    const filteredHeaders = headers.filter(header => header.column.getIsVisible());
    return filteredHeaders.map(header => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach(_ref => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}

const createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: columnId => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return undefined;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: columnId => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return undefined;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: columnId => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: [],
    getLeafRows: () => flattenBy(row.subRows, d => d.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : undefined,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow) break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo(() => [table.getAllLeafColumns()], leafColumns => {
      return leafColumns.map(column => {
        return createCell(table, row, column, column.id);
      });
    }, getMemoOptions(table.options, 'debugRows')),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], allCells => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, getMemoOptions(table.options, 'debugRows'))
  };
  for (let i = 0; i < table._features.length; i++) {
    const feature = table._features[i];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};

//

const ColumnFaceting = {
  createColumn: (column, table) => {
    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
    column.getFacetedRowModel = () => {
      if (!column._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column._getFacetedRowModel();
    };
    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
    column.getFacetedUniqueValues = () => {
      if (!column._getFacetedUniqueValues) {
        return new Map();
      }
      return column._getFacetedUniqueValues();
    };
    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
    column.getFacetedMinMaxValues = () => {
      if (!column._getFacetedMinMaxValues) {
        return undefined;
      }
      return column._getFacetedMinMaxValues();
    };
  }
};

const includesString = (row, columnId, filterValue) => {
  var _filterValue$toString, _row$getValue;
  const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = val => testFalsey(val);
const includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = val => testFalsey(val);
const equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = val => testFalsey(val);
const arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = val => testFalsey(val) || !(val != null && val.length);
const arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some(val => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = val => testFalsey(val) || !(val != null && val.length);
const arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some(val => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = val => testFalsey(val) || !(val != null && val.length);
const equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = val => testFalsey(val);
const weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = val => testFalsey(val);
const inNumberRange = (row, columnId, filterValue) => {
  let [min, max] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min && rowValue <= max;
};
inNumberRange.resolveFilterValue = val => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== 'number' ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== 'number' ? parseFloat(unsafeMax) : unsafeMax;
  let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min > max) {
    const temp = min;
    min = max;
    max = temp;
  }
  return [min, max];
};
inNumberRange.autoRemove = val => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);

// Export

const filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
// Utils

function testFalsey(val) {
  return val === undefined || val === null || val === '';
}

//

const ColumnFiltering = {
  getDefaultColumnDef: () => {
    return {
      filterFn: 'auto'
    };
  },
  getInitialState: state => {
    return {
      columnFilters: [],
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onColumnFiltersChange: makeStateUpdater('columnFilters', table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100
    };
  },
  createColumn: (column, table) => {
    column.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === 'string') {
        return filterFns.includesString;
      }
      if (typeof value === 'number') {
        return filterFns.inNumberRange;
      }
      if (typeof value === 'boolean') {
        return filterFns.equals;
      }
      if (value !== null && typeof value === 'object') {
        return filterFns.equals;
      }
      if (Array.isArray(value)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === 'auto' ? column.getAutoFilterFn() : // @ts-ignore
      (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];
    };
    column.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
    };
    column.getIsFiltered = () => column.getFilterIndex() > -1;
    column.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find(d => d.id === column.id)) == null ? void 0 : _table$getState$colum.value;
    };
    column.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex(d => d.id === column.id)) != null ? _table$getState$colum2 : -1;
    };
    column.setFilterValue = value => {
      table.setColumnFilters(old => {
        const filterFn = column.getFilterFn();
        const previousFilter = old == null ? void 0 : old.find(d => d.id === column.id);
        const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : undefined);

        //
        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
          var _old$filter;
          return (_old$filter = old == null ? void 0 : old.filter(d => d.id !== column.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column.id,
          value: newFilter
        };
        if (previousFilter) {
          var _old$map;
          return (_old$map = old == null ? void 0 : old.map(d => {
            if (d.id === column.id) {
              return newFilterObj;
            }
            return d;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
  },
  createRow: (row, _table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: table => {
    table.setColumnFilters = updater => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = old => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter(filter => {
          const column = leafColumns.find(d => d.id === filter.id);
          if (column) {
            const filterFn = column.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.resetColumnFilters = defaultState => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === 'undefined' || typeof value === 'string' && !value;
}

const sum = (columnId, _leafRows, childRows) => {
  // It's faster to just add the aggregations together instead of
  // process leaf nodes individually
  return childRows.reduce((sum, next) => {
    const nextValue = next.getValue(columnId);
    return sum + (typeof nextValue === 'number' ? nextValue : 0);
  }, 0);
};
const min = (columnId, _leafRows, childRows) => {
  let min;
  childRows.forEach(row => {
    const value = row.getValue(columnId);
    if (value != null && (min > value || min === undefined && value >= value)) {
      min = value;
    }
  });
  return min;
};
const max = (columnId, _leafRows, childRows) => {
  let max;
  childRows.forEach(row => {
    const value = row.getValue(columnId);
    if (value != null && (max < value || max === undefined && value >= value)) {
      max = value;
    }
  });
  return max;
};
const extent = (columnId, _leafRows, childRows) => {
  let min;
  let max;
  childRows.forEach(row => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min === undefined) {
        if (value >= value) min = max = value;
      } else {
        if (min > value) min = value;
        if (max < value) max = value;
      }
    }
  });
  return [min, max];
};
const mean = (columnId, leafRows) => {
  let count = 0;
  let sum = 0;
  leafRows.forEach(row => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count, sum += value;
    }
  });
  if (count) return sum / count;
  return;
};
const median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values = leafRows.map(row => row.getValue(columnId));
  if (!isNumberArray(values)) {
    return;
  }
  if (values.length === 1) {
    return values[0];
  }
  const mid = Math.floor(values.length / 2);
  const nums = values.sort((a, b) => a - b);
  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
const unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map(d => d.getValue(columnId))).values());
};
const uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map(d => d.getValue(columnId))).size;
};
const count = (_columnId, leafRows) => {
  return leafRows.length;
};
const aggregationFns = {
  sum,
  min,
  max,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count
};

//

const ColumnGrouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: props => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: 'auto'
    };
  },
  getInitialState: state => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onGroupingChange: makeStateUpdater('grouping', table),
      groupedColumnMode: 'reorder'
    };
  },
  createColumn: (column, table) => {
    column.toggleGrouping = () => {
      table.setGrouping(old => {
        // Find any existing grouping for this column
        if (old != null && old.includes(column.id)) {
          return old.filter(d => d !== column.id);
        }
        return [...(old != null ? old : []), column.id];
      });
    };
    column.getCanGroup = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);
    };
    column.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
    };
    column.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
    };
    column.getToggleGroupingHandler = () => {
      const canGroup = column.getCanGroup();
      return () => {
        if (!canGroup) return;
        column.toggleGrouping();
      };
    };
    column.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === 'number') {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value) === '[object Date]') {
        return aggregationFns.extent;
      }
    };
    column.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === 'auto' ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
    };
  },
  createTable: table => {
    table.setGrouping = updater => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
    table.resetGrouping = defaultState => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = columnId => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column, row, table) => {
    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter(col => !grouping.includes(col.id));
  if (groupedColumnMode === 'remove') {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map(g => leafColumns.find(col => col.id === g)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}

//

const ColumnOrdering = {
  getInitialState: state => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onColumnOrderChange: makeStateUpdater('columnOrder', table)
    };
  },
  createColumn: (column, table) => {
    column.getIndex = memo(position => [_getVisibleLeafColumns(table, position)], columns => columns.findIndex(d => d.id === column.id), getMemoOptions(table.options, 'debugColumns'));
    column.getIsFirstColumn = position => {
      var _columns$;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;
    };
    column.getIsLastColumn = position => {
      var _columns;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;
    };
  },
  createTable: table => {
    table.setColumnOrder = updater => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = defaultState => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => columns => {
      // Sort grouped columns to the start of the column list
      // before the headers are built
      let orderedColumns = [];

      // If there is no order, return the normal columns
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns;
      } else {
        const columnOrderCopy = [...columnOrder];

        // If there is an order, make a copy of the columns
        const columnsCopy = [...columns];

        // And make a new ordered array of the columns

        // Loop over the columns and place them in order into the new array
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }

        // If there are any columns left, add them to the end
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, getMemoOptions(table.options, 'debugTable'));
  }
};

//

const getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
const ColumnPinning = {
  getInitialState: state => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onColumnPinningChange: makeStateUpdater('columnPinning', table)
    };
  },
  createColumn: (column, table) => {
    column.pin = position => {
      const columnIds = column.getLeafColumns().map(d => d.id).filter(Boolean);
      table.setColumnPinning(old => {
        var _old$left3, _old$right3;
        if (position === 'right') {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter(d => !(columnIds != null && columnIds.includes(d))),
            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds]
          };
        }
        if (position === 'left') {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds],
            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter(d => !(columnIds != null && columnIds.includes(d)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter(d => !(columnIds != null && columnIds.includes(d))),
          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter(d => !(columnIds != null && columnIds.includes(d)))
        };
      });
    };
    column.getCanPin = () => {
      const leafColumns = column.getLeafColumns();
      return leafColumns.some(d => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column.getIsPinned = () => {
      const leafColumnIds = column.getLeafColumns().map(d => d.id);
      const {
        left,
        right
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some(d => left == null ? void 0 : left.includes(d));
      const isRight = leafColumnIds.some(d => right == null ? void 0 : right.includes(d));
      return isLeft ? 'left' : isRight ? 'right' : false;
    };
    column.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position = column.getIsPinned();
      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];
      return allCells.filter(d => !leftAndRight.includes(d.column.id));
    }, getMemoOptions(table.options, 'debugRows'));
    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {
      const cells = (left != null ? left : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({
        ...d,
        position: 'left'
      }));
      return cells;
    }, getMemoOptions(table.options, 'debugRows'));
    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
      const cells = (right != null ? right : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({
        ...d,
        position: 'right'
      }));
      return cells;
    }, getMemoOptions(table.options, 'debugRows'));
  },
  createTable: table => {
    table.setColumnPinning = updater => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = defaultState => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = position => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
      return (left != null ? left : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, 'debugColumns'));
    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
      return (right != null ? right : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, 'debugColumns'));
    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];
      return allColumns.filter(d => !leftAndRight.includes(d.id));
    }, getMemoOptions(table.options, 'debugColumns'));
  }
};

//

//

const defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
const getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
const ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: state => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      columnResizeMode: 'onEnd',
      columnResizeDirection: 'ltr',
      onColumnSizingChange: makeStateUpdater('columnSizing', table),
      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', table)
    };
  },
  createColumn: (column, table) => {
    column.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column.id];
      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column.getStart = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns'));
    column.getAfter = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns'));
    column.resetSize = () => {
      table.setColumnSizing(_ref2 => {
        let {
          [column.id]: _,
          ...rest
        } = _ref2;
        return rest;
      });
    };
    column.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum = 0;
      const recurse = header => {
        if (header.subHeaders.length) {
          header.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = _contextDocument => {
      const column = table.getColumn(header.column.id);
      const canResize = column == null ? void 0 : column.getCanResize();
      return e => {
        if (!column || !canResize) {
          return;
        }
        e.persist == null || e.persist();
        if (isTouchStartEvent(e)) {
          // lets not respond to multiple touches (e.g. 2 or 3 fingers)
          if (e.touches && e.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map(d => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];
        const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== 'number') {
            return;
          }
          table.setColumnSizingInfo(old => {
            var _old$startOffset, _old$startSize;
            const deltaDirection = table.options.columnResizeDirection === 'rtl' ? -1 : 1;
            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach(_ref3 => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === 'onChange' || eventType === 'end') {
            table.setColumnSizing(old => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = clientXPos => updateOffset('move', clientXPos);
        const onEnd = clientXPos => {
          updateOffset('end', clientXPos);
          table.setColumnSizingInfo(old => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const contextDocument = _contextDocument || typeof document !== 'undefined' ? document : null;
        const mouseEvents = {
          moveHandler: e => onMove(e.clientX),
          upHandler: e => {
            contextDocument == null || contextDocument.removeEventListener('mousemove', mouseEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener('mouseup', mouseEvents.upHandler);
            onEnd(e.clientX);
          }
        };
        const touchEvents = {
          moveHandler: e => {
            if (e.cancelable) {
              e.preventDefault();
              e.stopPropagation();
            }
            onMove(e.touches[0].clientX);
            return false;
          },
          upHandler: e => {
            var _e$touches$;
            contextDocument == null || contextDocument.removeEventListener('touchmove', touchEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener('touchend', touchEvents.upHandler);
            if (e.cancelable) {
              e.preventDefault();
              e.stopPropagation();
            }
            onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e)) {
          contextDocument == null || contextDocument.addEventListener('touchmove', touchEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener('touchend', touchEvents.upHandler, passiveIfSupported);
        } else {
          contextDocument == null || contextDocument.addEventListener('mousemove', mouseEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener('mouseup', mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo(old => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column.id
        }));
      };
    };
  },
  createTable: table => {
    table.setColumnSizing = updater => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = updater => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = defaultState => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = defaultState => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header) => {
        return sum + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header) => {
        return sum + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header) => {
        return sum + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header) => {
        return sum + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
let passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === 'boolean') return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop = () => {};
    window.addEventListener('test', noop, options);
    window.removeEventListener('test', noop);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e) {
  return e.type === 'touchstart';
}

//

const ColumnVisibility = {
  getInitialState: state => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onColumnVisibilityChange: makeStateUpdater('columnVisibility', table)
    };
  },
  createColumn: (column, table) => {
    column.toggleVisibility = value => {
      if (column.getCanHide()) {
        table.setColumnVisibility(old => ({
          ...old,
          [column.id]: value != null ? value : !column.getIsVisible()
        }));
      }
    };
    column.getIsVisible = () => {
      var _ref, _table$getState$colum;
      const childColumns = column.columns;
      return (_ref = childColumns.length ? childColumns.some(c => c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;
    };
    column.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column.getToggleVisibilityHandler = () => {
      return e => {
        column.toggleVisibility == null || column.toggleVisibility(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], cells => {
      return cells.filter(cell => cell.column.getIsVisible());
    }, getMemoOptions(table.options, 'debugRows'));
    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, 'debugRows'));
  },
  createTable: table => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter(d => d.getIsVisible()).map(d => d.id).join('_')], columns => {
        return columns.filter(d => d.getIsVisible == null ? void 0 : d.getIsVisible());
      }, getMemoOptions(table.options, 'debugColumns'));
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod('getVisibleFlatColumns', () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod('getVisibleLeafColumns', () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod('getLeftVisibleLeafColumns', () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod('getRightVisibleLeafColumns', () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod('getCenterVisibleLeafColumns', () => table.getCenterLeafColumns());
    table.setColumnVisibility = updater => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = defaultState => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = value => {
      var _value;
      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
        ...obj,
        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some(column => !(column.getIsVisible != null && column.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some(column => column.getIsVisible == null ? void 0 : column.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return e => {
        var _target;
        table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
function _getVisibleLeafColumns(table, position) {
  return !position ? table.getVisibleLeafColumns() : position === 'center' ? table.getCenterVisibleLeafColumns() : position === 'left' ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}

//

const GlobalFaceting = {
  createTable: table => {
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, '__global__');
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, '__global__');
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return new Map();
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, '__global__');
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};

//

const GlobalFiltering = {
  getInitialState: state => {
    return {
      globalFilter: undefined,
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onGlobalFilterChange: makeStateUpdater('globalFilter', table),
      globalFilterFn: 'auto',
      getColumnCanGlobalFilter: column => {
        var _table$getCoreRowMode;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
        return typeof value === 'string' || typeof value === 'number';
      }
    };
  },
  createColumn: (column, table) => {
    column.getCanGlobalFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;
      return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
    };
  },
  createTable: table => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      const {
        globalFilterFn: globalFilterFn
      } = table.options;
      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === 'auto' ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];
    };
    table.setGlobalFilter = updater => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = defaultState => {
      table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);
    };
  }
};

//

const RowExpanding = {
  getInitialState: state => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onExpandedChange: makeStateUpdater('expanded', table),
      paginateExpandedRows: true
    };
  },
  createTable: table => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = updater => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = expanded => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = defaultState => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some(row => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return e => {
        e.persist == null || e.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;

      // If expanded is true, save some cycles and return true
      if (typeof expanded === 'boolean') {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }

      // If any row is not expanded, return false
      if (table.getRowModel().flatRows.some(row => !row.getIsExpanded())) {
        return false;
      }

      // They must all be expanded :shrug:
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach(id => {
        const splitId = id.split('.');
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = expanded => {
      table.setExpanded(old => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach(rowId => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _,
            ...rest
          } = oldExpanded;
          return rest;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand) return;
        row.toggleExpanded();
      };
    };
  }
};

//

const defaultPageIndex = 0;
const defaultPageSize = 10;
const getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
const RowPagination = {
  getInitialState: state => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...(state == null ? void 0 : state.pagination)
      }
    };
  },
  getDefaultOptions: table => {
    return {
      onPaginationChange: makeStateUpdater('pagination', table)
    };
  },
  createTable: table => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued) return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = updater => {
      const safeUpdater = old => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = defaultState => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = updater => {
      table.setPagination(old => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === 'undefined' || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = defaultState => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = defaultState => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = updater => {
      table.setPagination(old => {
        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize);
        return {
          ...old,
          pageIndex,
          pageSize
        };
      });
    };
    //deprecated
    table.setPageCount = updater => table.setPagination(old => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === 'number') {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo(() => [table.getPageCount()], pageCount => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);
      }
      return pageOptions;
    }, getMemoOptions(table.options, 'debugTable'));
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex(old => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex(old => {
        return old + 1;
      });
    };
    table.firstPage = () => {
      return table.setPageIndex(0);
    };
    table.lastPage = () => {
      return table.setPageIndex(table.getPageCount() - 1);
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);
    };
    table.getRowCount = () => {
      var _table$options$rowCou;
      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;
    };
  }
};

//

const getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
const RowPinning = {
  getInitialState: state => {
    return {
      rowPinning: getDefaultRowPinningState(),
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onRowPinningChange: makeStateUpdater('rowPinning', table)
    };
  },
  createRow: (row, table) => {
    row.pin = (position, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map(_ref => {
        let {
          id
        } = _ref;
        return id;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map(_ref2 => {
        let {
          id
        } = _ref2;
        return id;
      }) : [];
      const rowIds = new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning(old => {
        var _old$top3, _old$bottom3;
        if (position === 'bottom') {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter(d => !(rowIds != null && rowIds.has(d))),
            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)]
          };
        }
        if (position === 'top') {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter(d => !(rowIds != null && rowIds.has(d)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter(d => !(rowIds != null && rowIds.has(d))),
          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter(d => !(rowIds != null && rowIds.has(d)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref3;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === 'function') {
        return enableRowPinning(row);
      }
      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top,
        bottom
      } = table.getState().rowPinning;
      const isTop = rowIds.some(d => top == null ? void 0 : top.includes(d));
      const isBottom = rowIds.some(d => bottom == null ? void 0 : bottom.includes(d));
      return isTop ? 'top' : isBottom ? 'bottom' : false;
    };
    row.getPinnedIndex = () => {
      var _ref4, _visiblePinnedRowIds$;
      const position = row.getIsPinned();
      if (!position) return -1;
      const visiblePinnedRowIds = (_ref4 = position === 'top' ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map(_ref5 => {
        let {
          id
        } = _ref5;
        return id;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
  },
  createTable: table => {
    table.setRowPinning = updater => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
    table.resetRowPinning = defaultState => {
      var _table$initialState$r, _table$initialState;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = position => {
      var _pinningState$positio;
      const pinningState = table.getState().rowPinning;
      if (!position) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table._getPinnedRows = (visibleRows, pinnedRowIds, position) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ?
      //get all rows that are pinned even if they would not be otherwise visible
      //account for expanded parent rows, but not pagination or filtering
      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => {
        const row = table.getRow(rowId, true);
        return row.getIsAllParentsExpanded() ? row : null;
      }) :
      //else get only visible rows that are pinned
      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => visibleRows.find(row => row.id === rowId));
      return rows.filter(Boolean).map(d => ({
        ...d,
        position
      }));
    };
    table.getTopRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, 'top'), getMemoOptions(table.options, 'debugRows'));
    table.getBottomRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, 'bottom'), getMemoOptions(table.options, 'debugRows'));
    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
      const topAndBottom = new Set([...(top != null ? top : []), ...(bottom != null ? bottom : [])]);
      return allRows.filter(d => !topAndBottom.has(d.id));
    }, getMemoOptions(table.options, 'debugRows'));
  }
};

//

const RowSelection = {
  getInitialState: state => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: table => {
    return {
      onRowSelectionChange: makeStateUpdater('rowSelection', table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: table => {
    table.setRowSelection = updater => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = defaultState => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = value => {
      table.setRowSelection(old => {
        value = typeof value !== 'undefined' ? value : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;

        // We don't use `mutateRowIsSelected` here for performance reasons.
        // All of the rows are flat already, so it wouldn't be worth it
        if (value) {
          preGroupedFlatRows.forEach(row => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach(row => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = value => table.setRowSelection(old => {
      const resolvedValue = typeof value !== 'undefined' ? value : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach(row => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });

    // addRowSelectionRange: rowId => {
    //   const {
    //     rows,
    //     rowsById,
    //     options: { selectGroupingRows, selectSubRows },
    //   } = table

    //   const findSelectedRow = (rows: Row[]) => {
    //     let found
    //     rows.find(d => {
    //       if (d.getIsSelected()) {
    //         found = d
    //         return true
    //       }
    //       const subFound = findSelectedRow(d.subRows || [])
    //       if (subFound) {
    //         found = subFound
    //         return true
    //       }
    //       return false
    //     })
    //     return found
    //   }

    //   const firstRow = findSelectedRow(rows) || rows[0]
    //   const lastRow = rowsById[rowId]

    //   let include = false
    //   const selectedRowIds = {}

    //   const addRow = (row: Row) => {
    //     mutateRowIsSelected(selectedRowIds, row.id, true, {
    //       rowsById,
    //       selectGroupingRows: selectGroupingRows!,
    //       selectSubRows: selectSubRows!,
    //     })
    //   }

    //   table.rows.forEach(row => {
    //     const isFirstRow = row.id === firstRow.id
    //     const isLastRow = row.id === lastRow.id

    //     if (isFirstRow || isLastRow) {
    //       if (!include) {
    //         include = true
    //       } else if (include) {
    //         addRow(row)
    //         include = false
    //       }
    //     }

    //     if (include) {
    //       addRow(row)
    //     }
    //   })

    //   table.setRowSelection(selectedRowIds)
    // },
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, 'debugTable'));
    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, 'debugTable'));
    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, 'debugTable'));

    ///

    // getGroupingRowCanSelect: rowId => {
    //   const row = table.getRow(rowId)

    //   if (!row) {
    //     throw new Error()
    //   }

    //   if (typeof table.options.enableGroupingRowSelection === 'function') {
    //     return table.options.enableGroupingRowSelection(row)
    //   }

    //   return table.options.enableGroupingRowSelection ?? false
    // },

    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some(row => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter(row => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some(row => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter(row => row.getCanSelect()).some(d => d.getIsSelected() || d.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return e => {
        table.toggleAllRowsSelected(e.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return e => {
        table.toggleAllPageRowsSelected(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value, opts) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection(old => {
        var _opts$selectChildren;
        value = typeof value !== 'undefined' ? value : !isSelected;
        if (row.getCanSelect() && isSelected === value) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === 'some';
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === 'all';
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === 'function') {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === 'function') {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === 'function') {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return e => {
        var _target;
        if (!canSelect) return;
        row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
const mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id, true);

  // const isGrouped = row.getIsGrouped()

  // if ( // TODO: enforce grouping row selection rules
  //   !isGrouped ||
  //   (isGrouped && table.options.enableGroupingRowSelection)
  // ) {
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach(key => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  // }

  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach(row => mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};

  // Filters top level and nested rows
  const recurseRows = function (rows, depth) {
    return rows.map(row => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach(subRow => {
    // Bail out early if we know both of these
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }

    // Check row selection of nested subrows
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === 'all') {
        someSelected = true;
      } else if (subRowChildrenSelected === 'some') {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? 'all' : someSelected ? 'some' : false;
}

const reSplitAlphaNumeric = /([0-9]+)/gm;
const alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
const alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};

// The text filter is more basic (less numeric support)
// but is much faster
const text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};

// The text filter is more basic (less numeric support)
// but is much faster
const textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
const datetime = (rowA, rowB, columnId) => {
  const a = rowA.getValue(columnId);
  const b = rowB.getValue(columnId);

  // Can handle nullish values
  // Use > and < because == (and ===) doesn't work with
  // Date objects (would require calling getTime()).
  return a > b ? 1 : a < b ? -1 : 0;
};
const basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};

// Utils

function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function toString(a) {
  if (typeof a === 'number') {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return '';
    }
    return String(a);
  }
  if (typeof a === 'string') {
    return a;
  }
  return '';
}

// Mixed sorting is slow, but very inclusive of many edge cases.
// It handles numbers, mixed alphanumeric combinations, and even
// null, undefined, and Infinity
function compareAlphanumeric(aStr, bStr) {
  // Split on number groups, but keep the delimiter
  // Then remove falsey split values
  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);

  // While
  while (a.length && b.length) {
    const aa = a.shift();
    const bb = b.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();

    // Both are string
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }

    // One is a string, one is a number
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }

    // Both are numbers
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a.length - b.length;
}

// Exports

const sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};

//

const RowSorting = {
  getInitialState: state => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: 'auto',
      sortUndefined: 1
    };
  },
  getDefaultOptions: table => {
    return {
      onSortingChange: makeStateUpdater('sorting', table),
      isMultiSortEvent: e => {
        return e.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString = false;
      for (const row of firstRows) {
        const value = row == null ? void 0 : row.getValue(column.id);
        if (Object.prototype.toString.call(value) === '[object Date]') {
          return sortingFns.datetime;
        }
        if (typeof value === 'string') {
          isString = true;
          if (value.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === 'string') {
        return 'asc';
      }
      return 'desc';
    };
    column.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === 'auto' ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
    };
    column.toggleSorting = (desc, multi) => {
      // if (column.columns.length) {
      //   column.columns.forEach((c, i) => {
      //     if (c.id) {
      //       table.toggleColumnSorting(c.id, undefined, multi || !!i)
      //     }
      //   })
      //   return
      // }

      // this needs to be outside of table.setSorting to be in sync with rerender
      const nextSortingOrder = column.getNextSortingOrder();
      const hasManualValue = typeof desc !== 'undefined' && desc !== null;
      table.setSorting(old => {
        // Find any existing sorting for this column
        const existingSorting = old == null ? void 0 : old.find(d => d.id === column.id);
        const existingIndex = old == null ? void 0 : old.findIndex(d => d.id === column.id);
        let newSorting = [];

        // What should we do with this sort action?
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === 'desc';

        // Multi-mode
        if (old != null && old.length && column.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = 'toggle';
          } else {
            sortAction = 'add';
          }
        } else {
          // Normal mode
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = 'replace';
          } else if (existingSorting) {
            sortAction = 'toggle';
          } else {
            sortAction = 'replace';
          }
        }

        // Handle toggle states that will remove the sorting
        if (sortAction === 'toggle') {
          // If we are "actually" toggling (not a manual set value), should we remove the sorting?
          if (!hasManualValue) {
            // Is our intention to remove?
            if (!nextSortingOrder) {
              sortAction = 'remove';
            }
          }
        }
        if (sortAction === 'add') {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column.id,
            desc: nextDesc
          }];
          // Take latest n columns
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === 'toggle') {
          // This flips (or sets) the
          newSorting = old.map(d => {
            if (d.id === column.id) {
              return {
                ...d,
                desc: nextDesc
              };
            }
            return d;
          });
        } else if (sortAction === 'remove') {
          newSorting = old.filter(d => d.id !== column.id);
        } else {
          newSorting = [{
            id: column.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === 'desc';
      return sortDescFirst ? 'desc' : 'asc';
    };
    column.getNextSortingOrder = multi => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column.getFirstSortDir();
      const isSorted = column.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && (
      // If enableSortRemove, enable in general
      multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true) // If multi, don't allow if enableMultiRemove))
      ) {
        return false;
      }
      return isSorted === 'desc' ? 'asc' : 'desc';
    };
    column.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
    };
    column.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
    };
    column.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find(d => d.id === column.id);
      return !columnSort ? false : columnSort.desc ? 'desc' : 'asc';
    };
    column.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex(d => d.id === column.id)) != null ? _table$getState$sorti2 : -1;
    };
    column.clearSorting = () => {
      //clear sorting for just 1 column
      table.setSorting(old => old != null && old.length ? old.filter(d => d.id !== column.id) : []);
    };
    column.getToggleSortingHandler = () => {
      const canSort = column.getCanSort();
      return e => {
        if (!canSort) return;
        e.persist == null || e.persist();
        column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);
      };
    };
  },
  createTable: table => {
    table.setSorting = updater => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
    table.resetSorting = defaultState => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};

const builtInFeatures = [Headers, ColumnVisibility, ColumnOrdering, ColumnPinning, ColumnFaceting, ColumnFiltering, GlobalFaceting,
//depends on ColumnFaceting
GlobalFiltering,
//depends on ColumnFiltering
RowSorting, ColumnGrouping,
//depends on RowSorting
RowExpanding, RowPagination, RowPinning, RowSelection, ColumnSizing];

//

function createTable(options) {
  var _options$_features, _options$initialState;
  const _features = [...builtInFeatures, ...((_options$_features = options._features) != null ? _options$_features : [])];
  let table = {
    _features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = options => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options);
    }
    return {
      ...defaultOptions,
      ...options
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...((_options$initialState = options.initialState) != null ? _options$initialState : {})
  };
  table._features.forEach(feature => {
    var _feature$getInitialSt;
    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features,
    options: {
      ...defaultOptions,
      ...options
    },
    initialState,
    _queue: cb => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;

        // Schedule a microtask to run the queued callbacks after
        // the current call stack (render, etc) has finished.
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch(error => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: updater => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: updater => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join('.') : index}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up

    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (id, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id];
        if (!row) {
          throw new Error();
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], defaultColumn => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: props => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: props => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options, 'debugColumns')),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], columnDefs => {
      const recurseColumns = function (columnDefs, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs.map(columnDef => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options, 'debugColumns')),
    getAllFlatColumns: memo(() => [table.getAllColumns()], allColumns => {
      return allColumns.flatMap(column => {
        return column.getFlatColumns();
      });
    }, getMemoOptions(options, 'debugColumns')),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], flatColumns => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, getMemoOptions(options, 'debugColumns')),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns) => {
      let leafColumns = allColumns.flatMap(column => column.getLeafColumns());
      return orderColumns(leafColumns);
    }, getMemoOptions(options, 'debugColumns')),
    getColumn: columnId => {
      const column = table._getAllFlatColumnsById()[columnId];
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index = 0; index < table._features.length; index++) {
    const feature = table._features[index];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}

function getCoreRowModel() {
  return table => memo(() => [table.options.data], data => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function (originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i = 0; i < originalRows.length; i++) {
        // This could be an expensive check at scale, so we should move it somewhere else, but where?
        // if (!id) {
        //   if (process.env.NODE_ENV !== 'production') {
        //     throw new Error(`getRowId expected an ID, but got ${id}`)
        //   }
        // }

        // Make the row
        const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);

        // Keep track of every row in a flat array
        rowModel.flatRows.push(row);
        // Also keep track of every row by its ID
        rowModel.rowsById[row.id] = row;
        // Push table row into parent
        rows.push(row);

        // Get the original subrows
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i], i);

          // Then recursively access them
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, 'debugTable', 'getRowModel', () => table._autoResetPageIndex()));
}

function getSortedRowModel() {
  return table => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];

    // Filter out sortings that correspond to non existing columns
    const availableSorting = sortingState.filter(sort => {
      var _table$getColumn;
      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();
    });
    const columnInfoById = {};
    availableSorting.forEach(sortEntry => {
      const column = table.getColumn(sortEntry.id);
      if (!column) return;
      columnInfoById[sortEntry.id] = {
        sortUndefined: column.columnDef.sortUndefined,
        invertSorting: column.columnDef.invertSorting,
        sortingFn: column.getSortingFn()
      };
    });
    const sortData = rows => {
      // This will also perform a stable sorting using the row index
      // if needed.
      const sortedData = rows.map(row => ({
        ...row
      }));
      sortedData.sort((rowA, rowB) => {
        for (let i = 0; i < availableSorting.length; i += 1) {
          var _sortEntry$desc;
          const sortEntry = availableSorting[i];
          const columnInfo = columnInfoById[sortEntry.id];
          const sortUndefined = columnInfo.sortUndefined;
          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;
          let sortInt = 0;

          // All sorting ints should always return in ascending order
          if (sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = aValue === undefined;
            const bUndefined = bValue === undefined;
            if (aUndefined || bUndefined) {
              if (sortUndefined === 'first') return aUndefined ? -1 : 1;
              if (sortUndefined === 'last') return aUndefined ? 1 : -1;
              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? sortUndefined : -sortUndefined;
            }
          }
          if (sortInt === 0) {
            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          }

          // If sorting is non-zero, take care of desc and inversion
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });

      // If there are sub-rows, sort them
      sortedData.forEach(row => {
        var _row$subRows;
        sortedFlatRows.push(row);
        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
          row.subRows = sortData(row.subRows);
        }
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, getMemoOptions(table.options, 'debugTable', 'getSortedRowModel', () => table._autoResetPageIndex()));
}

function flexRender(Comp, props) {
  if (!Comp) return null;
  if (typeof Comp === 'function') {
    return Comp(props);
  }
  return Comp;
}
class TableController {
  tableInstance = null;
  _tableState = null;
  constructor(host) {
    (this.host = host).addController(this);
  }
  table(options) {
    if (!this.tableInstance) {
      const resolvedOptions = {
        state: {},
        onStateChange: () => {},
        // noop
        renderFallbackValue: null,
        ...options
      };
      this.tableInstance = createTable(resolvedOptions);
      this._tableState = {
        ...this.tableInstance.initialState,
        ...options.state
      };
    }
    this.tableInstance.setOptions(prev => ({
      ...prev,
      state: {
        ...this._tableState,
        ...options.state
      },
      onStateChange: updater => {
        this._tableState = updater(this._tableState);
        this.host.requestUpdate();
        options.onStateChange == null || options.onStateChange(updater);
      }
    }));
    return this.tableInstance;
  }
  hostDisconnected() {}
}

var styles$a = i$4`@charset "UTF-8";
.m-table {
  --color-table-row-background: transparent;
  --table-row-border-bottom: inset 0 -1px var(--color-border-default);
  --space-table-cell: var(--space-s);
  --size-table-cell-min-height: var(--unit-6);
  --radius-table: var(--radius-m);
  overflow: hidden;
  width: 100%;
  table-layout: fixed;
  text-align: left;
  vertical-align: top;
  border-collapse: collapse;
  border-spacing: 0;
  border-radius: var(--radius-table);
  box-sizing: border-box;
  height: 0;
  font-weight: var(--font-weight-regular);
  margin: unset;
  font-family: var(--font-family);
  line-height: var(--line-height);
  font-size: var(--font-size-m);
  leading-trim: both;
  text-edge: cap;
}

.m-table-body, .m-table-header, .m-table-row {
  vertical-align: inherit;
}

.m-table-row {
  color: var(--color-text-default);
}

.m-table-cell {
  background-color: var(--color-table-row-background);
  box-sizing: border-box;
  vertical-align: inherit;
  box-shadow: var(--table-row-border-bottom);
  padding: var(--space-table-cell);
  height: var(--size-table-cell-min-height);
  font-weight: var(--font-weight-regular);
}

.m-table-column-header-cell {
  font-weight: var(--font-weight-bold);
  margin: unset;
  font-family: var(--font-family);
  line-height: var(--line-height-heading);
  line-height: unset;
}

.m-table-row-header-cell {
  font-weight: var(--font-weight-regular);
  margin: unset;
  font-family: var(--font-family);
  line-height: var(--line-height);
}

.m-table-align-right {
  text-align: end;
}

.m-table:not(.is-variant-ghost) {
  border-radius: var(--radius-table);
  background-color: var(--color-background-secondary);
  position: relative;
}

.m-table:not(.is-variant-ghost) :where(.m-table-header) {
  --color-table-row-background: var(--color-background-tertiary);
}

.m-table:not(.is-variant-ghost) :where(.m-table-body .m-table-row:last-child) {
  --table-row-border-bottom: none;
}

.m-table.is-variant-ghost {
  --color-table-row-background: transparent;
  background-color: rgba(0, 0, 0, 0);
}

.m-checkbox {
  display: flex;
  align-items: center;
  position: relative;
}

.m-checkbox label {
  display: flex;
  align-items: center;
  cursor: pointer;
  font-size: var(--font-size-m);
}

.m-checkbox input[type=checkbox] {
  cursor: pointer;
  opacity: 0;
  position: absolute;
}

.m-checkbox label:before {
  content: "";
  width: var(--unit-5);
  height: var(--unit-5);
  border-radius: var(--radius-m);
  margin-right: var(--size-gap-m);
  border: 1px solid var(--color-border-default);
  background-color: var(--color-background-secondary);
}

.m-checkbox input[type=checkbox]:focus + label:before {
  outline-style: solid;
  outline-color: rgba(0, 0, 0, 0);
  box-shadow: var(--color-shadow-accent) 0 0 0 2px;
  border-color: var(--color-shadow-accent);
}

.m-checkbox input[type=checkbox]:disabled + label, .m-checkbox input[type=checkbox]:disabled {
  color: var(--color-text-disabled);
  cursor: default;
}

.m-checkbox input[type=checkbox]:checked + label:before {
  content: "âœ“";
  background-color: var(--color-accent);
  display: flex;
  justify-content: center;
  align-items: center;
  color: var(--color-text-contrast);
}

.m-checkbox input[type=checkbox]:disabled + label:before {
  background-color: var(--color-background-tertiary);
  color: var(--color-text-disabled);
}

@media (pointer: fine) {
  .m-checkbox label:hover:before, .m-checkbox input[type=checkbox]:hover + label:before {
    background-color: var(--color-background-tertiary);
  }
  .m-checkbox input[type=checkbox]:checked:hover + label:before {
    background-color: var(--success-400);
  }
  .m-checkbox input[type=checkbox]:disabled:hover + label:before {
    background-color: var(--color-background-tertiary);
  }
}
.m-table.is-layout-auto {
  table-layout: auto;
}`;

let MTable = class MTable extends s$1 {
    constructor() {
        super(...arguments);
        this.columns = [];
        this.data = [];
        this.variant = "classic";
        this.layout = "fixed";
        this._sorting = [];
        this._hoveredRowId = "";
        this.tableController = new TableController(this);
    }
    _handleRowClick(row) {
        this.dispatchEvent(new CustomEvent("row-click", { bubbles: true, composed: true, detail: { row, }, }));
    }
    _handleRowMouseEnter(row) {
        this._hoveredRowId = row.id;
    }
    _handleRowMouseLeave(row) {
        this._hoveredRowId = "";
    }
    render() {
        const table = new TableController(this).table({
            // temporary TS workaround
            columns: this.columns,
            data: this.data,
            state: {
                sorting: this._sorting,
            },
            onSortingChange: updaterOrValue => {
                this._sorting = typeof updaterOrValue === "function"
                    ? updaterOrValue(this._sorting)
                    : updaterOrValue;
            },
            getSortedRowModel: getSortedRowModel(),
            getCoreRowModel: getCoreRowModel(),
        });
        const classes = e$1({
            "m-table": true,
            [`is-variant-${this.variant}`]: true,
            [`is-layout-${this.layout}`]: true,
        });
        return x `
            <table part="table" class=${classes} style="position: static;">
                <thead part="header" class="m-table-header">
                    <tr class="m-table-row">
                        ${c(table.getHeaderGroups(), headerGroup => headerGroup.id, headerGroup => x `${c(headerGroup.headers, header => header.id, header => {
            var _a;
            return x `<th 
                                                class="m-table-cell m-table-column-header-cell m-stack is-horizontal is-align-center"
                                                style="cursor: ${header.column.getCanSort()
                ? "pointer"
                : "auto"}"
                                                @click=${header.column.getToggleSortingHandler()}
                                            >
                                                <m-stack horizontal align-center>
                                                    ${header.isPlaceholder
                ? null
                : flexRender(header.column.columnDef.header, header.getContext())}
                                                    ${(_a = {
                asc: x `<m-icon name="arrow-up"></m-icon>`,
                desc: x `<m-icon name="arrow-down"></m-icon>`
            }[header.column.getIsSorted()]) !== null && _a !== void 0 ? _a : null}
                                                </m-stack>
                                        </th>`;
        })}`)}
                    </tr>
                </thead>
                <tbody class="m-table-body">
                    ${c(table.getRowModel().rows, row => row.id, row => x `
                            <tr
                                class="m-table-row"
                                @click=${() => this._handleRowClick(row)}
                                @mouseenter=${() => this._handleRowMouseEnter(row)}
                                @mouseleave=${() => this._handleRowMouseLeave(row)}
                                style=${row.original.clickable ? "cursor: pointer;" : ""}
                            >
                                    ${c(row.getVisibleCells(), cell => cell.id, cell => x `<td class="m-table-cell">
                                                ${flexRender(cell.column.columnDef.cell, Object.assign(Object.assign({}, cell.getContext()), { 
            // @ts-ignore
            rowHovered: this._hoveredRowId === row.id }))}
                                            </td>
                                        `)}
                            </tr>
                        `)}
                </tbody>
            </table>
        `;
    }
};
MTable.styles = styles$a;
__decorate([
    n$1({ type: Array })
], MTable.prototype, "columns", void 0);
__decorate([
    n$1({ type: Array })
], MTable.prototype, "data", void 0);
__decorate([
    n$1()
], MTable.prototype, "variant", void 0);
__decorate([
    n$1()
], MTable.prototype, "layout", void 0);
__decorate([
    r$1()
], MTable.prototype, "_sorting", void 0);
__decorate([
    r$1()
], MTable.prototype, "_hoveredRowId", void 0);
MTable = __decorate([
    t$2("m-table")
], MTable);

var styles$9 = i$4`.m-text {
  font-family: var(--font-family);
  font-weight: var(--font-weight-regular);
  font-size: var(--font-size-m);
  line-height: var(--line-height-default);
  margin: unset;
  color: var(--color-text-default);
}

.m-text.is-size-2xl {
  font-size: var(--font-size-2xl);
  line-height: var(--line-height-2xl);
}

.m-text.is-size-xl {
  font-size: var(--font-size-xl);
  line-height: var(--line-height-xl);
}

.m-text.is-size-l {
  font-size: var(--font-size-l);
  line-height: var(--line-height-l);
}

.m-text.is-size-m {
  font-size: var(--font-size-m);
  line-height: var(--line-height-m);
}

.m-text.is-size-s {
  font-size: var(--font-size-s);
  line-height: var(--line-height-s);
}

.m-text.is-size-xs {
  font-size: var(--font-size-xs);
  line-height: var(--line-height-xs);
}

.m-text.is-primary, .m-text > .is-primary {
  color: var(--color-text-primary);
}

.m-text.is-secondary, .m-text > .is-secondary {
  color: var(--color-text-secondary);
}

.m-text.is-tertiary, .m-text > .is-tertiary {
  color: var(--color-text-tertiary);
}

.m-text.is-accent {
  color: var(--color-text-accent);
}

.m-text.is-warning {
  color: var(--color-text-warning);
}

.m-text.is-error {
  color: var(--color-text-error);
}

.m-text.is-success {
  color: var(--color-text-success);
}

.m-text.has-measure-l {
  max-inline-size: var(--size-measure-content-l);
}

.m-text.has-measure-m {
  max-inline-size: var(--size-measure-content-m);
}

.m-text.has-measure-s {
  max-inline-size: var(--size-measure-content-s);
}

.m-text.is-truncated {
  display: inline-block;
  max-width: 100%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  word-wrap: normal;
}

.m-text.has-text-left {
  text-align: left;
}

.m-text.has-text-centered {
  text-align: center;
}

.m-text.has-text-right {
  text-align: right;
}

.m-text.m-text.is-currency {
  font-feature-settings: "aalt" on;
}

.m-text.is-tabular {
  font-feature-settings: "tnum" on, "case" on;
  font-variant-numeric: tabular-nums;
}

:host {
  display: inline-flex;
}`;

let MText = class MText extends s$1 {
    constructor() {
        super(...arguments);
        this.as = "p";
        this.size = "s";
        this.variant = "primary";
    }
    render() {
        const classes = e$1({
            "m-text": true,
            [`is-size-${this.size}`]: true,
            [`is-${this.variant}`]: true,
        });
        return n `
            <${i(this.as)} class=${classes} part="text">
                <slot></slot>
            </${i(this.as)}>
        `;
    }
};
MText.styles = styles$9;
__decorate([
    n$1()
], MText.prototype, "as", void 0);
__decorate([
    n$1()
], MText.prototype, "size", void 0);
__decorate([
    n$1()
], MText.prototype, "variant", void 0);
MText = __decorate([
    t$2("m-text")
], MText);

var styles$8 = i$4`:root {
  --m-uishell-header-height: var(--unit-11);
  --m-uishell-left-panel-width: var(--unit-15);
  --m-uishell-color-background: var(--foundry-gray-900);
  --m-uishell-header-color-background: var(--black);
}

:root:has(body[data-color-scheme=light]) {
  --m-uishell-color-background: var(--foundry-gray-100);
  --m-uishell-header-color-background: var(--white);
}

.m-uishell {
  background: var(--color-background-default);
  color: var(--color-text-default);
  display: grid;
  align-self: start;
  grid-template-columns: var(--m-uishell-left-panel-width) 1fr var(--m-uishell-left-panel-width);
  grid-template-rows: var(--m-uishell-header-height) 1fr;
  grid-template-areas: "brand header header" "leftpanel main main";
  height: 100dvh;
}

.m-uishell .m-uishell-brand {
  grid-area: brand;
  border-bottom: 1px solid var(--color-border-default);
  border-right: 1px solid var(--color-border-default);
  background: var(--m-uishell-color-background);
  display: flex;
  align-items: center;
  padding: calc(var(--space-s) + var(--space-xs)) var(--space-l);
  z-index: var(--index-nav);
}

.m-uishell .m-uishell-header {
  grid-area: header;
  background-color: var(--m-uishell-color-background);
  padding-inline: var(--space-l);
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-m);
  border-bottom: 1px solid var(--color-border-default);
  position: relative;
  z-index: var(--index-nav);
}

.m-uishell .m-uishell-header.has-img {
  background-image: url("/dots.png");
  background-size: 92rem;
  background-repeat: no-repeat;
  background-position: -200px -12rem;
  background-color: var(--m-uishell-header-color-background);
}

.m-uishell .m-uishell-header.has-img .m-uishell-overlay {
  position: absolute;
  width: 100%;
  height: 100%;
  background: linear-gradient(45deg, transparent -50%, var(--m-uishell-header-color-background) 80%);
  right: 0;
}

.m-uishell .m-uishell-header .m-uishell-nav-toggle {
  z-index: var(--index-200);
  display: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  -webkit-font-smoothing: inherit;
  appearance: none;
  background: none;
  border: 0;
  box-sizing: border-box;
  color: inherit;
  cursor: pointer;
  font: inherit;
  letter-spacing: inherit;
  margin: 0;
  outline: 0;
  overflow: visible;
  padding: 0;
  vertical-align: top;
  width: fit-content;
  margin-top: var(--space-xs);
}

.m-uishell .m-uishell-header .m-uishell-heading {
  z-index: var(--index-200);
  font-family: var(--font-family-display);
  font-size: var(--font-size-display-m);
  font-weight: var(--font-weight-semibold);
  margin: unset;
  white-space: nowrap;
}

.m-uishell .m-uishell-header .m-uishell-actions {
  display: flex;
  align-items: center;
  gap: var(--space-l);
  width: 100%;
  justify-content: end;
  z-index: var(--index-200);
}

.m-uishell .m-uishell-left-panel {
  grid-area: leftpanel;
  background-color: var(--m-uishell-color-background);
  border-right: 1px solid var(--color-border-default);
  overflow-y: auto;
  -ms-overflow-style: none;
  scrollbar-width: none;
  z-index: var(--index-nav);
}

.m-uishell .m-uishell-left-panel::-webkit-scrollbar {
  display: none;
}

.m-uishell .m-uishell-content {
  background: var(--color-background-default);
  grid-area: main;
  overflow-y: auto;
}

@media (max-width: 1150px) {
  .m-uishell {
    grid-template-columns: 1fr;
    grid-template-areas: "header header header" "main main main";
  }
  .m-uishell .m-uishell-brand {
    display: none;
  }
  .m-uishell .m-uishell-header .m-uishell-nav-toggle {
    display: block;
  }
  .m-uishell .m-uishell-header .m-uishell-heading {
    display: none;
  }
  .m-uishell .m-uishell-left-panel {
    display: none;
    position: fixed;
    width: var(--m-uishell-left-panel-width);
    left: 0;
    top: var(--m-uishell-header-height);
    z-index: var(--index-nav);
    height: calc(100dvh - var(--m-uishell-header-height));
  }
  .m-uishell .m-uishell-left-panel.is-open {
    display: block;
  }
}
.m-nav {
  display: grid;
  grid-row-gap: var(--unit-2);
  grid-template-columns: 100%;
}`;

let MUIShell = class MUIShell extends s$1 {
    constructor() {
        super(...arguments);
        this.title = "";
    }
    render() {
        return x `
            <div class="m-uishell">
                <div class="m-uishell-brand">
                    <svg xmlns="http://www.w3.org/2000/svg" width="149" height="49" viewBox="0 0 149 49" fill="none">
                        <path d="M38.3948 43.2576C36.8779 43.2576 35.4649 42.9923 34.1672 42.4732C32.8637 41.9483 31.7333 41.2101 30.7643 40.2642C29.7954 39.3183 29.0456 38.2109 28.5034 36.9421C27.9613 35.6732 27.6902 34.3063 27.6902 32.824C27.6902 31.3418 27.9555 29.9691 28.4919 28.706C29.0225 27.4429 29.7723 26.3413 30.7412 25.4012C31.7102 24.461 32.8406 23.7286 34.1441 23.2037C35.4476 22.6789 36.8664 22.4193 38.4006 22.4193C39.9348 22.4193 41.3536 22.6846 42.6571 23.2037C43.9605 23.7286 45.091 24.461 46.0599 25.4012C47.0289 26.3413 47.7787 27.4429 48.3093 28.706C48.8399 29.9691 49.111 31.3475 49.111 32.824C49.111 34.3005 48.8399 35.679 48.2977 36.9421C47.7556 38.2052 47 39.3126 46.0369 40.2642C45.0679 41.2159 43.9375 41.9483 42.634 42.4732C41.3305 42.998 39.9232 43.2576 38.4063 43.2576H38.3948ZM38.3948 39.4625C39.3176 39.4625 40.1712 39.301 40.9556 38.9723C41.74 38.6493 42.4321 38.1936 43.0319 37.6053C43.626 37.0171 44.0874 36.3192 44.4162 35.506C44.7449 34.6927 44.9064 33.7987 44.9064 32.824C44.9064 31.8493 44.7449 30.9611 44.4162 30.1536C44.0874 29.3462 43.6318 28.6483 43.0319 28.0542C42.4379 27.4602 41.7458 26.9988 40.9556 26.6873C40.1712 26.3701 39.3176 26.2144 38.3948 26.2144C37.472 26.2144 36.6184 26.3701 35.834 26.6873C35.0496 27.0045 34.3575 27.4602 33.7577 28.0542C33.1636 28.6483 32.7022 29.3519 32.3735 30.1536C32.0505 30.9553 31.8832 31.8493 31.8832 32.824C31.8832 33.7987 32.0447 34.6927 32.3735 35.506C32.6964 36.3192 33.1579 37.0171 33.7577 37.6053C34.3517 38.1936 35.0438 38.6493 35.834 38.9723C36.6184 39.2952 37.472 39.4625 38.3948 39.4625Z" fill="currentColor"/>
                        <path d="M51.2393 48.3558V28.1347H55.0343V30.955L54.6825 30.1418C55.1727 29.3978 55.836 28.8268 56.6723 28.4173C57.5144 28.0135 58.4776 27.8059 59.5619 27.8059C60.9692 27.8059 62.2438 28.1462 63.3858 28.8383C64.522 29.5246 65.4275 30.4532 66.0965 31.6183C66.7656 32.7833 67.1001 34.0868 67.1001 35.5345C67.1001 36.9821 66.7713 38.2625 66.1081 39.4391C65.4506 40.6157 64.5508 41.5443 63.4089 42.2306C62.2669 42.917 60.9807 43.263 59.533 43.263C58.5237 43.263 57.5836 43.0785 56.73 42.7093C55.8706 42.3402 55.1785 41.7923 54.6537 41.0713L55.3054 40.2293V48.3616H51.2393V48.3558ZM59.0486 39.6006C59.8099 39.6006 60.4732 39.4276 61.0557 39.0873C61.6324 38.747 62.0881 38.2625 62.4111 37.6512C62.734 37.0398 62.9013 36.3304 62.9013 35.5345C62.9013 34.7385 62.7398 34.0407 62.4111 33.4351C62.0881 32.8295 61.6324 32.3508 61.0557 31.9989C60.4789 31.6471 59.8099 31.4683 59.0486 31.4683C58.2872 31.4683 57.6816 31.6413 57.1107 31.9816C56.5397 32.3277 56.0956 32.8064 55.7841 33.4178C55.4669 34.0349 55.3112 34.7385 55.3112 35.5345C55.3112 36.3304 55.4669 37.034 55.7841 37.6512C56.1013 38.2683 56.5454 38.747 57.1107 39.0873C57.6816 39.4333 58.3276 39.6006 59.0486 39.6006Z" fill="currentColor"/>
                        <path d="M75.7976 43.0951C74.0096 43.0951 72.6197 42.6106 71.6392 41.6474C70.6529 40.6785 70.1627 39.3288 70.1627 37.5928V31.658H67.6711V28.134H67.8037C68.5651 28.134 69.1476 27.9437 69.5513 27.563C69.9608 27.1823 70.1627 26.6171 70.1627 25.8558V24.7715H74.2288V28.134H77.7009V31.658H74.2288V37.3217C74.2288 37.8293 74.3211 38.2503 74.4999 38.5791C74.6787 38.9136 74.9613 39.1616 75.342 39.3231C75.7226 39.4846 76.1898 39.5653 76.7493 39.5653C76.8761 39.5653 77.0203 39.5538 77.1818 39.5365C77.3433 39.5192 77.5163 39.5019 77.6951 39.4846V42.9278C77.4241 42.9624 77.1184 42.997 76.7723 43.0374C76.4263 43.072 76.1033 43.0893 75.7976 43.0893V43.0951Z" fill="currentColor"/>
                        <path d="M79.5409 26.8017V22.7356H83.607V26.8017H79.5409ZM79.5409 42.9279V28.1283H83.607V42.9279H79.5409Z" fill="currentColor"/>
                        <path d="M86.3465 42.9337V22.7356H100.171V26.398H90.5453V31.5196H98.8103V35.1763H90.5453V42.9279H86.3408L86.3465 42.9337Z" fill="currentColor"/>
                        <path d="M101.417 42.9344V22.4133H105.483V42.9344H101.417Z" fill="currentColor"/>
                        <path d="M115.052 43.2563C113.477 43.2563 112.116 42.9103 110.957 42.2124C109.798 41.5145 108.904 40.5802 108.275 39.4036C107.64 38.227 107.323 36.9293 107.323 35.4989C107.323 34.0686 107.652 32.6959 108.315 31.5424C108.973 30.3888 109.867 29.4718 110.986 28.8028C112.105 28.1337 113.373 27.7992 114.781 27.7992C115.957 27.7992 116.995 27.9838 117.901 28.3529C118.806 28.722 119.568 29.2411 120.191 29.9101C120.814 30.5792 121.287 31.352 121.615 32.2287C121.938 33.1054 122.106 34.057 122.106 35.0894C122.106 35.3778 122.094 35.6662 122.065 35.943C122.036 36.2256 121.99 36.4621 121.915 36.664H110.83V33.6821H119.614L117.688 35.0894C117.866 34.3108 117.861 33.6245 117.659 33.0131C117.463 32.4075 117.111 31.9288 116.615 31.577C116.119 31.2251 115.507 31.0463 114.786 31.0463C114.066 31.0463 113.477 31.2194 112.97 31.5597C112.462 31.9057 112.081 32.4075 111.833 33.0765C111.585 33.7456 111.482 34.5588 111.534 35.5162C111.459 36.3468 111.562 37.0792 111.833 37.7137C112.105 38.3481 112.52 38.8383 113.079 39.1902C113.639 39.542 114.319 39.7208 115.115 39.7208C115.836 39.7208 116.459 39.5766 116.972 39.2882C117.486 38.9998 117.889 38.6019 118.178 38.0943L121.431 39.64C121.142 40.361 120.687 40.9954 120.064 41.5376C119.441 42.0797 118.703 42.5008 117.855 42.8007C117.007 43.1006 116.073 43.2505 115.063 43.2505L115.052 43.2563Z" fill="currentColor"/>
                        <path d="M131.074 43.2563C129.5 43.2563 128.138 42.9103 126.979 42.2124C125.82 41.5145 124.926 40.5802 124.297 39.4036C123.663 38.227 123.346 36.9293 123.346 35.4989C123.346 34.0686 123.674 32.6959 124.338 31.5424C124.995 30.3888 125.889 29.4718 127.008 28.8028C128.127 28.1337 129.396 27.7992 130.803 27.7992C131.98 27.7992 133.018 27.9838 133.923 28.3529C134.829 28.722 135.59 29.2411 136.213 29.9101C136.836 30.5792 137.309 31.352 137.638 32.2287C137.961 33.1054 138.128 34.057 138.128 35.0894C138.128 35.3778 138.116 35.6662 138.087 35.943C138.059 36.2256 138.012 36.4621 137.937 36.664H126.852V33.6821H135.636L133.71 35.0894C133.889 34.3108 133.883 33.6245 133.681 33.0131C133.485 32.4075 133.133 31.9288 132.637 31.577C132.141 31.2251 131.53 31.0463 130.809 31.0463C130.088 31.0463 129.5 31.2194 128.992 31.5597C128.484 31.9057 128.104 32.4075 127.856 33.0765C127.608 33.7456 127.504 34.5588 127.556 35.5162C127.481 36.3468 127.585 37.0792 127.856 37.7137C128.127 38.3481 128.542 38.8383 129.102 39.1902C129.661 39.542 130.342 39.7208 131.138 39.7208C131.858 39.7208 132.481 39.5766 132.995 39.2882C133.508 38.9998 133.912 38.6019 134.2 38.0943L137.453 39.64C137.165 40.361 136.709 40.9954 136.086 41.5376C135.463 42.0797 134.725 42.5008 133.877 42.8007C133.029 43.1006 132.095 43.2505 131.086 43.2505L131.074 43.2563Z" fill="currentColor"/>
                        <path d="M147.091 43.0951C145.303 43.0951 143.913 42.6106 142.932 41.6474C141.946 40.6785 141.456 39.3288 141.456 37.5928V31.658H138.964V28.134H139.103C139.864 28.134 140.447 27.9437 140.85 27.563C141.26 27.1823 141.462 26.6171 141.462 25.8558V24.7715H145.528V28.134H149V31.658H145.528V37.3217C145.528 37.8293 145.62 38.2503 145.799 38.5791C145.978 38.9136 146.26 39.1616 146.641 39.3231C147.022 39.4846 147.489 39.5653 148.048 39.5653C148.175 39.5653 148.319 39.5538 148.481 39.5365C148.642 39.5192 148.815 39.5019 148.994 39.4846V42.9278C148.723 42.9624 148.417 42.997 148.071 43.0374C147.725 43.072 147.402 43.0893 147.097 43.0893L147.091 43.0951Z" fill="currentColor"/>
                        <path d="M13.8421 9.22813C16.3904 9.22813 18.4562 7.16234 18.4562 4.61406C18.4562 2.06579 16.3904 0 13.8421 0C11.2938 0 9.22803 2.06579 9.22803 4.61406C9.22803 7.16234 11.2938 9.22813 13.8421 9.22813Z" fill="currentColor"/>
                        <path d="M4.61406 16.1494C7.16234 16.1494 9.22813 14.0836 9.22813 11.5353C9.22813 8.98705 7.16234 6.92126 4.61406 6.92126C2.06579 6.92126 0 8.98705 0 11.5353C0 14.0836 2.06579 16.1494 4.61406 16.1494Z" fill="currentColor"/>
                        <path d="M4.61406 29.9903C7.16234 29.9903 9.22813 27.9245 9.22813 25.3763C9.22813 22.828 7.16234 20.7622 4.61406 20.7622C2.06579 20.7622 0 22.828 0 25.3763C0 27.9245 2.06579 29.9903 4.61406 29.9903Z" fill="currentColor"/>
                        <path d="M13.8421 23.0699C16.3904 23.0699 18.4562 21.0041 18.4562 18.4559C18.4562 15.9076 16.3904 13.8418 13.8421 13.8418C11.2938 13.8418 9.22803 15.9076 9.22803 18.4559C9.22803 21.0041 11.2938 23.0699 13.8421 23.0699Z" fill="var(--color-brand-orange)"/>
                        <path d="M13.8421 36.9125C16.3904 36.9125 18.4562 34.8467 18.4562 32.2984C18.4562 29.7501 16.3904 27.6843 13.8421 27.6843C11.2938 27.6843 9.22803 29.7501 9.22803 32.2984C9.22803 34.8467 11.2938 36.9125 13.8421 36.9125Z" fill="var(--color-brand-orange)"/>
                        <path d="M4.61406 43.8343C7.16234 43.8343 9.22813 41.7685 9.22813 39.2203C9.22813 36.672 7.16234 34.6062 4.61406 34.6062C2.06579 34.6062 0 36.672 0 39.2203C0 41.7685 2.06579 43.8343 4.61406 43.8343Z" fill="var(--color-brand-orange)"/>
                        <path d="M33.7461 4.78687V5.94615C33.6884 5.94615 33.625 5.94615 33.5615 5.94615C32.9444 5.94615 32.333 5.94615 31.7159 5.94615C31.341 5.94615 31.2487 6.03266 31.2487 6.40755C31.2487 6.64403 31.2487 6.88626 31.2487 7.14581H33.7288V8.42621H31.2603V13.519H29.4838V8.44351H27.6786V7.16311H29.4723C29.4723 7.04776 29.4723 6.94971 29.4723 6.85743C29.4781 6.45946 29.4435 6.05573 29.5761 5.6693C29.7549 5.16176 30.1356 4.91375 30.6489 4.83301C30.7181 4.82147 30.7873 4.80994 30.8565 4.7984C31.8139 4.7984 32.7771 4.7984 33.7345 4.7984L33.7461 4.78687Z" fill="currentColor"/>
                        <path d="M66.5464 8.2587V4.83276H68.2998V13.513H66.5464V11.7769C66.4311 12.2153 66.2234 12.5786 65.8889 12.8728C65.4736 13.2361 64.9719 13.4149 64.4355 13.5072C63.6972 13.6341 62.959 13.611 62.2323 13.438C61.0788 13.1611 60.2944 12.4748 59.9887 11.3098C59.7176 10.2716 59.7349 9.23342 60.1329 8.2241C60.4097 7.52045 60.9173 7.02444 61.6151 6.71876C62.3361 6.40154 63.1032 6.3381 63.876 6.37271C64.4759 6.40154 65.0642 6.52266 65.589 6.84565C66.0677 7.14556 66.3965 7.54929 66.4945 8.12028C66.5003 8.15489 66.5233 8.18949 66.5522 8.27024L66.5464 8.2587ZM66.5407 9.98321C66.5407 9.59678 66.5407 9.21035 66.5407 8.82969C66.5407 8.4721 66.3676 8.24717 66.0446 8.11451C65.6351 7.94149 65.1968 7.90111 64.7585 7.86651C64.1759 7.82037 63.605 7.82613 63.034 7.94725C62.3534 8.09144 61.8574 8.4548 61.6843 9.15844C61.5632 9.66022 61.5632 10.1678 61.6613 10.6753C61.7939 11.3617 62.2207 11.7885 62.8955 11.9615C63.4723 12.1114 64.0548 12.123 64.6489 12.0826C65.0988 12.0538 65.5429 12.0076 65.9697 11.8577C66.3792 11.7135 66.5464 11.4885 66.5464 11.0502C66.5464 10.6926 66.5464 10.3408 66.5464 9.98321H66.5407Z" fill="currentColor"/>
                        <path d="M42.4265 9.97092C42.4092 10.5708 42.3227 11.1475 42.0747 11.6897C41.7459 12.4164 41.1922 12.9009 40.4598 13.1892C39.5023 13.5641 38.5103 13.6218 37.4952 13.5411C36.8031 13.4834 36.1341 13.3565 35.5169 13.0277C34.698 12.5894 34.225 11.9031 34.0289 11.0033C33.879 10.2997 33.879 9.59603 34.0289 8.89239C34.2135 8.06185 34.646 7.40435 35.3958 6.97178C36.036 6.60266 36.7281 6.4527 37.4549 6.38926C38.0547 6.33735 38.6545 6.34888 39.2543 6.42963C39.9176 6.51614 40.5578 6.70071 41.1115 7.08713C41.7344 7.52547 42.1208 8.13107 42.2765 8.86932C42.3515 9.23267 42.3746 9.6018 42.4207 9.96516L42.4265 9.97092ZM35.7015 9.95362C35.7188 10.1497 35.7246 10.3458 35.7534 10.5419C35.8515 11.1475 36.1629 11.5916 36.7627 11.7935C37.6048 12.0761 38.4584 12.0588 39.312 11.88C39.9061 11.7531 40.3444 11.4128 40.5174 10.8072C40.627 10.4093 40.6386 9.99976 40.604 9.5845C40.5232 8.71359 40.0791 8.23488 39.2716 8.05032C38.5853 7.89459 37.8932 7.90036 37.2068 8.01571C36.7051 8.10223 36.2437 8.29832 35.9726 8.7655C35.7592 9.13462 35.7015 9.53835 35.7015 9.95939V9.95362Z" fill="currentColor"/>
                        <path d="M50.7373 13.5134H48.9609V11.6216C48.8802 11.9677 48.7706 12.2964 48.563 12.5906C48.2169 13.0693 47.7267 13.3346 47.1672 13.4615C46.3021 13.6576 45.4312 13.6403 44.5833 13.3461C43.5798 13.0001 43.0145 12.2906 42.8819 11.2352C42.8588 11.0506 42.8473 10.8661 42.8473 10.6815C42.8473 9.32611 42.8473 7.9765 42.8473 6.62112C42.8473 6.5519 42.8473 6.48269 42.8473 6.40771H44.6064C44.6064 6.47116 44.6064 6.54037 44.6064 6.60958C44.6064 7.89575 44.5949 9.17615 44.6064 10.4623C44.6122 11.264 44.9525 11.737 45.7657 11.9331C46.5789 12.1292 47.3979 12.1061 48.1996 11.8638C48.5457 11.76 48.8456 11.5639 48.9378 11.1775C48.9552 11.1025 48.9551 11.0275 48.9551 10.9526C48.9551 9.5049 48.9551 8.05724 48.9551 6.61535V6.41925H50.7316V13.5249L50.7373 13.5134Z" fill="currentColor"/>
                        <path d="M79.0677 10.791C79.3099 10.3296 79.5406 9.88547 79.7713 9.44713C80.2847 8.46665 80.8037 7.48616 81.3228 6.50567C81.3517 6.45376 81.4209 6.40186 81.4728 6.40186C82.0726 6.39609 82.6782 6.40186 83.3011 6.40186C83.1511 6.68447 83.0069 6.94977 82.8628 7.21508C82.534 7.81491 82.2053 8.41474 81.8765 9.0088C81.4324 9.81626 80.9941 10.6237 80.5442 11.4196C80.302 11.8464 80.054 12.2617 79.7771 12.6654C79.3445 13.2999 78.7101 13.6517 77.9719 13.819C77.3374 13.9631 76.6915 13.992 76.0455 14.0151C75.8494 14.0151 75.6475 14.0151 75.4399 14.0151V12.527C75.8898 12.527 76.3339 12.5386 76.778 12.527C77.1817 12.5155 77.5739 12.452 77.9373 12.2502C78.191 12.106 78.3929 11.9157 78.5832 11.6561C78.2775 11.6561 78.0065 11.6561 77.7354 11.6561C77.6431 11.6561 77.597 11.6273 77.5451 11.5465C76.53 9.94891 75.5149 8.3513 74.494 6.75368C74.4248 6.64409 74.3614 6.53451 74.2864 6.41339C74.3325 6.41339 74.3729 6.40186 74.4075 6.40186C74.99 6.40186 75.5783 6.40186 76.1608 6.40186C76.23 6.40186 76.3281 6.45953 76.3627 6.51721C76.8529 7.27853 77.3317 8.04561 77.8104 8.8127C78.2141 9.4529 78.6121 10.0931 79.01 10.7333C79.0216 10.7448 79.0331 10.7564 79.0677 10.7967V10.791Z" fill="currentColor"/>
                        <path d="M53.2348 8.65693C53.1656 7.90138 53.6155 7.10545 54.3191 6.73633C54.7056 6.53446 55.1208 6.43641 55.5592 6.39027C56.1532 6.32683 56.7358 6.36143 57.3125 6.50562C58.0277 6.67865 58.6102 7.04778 58.9794 7.69375C59.1812 8.04557 59.3081 8.43776 59.3139 8.84149C59.3312 10.3641 59.3312 11.8868 59.3369 13.4094C59.3369 13.4383 59.3369 13.4671 59.3254 13.5075H57.5605V13.3171C57.5605 12.0483 57.5548 10.7736 57.5605 9.50477C57.5663 8.61656 57.1049 8.14938 56.3436 7.99366C55.5246 7.82063 54.7056 7.83793 53.9039 8.11478C53.604 8.21859 53.3848 8.40316 53.2464 8.68577C53.2406 8.68 53.2348 8.66847 53.2291 8.6627L53.2348 8.65693Z" fill="currentColor"/>
                        <path d="M70.7679 13.5137H69.0031V6.41384H70.7622V8.49017C70.8371 8.23062 70.8891 7.95378 70.9986 7.70001C71.2351 7.12902 71.685 6.76566 72.2617 6.56379C72.8385 6.36193 73.4268 6.32732 74.0381 6.40807V8.12681C73.5998 8.0922 73.173 8.02876 72.7462 8.02876C72.2906 8.02876 71.8292 8.0749 71.3966 8.26523C70.9583 8.46133 70.7564 8.74971 70.7622 9.20534C70.7737 10.578 70.7622 11.9449 70.7622 13.3176V13.531L70.7679 13.5137Z" fill="currentColor"/>
                        <path d="M53.2519 8.68017C53.2346 8.84166 53.2115 9.00315 53.2058 9.16465C53.2058 10.5489 53.2058 11.9273 53.2058 13.3115V13.5076H51.4236V6.40198H53.2346V8.65133C53.2346 8.65133 53.2461 8.66864 53.2519 8.6744V8.68017Z" fill="currentColor"/>
                    </svg>
                </div>
                <header class="m-uishell-header" style="background-image: url(/img/dots.png);">
                    <div class="m-uishell-overlay"></div>
                    <button type="button" class="m-uishell-nav-toggle" onclick="ms.toggleSideNav();">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg>
                    </button>
                    <h2 class="m-uishell-heading">${this.title}</h2>
                    <div class="m-uishell-actions">
                        <slot name="actions"></slot>
                        <m-icon name="user"></m-icon>
                    </div>
                </header>
                <div class="m-uishell-left-panel">
                    <m-box variant="ghost" space="s">
                        <slot name="left-panel"></slot>
                    </m-box>
                </div>
                <div class="m-uishell-content" part="content">
                    <slot name="main-content"></slot>
                </div>
            </div> 
        `;
    }
};
MUIShell.styles = styles$8;
__decorate([
    n$1()
], MUIShell.prototype, "title", void 0);
MUIShell = __decorate([
    t$2("m-uishell")
], MUIShell);

var styles$7 = i$4`.op-header {
  height: 100%;
  padding-block: var(--space-l);
}`;

let OPHeader = class OPHeader extends s$1 {
    render() {
        return x `
            <header class="op-header">
                <slot></slot>
            </header>
        `;
    }
};
OPHeader.styles = styles$7;
OPHeader = __decorate([
    t$2("op-header")
], OPHeader);

var styles$6 = i$4`.op-large-select {
  display: inline-flex;
  position: relative;
  overflow: hidden;
  max-inline-size: fit-content;
  height: var(--size-control-default);
  border-radius: var(--radius-m);
  cursor: pointer;
}
.op-large-select select {
  all: unset;
  box-sizing: border-box;
  width: var(--unit-15);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: var(--font-size-l);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-l);
  color: var(--color-text-primary);
  margin: unset;
  font-family: var(--font-family);
  leading-trim: both;
  text-edge: cap;
  /*background-color: var(--m-select-color-background-default);
  border: 1px solid var(--m-select-color-border);*/
  background: var(--color-background-secondary);
  border: 1px solid var(--color-border-secondary);
  padding-inline: var(--space-control-inline);
  border-radius: var(--radius-m);
  height: var(--size-control-default);
  padding-inline-end: var(--unit-6);
}
.op-large-select select option {
  font-size: var(--font-size-s);
  background-color: var(--color-background-tertiary);
}
.op-large-select.has-placeholder {
  color: var(--color-text-tertiary);
}
.op-large-select::after {
  stroke: var(--chevron-color-icon);
  content: url('data:image/svg+xml; utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="rgb(255, 255, 255)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg>');
  width: var(--size-control-default);
  height: var(--size-control-default);
  overflow: hidden;
  border: 1px solid transparent;
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  padding-top: 2px;
  pointer-events: none;
}
:host([data-color-scheme=light]) .op-large-select::after {
  content: url('data:image/svg+xml; utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="rgb(26, 33, 30)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg>');
}`;

let OPLargeSelect = class OPLargeSelect extends s$1 {
    constructor() {
        super();
        this.selected = null;
        this.options = [{ label: "Loading...", value: "0" }];
        this.updateColorScheme = this.updateColorScheme.bind(this);
    }
    connectedCallback() {
        super.connectedCallback();
        this.updateColorScheme();
        this.observer = new MutationObserver(this.updateColorScheme);
        this.observer.observe(document.body, { attributes: true, attributeFilter: ["data-color-scheme"] });
    }
    updateColorScheme() {
        const colorScheme = document.body.getAttribute("data-color-scheme") || "dark";
        this.setAttribute("data-color-scheme", colorScheme);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        if (this.observer) {
            this.observer.disconnect();
        }
    }
    _handleOnChange(e) {
        const value = e.target.value;
        const label = e.target.options[e.target.selectedIndex].text;
        this.dispatchEvent(new CustomEvent("on-change", { bubbles: true, composed: true, detail: { value, label } }));
    }
    render() {
        return x `
            <div class="op-large-select">
                <select @change=${this._handleOnChange}>
                    ${this.options.map((option) => {
            let isSelected = this.selected !== null && option.value.endsWith(this.selected);
            return x `<option ?selected=${isSelected} value=${option.value}>${option.label}</option>`;
        })}
                </select>
            </div>
        `;
    }
};
OPLargeSelect.styles = styles$6;
__decorate([
    n$1()
], OPLargeSelect.prototype, "selected", void 0);
__decorate([
    n$1()
], OPLargeSelect.prototype, "options", void 0);
OPLargeSelect = __decorate([
    t$2("op-large-select")
], OPLargeSelect);

var styles$5 = i$4`.op-menu-item {
  background: none;
  border: none;
  width: 100%;
  cursor: pointer;
  display: grid;
  grid-template-columns: var(--space-m) 1fr;
  gap: var(--size-gap-default);
  font-size: var(--font-size-s);
  padding: var(--space-s) var(--space-s);
  border-radius: var(--radius-default);
}
.op-menu-item .op-menu-icon {
  display: none;
}
.op-menu-item[aria-current=true] .op-menu-icon {
  display: block;
  stroke: var(--color-icon-accent);
}
.op-menu-item:hover {
  background: var(--dropdown-menu-hover);
}
.op-menu-item .op-menu-item-label {
  text-align: start;
}`;

let OPMenu = class OPMenu extends s$1 {
    constructor() {
        super(...arguments);
        this.menuItems = [{ label: "Loading...", id: "loadingId" }];
    }
    _handleOnClick(id, label) {
        this.dispatchEvent(new CustomEvent("on-click", { bubbles: true, composed: true, detail: { id, label } }));
    }
    render() {
        return n `
            <div class="op-menu">
                ${this.menuItems.map((menuItem) => n `<button class="op-menu-item" id=${menuItem.id} aria-current=${menuItem.id === this.selected} @click=${() => this._handleOnClick(menuItem.id, menuItem.label)}>
                        <div>
                            <svg
                                xmlns="http://www.w3.org/2000/svg"
                                width="16"
                                height="16"
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                stroke-width="4"
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                class="lucide lucide-check op-menu-icon"><path d="M20 6 9 17l-5-5" /></svg
                            >
                        </div>
                        <span class="op-menu-item-label">${menuItem.label}</span>
                    </button>`)}
            </div>
        `;
    }
};
OPMenu.styles = styles$5;
__decorate([
    n$1()
], OPMenu.prototype, "selected", void 0);
__decorate([
    n$1()
], OPMenu.prototype, "menuItems", void 0);
OPMenu = __decorate([
    t$2("op-menu")
], OPMenu);

var OPRefreshButton_1;
let OPRefreshButton = OPRefreshButton_1 = class OPRefreshButton extends s$1 {
    constructor() {
        super(...arguments);
        this.onRefresh = () => __awaiter(this, void 0, void 0, function* () { });
        this.countdownDisabled = false;
        this.disabled = true;
        this._seconds = OPRefreshButton_1.REFRESH_INTERVAL_SECONDS;
        this._lastRefresh = this._getTime();
        this._refreshing = false;
        this._rotation = 0;
        this.prevSecTimestamp = null;
        this.countdownStartTimestamp = null;
        this.prevFrameTimestamp = null;
    }
    connectedCallback() {
        super.connectedCallback();
        requestAnimationFrame(this._animFrame.bind(this));
    }
    _animFrame(timestamp) {
        this._tick.call(this, timestamp);
        requestAnimationFrame(this._animFrame.bind(this));
    }
    _tick(timestamp) {
        if (this.prevFrameTimestamp === null) {
            this.prevFrameTimestamp = timestamp;
        }
        let timePassedSincePrevFrame = timestamp - this.prevFrameTimestamp;
        let multiplier = timePassedSincePrevFrame / 16.666666666666667;
        this.prevFrameTimestamp = timestamp;
        if (this._refreshing) {
            this._rotation += OPRefreshButton_1.ROTATION_SPEED * multiplier;
            if (this._rotation >= 180) {
                this._rotation = 0;
            }
            return;
        }
        if (!this._refreshing && this._rotation !== 0) {
            if (this._rotation - OPRefreshButton_1.ROTATION_SPEED <= 0) {
                this._rotation = 0;
                return;
            }
            if (this._rotation >= 180) {
                this._rotation = 0;
                return;
            }
            this._rotation += OPRefreshButton_1.ROTATION_SPEED * multiplier;
            return;
        }
        if (this.countdownDisabled) {
            return;
        }
        if (this.countdownStartTimestamp === null) {
            this.countdownStartTimestamp = timestamp;
        }
        if (this.prevSecTimestamp === null) {
            this.prevSecTimestamp = timestamp;
        }
        let timeSincePrevSec = timestamp - this.prevSecTimestamp;
        timestamp - this.countdownStartTimestamp;
        let didSecondPass = timeSincePrevSec >= 1000;
        if (didSecondPass) {
            this._seconds--;
            this.prevSecTimestamp = timestamp;
        }
        if (didSecondPass && this._seconds === 0) {
            this.refresh();
        }
    }
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            this.prevSecTimestamp = null;
            this.countdownStartTimestamp = null;
            this._refreshing = true;
            yield this.onRefresh();
            this._refreshing = false;
            this._seconds = OPRefreshButton_1.REFRESH_INTERVAL_SECONDS;
            this._lastRefresh = this._getTime();
        });
    }
    _getTimeZoneAbrev() {
        return new Date()
            .toLocaleString("en-US", { timeZoneName: "short" })
            .split(' ').pop();
    }
    _getTime() {
        return window.moment().format("h:mma") + " " + this._getTimeZoneAbrev();
    }
    render() {
        let textVariant = this.disabled ? "tertiary" : "primary";
        return x `<m-stack horizontal align-center>
            <m-text variant=${textVariant}>
                Last Updated: ${this._lastRefresh}
            </m-text>
            ${(this.countdownDisabled || this.disabled)
            ? T
            : x `<m-text variant=${textVariant}>|</m-text><m-text variant=${textVariant} style="min-width: 25px;">${this._seconds}s</m-text>`}
            <button 
                type="button"
                style="background: none; cursor: ${this.disabled ? "auto" : "pointer"}; padding: 0; border: none; margin-left: var(--space-s);"
                @click=${this.refresh}
                ?disabled=${this.disabled}
            >
                <m-icon
                    name="refresh-cw"
                    size="l"
                    style=${`
                        transform: rotate(${this._rotation}deg);
                        color: var(--color-text-${textVariant});
                    `}
                ></m-icon>
            </button>
        </m-stack>`;
    }
};
OPRefreshButton.REFRESH_INTERVAL_SECONDS = 60;
OPRefreshButton.ROTATION_SPEED = 3;
__decorate([
    n$1()
], OPRefreshButton.prototype, "onRefresh", void 0);
__decorate([
    n$1({ type: Boolean, attribute: "countdown-disabled" })
], OPRefreshButton.prototype, "countdownDisabled", void 0);
__decorate([
    n$1({ type: Boolean })
], OPRefreshButton.prototype, "disabled", void 0);
__decorate([
    r$1()
], OPRefreshButton.prototype, "_seconds", void 0);
__decorate([
    r$1()
], OPRefreshButton.prototype, "_lastRefresh", void 0);
__decorate([
    r$1()
], OPRefreshButton.prototype, "_refreshing", void 0);
__decorate([
    r$1()
], OPRefreshButton.prototype, "_rotation", void 0);
OPRefreshButton = OPRefreshButton_1 = __decorate([
    t$2("op-refresh-button")
], OPRefreshButton);

var styles$4 = i$4`.op-tab-root {
  display: grid;
  row-gap: var(--space-m);
  grid-template-columns: 100%;
}

.op-tab-group {
  display: flex;
  font-size: var(--font-size-l);
  margin-top: var(--size-l);
  gap: 0px !important;
  box-shadow: 0 1px 0px 0px var(--color-border-default);
}

.op-tab {
  cursor: pointer;
  padding: 5px 10px;
  user-select: none;
}
.op-tab[aria-current=true] {
  color: var(--color-text-accent);
  box-shadow: 0 1px 0px 0px var(--color-border-accent);
}

.op-tab-section {
  display: none;
}`;

let OpTabContent = class OpTabContent extends s$1 {
    render() {
        return n `
            <div class="op-tab-content">
                <slot></slot>
            </div>
        `;
    }
};
OpTabContent.styles = styles$4;
OpTabContent = __decorate([
    t$2("op-tab-content")
], OpTabContent);

let OPTabGroup = class OPTabGroup extends s$1 {
    render() {
        return n `
            <div class="op-tab-group">
                <slot></slot>
            </div>
        `;
    }
};
OPTabGroup.styles = styles$4;
OPTabGroup = __decorate([
    t$2("op-tab-group")
], OPTabGroup);

let OpTabRoot = class OpTabRoot extends s$1 {
    updated() {
        this.updateComplete.then(() => {
            let id = this.selected;
            if (!id) {
                const tabs = this.getTabs();
                id = tabs[0].getAttribute("for");
            }
            this.changeTab(id);
        });
    }
    getUpdateComplete() {
        const _super = Object.create(null, {
            getUpdateComplete: { get: () => super.getUpdateComplete }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.getUpdateComplete.call(this);
            const sections = this.getSections();
            yield Promise.all(sections.map(el => el.updatedComplete));
            return true;
        });
    }
    getTabs() {
        const tabGroup = this.shadowRoot.querySelector('slot[name="tab-group"]').assignedNodes()
            .find(node => node.nodeName.toLowerCase() === 'op-tab-group');
        const tabs = tabGroup ? Array.from(tabGroup.querySelectorAll('op-tab')) : [];
        return tabs;
    }
    getSections() {
        const tabContent = this.shadowRoot.querySelector('slot[name="tab-content"]').assignedNodes()
            .find(node => node.nodeName.toLowerCase() === 'op-tab-content');
        const sections = tabContent ? Array.from(tabContent.querySelectorAll('op-tab-section')) : [];
        return sections;
    }
    changeTab(id) {
        const sections = this.getSections();
        const tabs = this.getTabs();
        sections.forEach(section => {
            const elem = section.shadowRoot.querySelector(".op-tab-section");
            if (section.id === id) {
                elem.style.display = 'block';
                return;
            }
            elem.style.display = 'none';
        });
        tabs.forEach(tab => {
            if (tab.getAttribute("for") === id) {
                tab.selected = true;
                return;
            }
            tab.selected = false;
        });
    }
    _handleOnClick(e) {
        const id = e.target.getAttribute("for");
        if (id) {
            this.changeTab(id);
        }
    }
    render() {
        return n `
            <div class="op-tab-root" @click=${this._handleOnClick.bind(this)}>
                <slot name="tab-group"></slot> 
                <slot name="tab-content"></slot> 
            </div>
        `;
    }
};
OpTabRoot.styles = styles$4;
__decorate([
    n$1()
], OpTabRoot.prototype, "selected", void 0);
OpTabRoot = __decorate([
    t$2("op-tab-root")
], OpTabRoot);

let OpTabSection = class OpTabSection extends s$1 {
    render() {
        return n `
            <div class="op-tab-section">
                <slot></slot>
            </div>
        `;
    }
};
OpTabSection.styles = styles$4;
OpTabSection = __decorate([
    t$2("op-tab-section")
], OpTabSection);

let OPTab = class OPTab extends s$1 {
    constructor() {
        super(...arguments);
        this.selected = false;
    }
    render() {
        return n `
            <div class="op-tab" aria-current=${this.selected}>
                <slot></slot>
            </div>
        `;
    }
};
OPTab.styles = styles$4;
__decorate([
    n$1({ type: Boolean })
], OPTab.prototype, "selected", void 0);
OPTab = __decorate([
    t$2("op-tab")
], OPTab);

var styles$3 = i$4`.op-weather-widget {
  width: var(--unit-15);
  background-color: var(--color-background-secondary);
  padding: var(--space-m);
  border-radius: var(--radius-m);
  box-shadow: var(--shadow-box);
  display: grid;
  grid-template-columns: 100%;
  grid-row-gap: var(--size-gap-m);
  /*background-color: var(--color-background-tertiary);
  box-shadow: inset 0 0 0 1px var(--color-border-secondary);*/
  /*background: linear-gradient(to right, var(--black), 25%, var(--color-background-tertiary));
  box-shadow: inset 0 0 0 1px var(--color-border-primary);*/
  /*background: linear-gradient(to right, var(--black), 80%, var(--color-brand));
  box-shadow: inset 0 0 0 1px var(--color-border-primary);*/
}`;

let OPWeatherWidget = class OPWeatherWidget extends s$1 {
    constructor() {
        super(...arguments);
        this.hidden = false;
        this.temperature = "";
        this.humidity = "";
        this.wind = "";
    }
    render() {
        return x `
            <div class="op-weather-widget" aria-hidden=${this.hidden}>
                <!-- Temperature -->
                <m-stack horizontal space-between align-center space="l">
                    <m-stack horizontal align-center>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
                            <g clip-path="url(#clip0_3085_14059)">
                                <path d="M7.99992 10.6666C9.47268 10.6666 10.6666 9.47274 10.6666 7.99998C10.6666 6.52722 9.47268 5.33331 7.99992 5.33331C6.52716 5.33331 5.33325 6.52722 5.33325 7.99998C5.33325 9.47274 6.52716 10.6666 7.99992 10.6666Z" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M8 1.33331V2.66665" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M8 13.3333V14.6666" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M3.28662 3.28668L4.22662 4.22668" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M11.7734 11.7733L12.7134 12.7133" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M1.33325 8H2.66659" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M13.3333 8H14.6666" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M4.22662 11.7733L3.28662 12.7133" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M12.7134 3.28668L11.7734 4.22668" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                            </g>
                            <defs>
                                <clipPath id="clip0_3085_14059">
                                    <rect width="16" height="16" fill="white" />
                                </clipPath>
                            </defs>
                        </svg>
                        <m-text size="s" variant="secondary">Temperature </m-text>
                    </m-stack>
                    <m-text size="s">${this.temperature}</m-text>
                </m-stack>
                <!-- Humidity -->
                <m-stack horizontal space-between align-center space="l">
                    <m-stack horizontal align-center>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
                            <path d="M7.99992 14.6667C9.2376 14.6667 10.4246 14.175 11.2998 13.2998C12.1749 12.4247 12.6666 11.2377 12.6666 10C12.6666 8.66667 11.9999 7.4 10.6666 6.33333C9.33325 5.26667 8.33325 3.66667 7.99992 2C7.66659 3.66667 6.66659 5.26667 5.33325 6.33333C3.99992 7.4 3.33325 8.66667 3.33325 10C3.33325 11.2377 3.82492 12.4247 4.70009 13.2998C5.57526 14.175 6.76224 14.6667 7.99992 14.6667Z" stroke="#96C7F2" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                        </svg>
                        <m-text size="s" variant="secondary">Humidity </m-text>
                    </m-stack>
                    <m-text size="s">${this.humidity}</m-text>
                </m-stack>
                <!-- Wind -->
                <m-stack horizontal space-between align-center space="l">
                    <m-stack horizontal align-center>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
                            <path d="M11.7999 5.13332C11.9951 4.94543 12.2331 4.80793 12.4933 4.73273C12.7535 4.65754 13.0282 4.64691 13.2935 4.70177C13.5588 4.75663 13.8067 4.87533 14.0157 5.04758C14.2248 5.21984 14.3887 5.44046 14.4933 5.69034C14.5979 5.94022 14.6401 6.21183 14.616 6.48166C14.592 6.75149 14.5026 7.01139 14.3555 7.23887C14.2084 7.46635 14.0081 7.65455 13.7719 7.78717C13.5357 7.91979 13.2707 7.99284 12.9999 7.99999H1.33325" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M6.39992 3.06668C6.55437 2.90915 6.7455 2.7924 6.95617 2.72691C7.16684 2.66142 7.39047 2.64923 7.60702 2.69143C7.82356 2.73363 8.02625 2.8289 8.19691 2.9687C8.36758 3.10851 8.50088 3.28848 8.58488 3.49248C8.66888 3.69648 8.70095 3.91813 8.67821 4.13757C8.65547 4.35701 8.57864 4.56738 8.45459 4.74982C8.33055 4.93227 8.16317 5.08108 7.96747 5.18292C7.77176 5.28476 7.55385 5.33644 7.33325 5.33334H1.33325" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M8.39992 12.9334C8.55437 13.0909 8.7455 13.2076 8.95617 13.2731C9.16684 13.3386 9.39047 13.3508 9.60702 13.3086C9.82356 13.2664 10.0262 13.1711 10.1969 13.0313C10.3676 12.8915 10.5009 12.7116 10.5849 12.5076C10.6689 12.3036 10.701 12.0819 10.6782 11.8625C10.6555 11.643 10.5786 11.4327 10.4546 11.2502C10.3305 11.0678 10.1632 10.919 9.96747 10.8171C9.77176 10.7153 9.55385 10.6636 9.33325 10.6667H1.33325" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                        </svg>
                        <m-text size="s" variant="secondary">Wind </m-text>
                    </m-stack>
                    <m-text size="s">${this.wind}</m-text>
                </m-stack>
            </div>
        `;
    }
};
OPWeatherWidget.styles = styles$3;
__decorate([
    n$1({ type: Boolean })
], OPWeatherWidget.prototype, "hidden", void 0);
__decorate([
    n$1()
], OPWeatherWidget.prototype, "temperature", void 0);
__decorate([
    n$1()
], OPWeatherWidget.prototype, "humidity", void 0);
__decorate([
    n$1()
], OPWeatherWidget.prototype, "wind", void 0);
OPWeatherWidget = __decorate([
    t$2("op-weather-widget")
], OPWeatherWidget);

const MAX_FETCH_RETRIES = 3;
/**
 * Base service class for getting and posting data
 * BaseURL is fixed to /OptiFleet.Portal/api
 * Auto attaches DefaultRequest (see OptiFleet.Service project) properties to the requests
 * */
class OptiFleetService {
    constructor() {
        if (self.window.location.href.toLowerCase().indexOf("optifleet.portal") > -1) {
            this.baseUrl = "/OptiFleet.Portal/api";
            self.axios.defaults.baseURL = "/OptiFleet.Portal/api";
        }
        else {
            this.baseUrl = "/api";
            self.axios.defaults.baseURL = "/api";
        }
        $(window).on('beforeunload', (ev) => {
            if (this.cancelTokenSource) {
                this.cancelTokenSource.cancel("aborting for navigation");
            }
        });
    }
    /**
     * Toggles a busy blocker
     * @param isBusy
     */
    toggleBusy(isBusy) {
        if (!isBusy) {
            $(".screen-busy").removeClass("active");
            return;
        }
        $(".screen-busy").addClass("active");
    }
    /**
     * Post data to web api endpoint
     * usage: this.post<YourType>("/YourService", {yourOptionalObject}).then(() => ...)
     * @param url
     * The endpoint for your service
     * @param data
     * Optional data to post
     */
    post(url, data, queryAuth) {
        if (!this.cancelTokenSource) {
            const token = self.axios.CancelToken;
            this.cancelTokenSource = token.source();
        }
        let config = { cancelToken: this.cancelTokenSource.token };
        if (!data) {
            data = {};
        }
        const user = localStorage.getItem("OptiFleetID");
        const selectedCompany = JSON.parse(localStorage.getItem("selectedCompany"));
        if (queryAuth) {
            if (url.indexOf("?") === -1) {
                url = url + `?userId=${user}`;
            }
            else {
                url = url + `&userId=${user}`;
            }
            url = url + `&companyFilter=${selectedCompany}`;
        }
        else {
            if (data instanceof FormData) {
                data.append("userId", user);
                data.append("companyFilter", selectedCompany);
                config['headers'] = {
                    'Content-Type': 'multipart/form-data'
                };
            }
            else {
                data["userId"] = user;
                data["companyFilter"] = selectedCompany;
            }
        }
        return self.axios.post(url, data, config)
            .then((response) => {
            return response.data;
        })
            .catch((err) => {
            return err;
        });
    }
    /**
     * Patch data to web api endpoint
     * usage: this.patch<YourType>("/YourService", {yourOptionalObject}).then(() => ...)
     * @param url
     * The endpoint for your service
     * @param data
     * Optional data to post
     */
    patch(url, data, queryAuth) {
        if (!this.cancelTokenSource) {
            const token = self.axios.CancelToken;
            this.cancelTokenSource = token.source();
        }
        let config = { cancelToken: this.cancelTokenSource.token };
        if (!data) {
            data = {};
        }
        let user = localStorage.getItem("OptiFleetID");
        let selectedCompany = JSON.parse(localStorage.getItem("selectedCompany"));
        if (queryAuth) {
            if (url.indexOf("?") === -1) {
                url = url + `?userId=${user}`;
            }
            else {
                url = url + `&userId=${user}`;
            }
            url = url + `&companyFilter=${selectedCompany}`;
        }
        else {
            if (data instanceof FormData) {
                data.append("userId", user);
                data.append("companyFilter", selectedCompany);
                config['headers'] = {
                    'Content-Type': 'multipart/form-data'
                };
            }
            else {
                data["userId"] = user;
                data["companyFilter"] = selectedCompany;
            }
        }
        return self.axios.patch(url, data, config)
            .then((response) => {
            return response.data;
        })
            .catch((err) => {
            return err;
        });
    }
    /**
     * Post data to web api endpoint
     * usage: this.get<YourType>("/YourService?param=value").then(() => ...)
     * @param url
     * The endpoint for your service with optional parameters
     */
    get(url_1) {
        return __awaiter(this, arguments, void 0, function* (url, retries = 0, rawResonse = false) {
            try {
                const resp = this._get(url, rawResonse);
                return resp;
            }
            catch (err) {
                if (retries < MAX_FETCH_RETRIES) {
                    // wait 750 ms before retrying
                    yield new Promise(resolve => setTimeout(resolve, 750));
                    return this.get(url, ++retries, rawResonse);
                }
                return err;
            }
        });
    }
    /**
     * Post data to web api endpoint
     * usage: this.get<YourType>("/YourService?param=value").then(() => ...)
     * @param url
     * The endpoint for your service with optional parameters
     */
    _get(url, raw) {
        if (!this.cancelTokenSource) {
            const token = self.axios.CancelToken;
            this.cancelTokenSource = token.source();
        }
        const user = localStorage.getItem("OptiFleetID");
        const selectedCompany = JSON.parse(localStorage.getItem("selectedCompany"));
        if (url.indexOf("?") === -1) {
            url = url + `?userId=${user}`;
        }
        else {
            url = url + `&userId=${user}`;
        }
        url = url + `&companyFilter=${selectedCompany}`;
        if (raw) {
            return self.axios.get(url, { cancelToken: this.cancelTokenSource.token });
        }
        return self.axios.get(url, { cancelToken: this.cancelTokenSource.token })
            .then((response) => {
            return response.data;
        })
            .catch((err) => {
            return err;
        });
    }
    /**
     * Send DELETE to web api endpoint
     * usage: this.delete<YourType>("/YourService", {yourOptionalObject}).then(() => ...)
     * @param url
     * The endpoint for your service
     * @param data
     * Optional data to post
     */
    delete(url, data, queryAuth) {
        if (!this.cancelTokenSource) {
            const token = self.axios.CancelToken;
            this.cancelTokenSource = token.source();
        }
        let config = { cancelToken: this.cancelTokenSource.token };
        if (!data) {
            data = {};
        }
        const user = localStorage.getItem("OptiFleetID");
        const selectedCompany = JSON.parse(localStorage.getItem("selectedCompany"));
        if (queryAuth) {
            if (url.indexOf("?") === -1) {
                url = url + `?userId=${user}`;
            }
            else {
                url = url + `&userId=${user}`;
            }
            url = url + `&companyFilter=${selectedCompany}`;
        }
        else {
            if (data instanceof FormData) {
                data.append("userId", user);
                data.append("companyFilter", selectedCompany);
                config['headers'] = {
                    'Content-Type': 'multipart/form-data'
                };
            }
            else {
                data["userId"] = user;
                data["companyFilter"] = selectedCompany;
            }
        }
        return self.axios.delete(url, { data: data }, config)
            .then((response) => {
            return response.data;
        })
            .catch((err) => {
            return err;
        });
    }
}

class PrometheusRange extends OptiFleetService {
    constructor(queries, graphBusySelector) {
        super();
        this.minute = 60 * 1000;
        /** ID for a busy element */
        this.graphBusySelector = null;
        this.selectedInterval = parseInt(localStorage.getItem("graphInterval"));
        if (!this.selectedInterval) {
            this.selectedInterval = (60 * 5);
        }
        this.graphBusySelector = graphBusySelector;
        this.queries = queries;
        this.currentQueryParams = TimePickerDropdown.getDefaultParams();
    }
    /**
     * Loads the series data for the chart
     * @param extraParams
     */
    load(extraParams) {
        return __awaiter(this, void 0, void 0, function* () {
            if (extraParams) {
                this.extraParams = extraParams;
            }
            yield this.loadQueries();
        });
    }
    loadQueries() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.queries)
                return;
            if (this.queries.length == 1) {
                yield this.loadSingleQuery();
                return;
            }
            yield this.loadMultiQuery();
        });
    }
    loadQuery(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.post(query, this.getParams());
            if (!response.data.result[0]) {
                response.data.result.push({
                    values: [],
                    metric: {
                        __name__: ""
                    }
                });
            }
            return response;
        });
    }
    loadSingleQuery() {
        return __awaiter(this, void 0, void 0, function* () {
            this.toggleGraphBusy(true);
            const resp = yield this.loadQuery(this.queries[0]);
            this.toggleGraphBusy(false);
            this.onGraphDataLoaded([resp]);
        });
    }
    loadMultiQuery() {
        return __awaiter(this, void 0, void 0, function* () {
            let promises = [];
            this.queries.forEach((query) => {
                promises.push(this.loadQuery(query));
            });
            this.toggleGraphBusy(true);
            const data = yield self.Promise.all(promises);
            this.toggleGraphBusy(false);
            this.onGraphDataLoaded(data);
        });
    }
    toggleGraphBusy(isBusy) {
        if (!this.graphBusySelector) {
            this.toggleBusy(isBusy);
            return;
        }
        if (!isBusy) {
            $(this.graphBusySelector).removeClass("active");
            return;
        }
        $(this.graphBusySelector).addClass("active");
    }
    getParams() {
        let obj = Object.assign({}, this.currentQueryParams);
        if (this.extraParams && this.extraParams.length > 0) {
            this.extraParams.forEach((param) => {
                obj[param[0]] = param[1];
            });
            return obj;
        }
        return obj;
    }
}

/**
 * Base class most page classes should extend
 * Handles companyFilterChanged and extends OptiFleetService
 * */
let confirmationModal;
class OptiFleetPage extends OptiFleetService {
    set refreshFunction(val) {
        this.refreshButton = document.querySelector("op-refresh-button");
        this.refreshButton.onRefresh = val;
    }
    set refreshDisabled(val) {
        this.refreshButton = document.querySelector("op-refresh-button");
        this.refreshButton.disabled = val;
    }
    set refreshCountdownDisabled(val) {
        this.refreshButton = document.querySelector("op-refresh-button");
        this.refreshButton.countdownDisabled = val;
    }
    constructor(showWeather = false, siteConfig) {
        super();
        this.showWeather = showWeather;
        this.weatherUrl = "Weather";
        this.unsupportedModelsUrl = "/UnsupportedModels";
        if (!OptiFleetPage.init) {
            OptiFleetPage.init = true;
            let siteFilterConfig = siteConfig ? siteConfig : {
                elemId: undefined,
                includeAllSites: true,
                hideSiteLabel: false,
            };
            this.siteConfig = {
                elemId: siteConfig === null || siteConfig === void 0 ? void 0 : siteConfig.elemId,
                includeAllSites: Boolean(siteConfig === null || siteConfig === void 0 ? void 0 : siteConfig.includeAllSites),
                hideSiteLabel: derive(() => {
                    if (typeof siteConfig === "undefined") {
                        return false;
                    }
                    if (typeof siteConfig.hideSiteLabel === "undefined") {
                        return false;
                    }
                    return siteConfig.hideSiteLabel;
                }),
            };
            $(document).on("siteFilterChanged", this.handleSiteFilterChange.bind(this));
            this.siteCache = new SiteFilterCache(true, siteFilterConfig.includeAllSites, siteFilterConfig.elemId);
            // due to some strange behavior, a setTimeout is needed here for this to work
            setTimeout(() => {
                if (typeof confirmationModal === "undefined") {
                    confirmationModal = new OpConfirmationModal("confirm");
                }
            }, 100);
            if (this.showWeather) {
                $("#weatherBannerWrapper").addClass('active');
                $(".shell-content-wrapper").css("padding-top", "32px");
            }
            OptiFleetPage.selectedCompanyId = JSON.parse(localStorage.getItem("selectedCompany"));
            OptiFleetPage.selectedCompanyName = localStorage.getItem("selectedCompanyName");
            $(document).on("companyFilterChanged", (ev, companyId) => {
                if (this.onCompanyFilterChanged) {
                    OptiFleetPage.selectedCompanyId = companyId;
                    OptiFleetPage.selectedCompanyName = localStorage.getItem("selectedCompanyName");
                    this.setCompanyTitle();
                    this.onCompanyFilterChanged(companyId);
                }
            });
            OptiFleetPage.selectedSiteId = JSON.parse(localStorage.getItem("selectedSite"));
            OptiFleetPage.selectedSiteName = localStorage.getItem("selectedSiteName");
            $(document).on("siteFilterChanged", (ev, siteId) => {
                OptiFleetPage.selectedSiteId = siteId;
                OptiFleetPage.selectedSiteName = localStorage.getItem("selectedSiteName");
                if (this.onSiteFilterChanged) {
                    this.onSiteFilterChanged(siteId);
                }
                this.loadWeather();
            });
            this.setCompanyTitle();
        }
    }
    handleSiteFilterChange() {
        return __awaiter(this, void 0, void 0, function* () {
            const agentIcon = document.getElementById("agentsIcon");
            const siteName = localStorage.getItem("selectedSiteName");
            const companyName = localStorage.getItem("selectedCompanyName");
            const siteId = parseInt(localStorage.getItem("selectedSite"));
            const agentTooltipLabel = document.getElementById("agent-tooltip-text");
            $(".m-uishell-heading").text(this.siteConfig.hideSiteLabel ? companyName : siteName);
            const agents = (yield this.get("/Agents")).agents;
            for (const agent of agents) {
                let isAllSites = siteId === -1;
                if (!isAllSites && siteId !== agent.siteId) {
                    continue;
                }
                if (!agent.isOnline) {
                    agentIcon.status = "error";
                    agentIcon.name = "wifi-off";
                    agentTooltipLabel.textContent = "Agent(s) offline.";
                    return;
                }
            }
            agentIcon.status = "success";
            agentIcon.name = "wifi";
            agentTooltipLabel.textContent = "Agent(s) online.";
        });
    }
    getSelectedCompanyId() {
        return OptiFleetPage.selectedCompanyId;
    }
    getSelectedCompanyName() {
        return OptiFleetPage.selectedCompanyName;
    }
    setCompanyTitle() {
        if (!OptiFleetPage.selectedCompanyName) {
            return;
        }
        $("#filteredCompany").text(`- ${OptiFleetPage.selectedCompanyName}`);
    }
    /**
     * Blocker instructing a user to choose a company
     * @param isVisible
     */
    toggleSelectCompany(isVisible) {
        if (!isVisible) {
            $(".select-company").addClass("hide");
            return;
        }
        $(".select-company").removeClass("hide");
    }
    getSelectedSiteId() {
        return OptiFleetPage.selectedSiteId;
    }
    getSelectedSiteName() {
        return OptiFleetPage.selectedSiteName;
    }
    loadWeather() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.showWeather) {
                this.hideWeatherBanner();
                return;
            }
            const siteId = OptiFleetPage.selectedSiteId;
            const res = yield this.get(`${this.weatherUrl}?siteId=${siteId}`);
            if (!res.siteName) {
                this.hideWeatherBanner();
            }
            else {
                this.showWeatherBanner();
            }
            this.populateWeatherData(res);
        });
    }
    hideWeatherBanner() {
        $("#weatherBanner").removeClass('active');
    }
    showWeatherBanner() {
        if (!$("#weatherBanner").hasClass('active')) {
            $("#weatherBanner").addClass('active');
        }
    }
    populateWeatherData(resp) {
        const celsius = Math.round((resp.temperature - 32) * (5 / 9));
        $('#weatherLocation').text(resp.siteName);
        $('#weatherTemperature').text(`${resp.temperature}Â°F (${celsius}Â°C)`);
        $('#weatherHumidity').text(`${resp.humidity}%`);
        $('#weatherWind').text(`${resp.windDirection} ${resp.windSpeed} mph `);
    }
    /**
     * Briefly shows a green success banner underneath the header
     * @param msg Success messaging
     * @param showSeconds Number of seconds to show message.
     */
    showSuccessMessage(msg, showSeconds) {
        $(".banner-message").text(msg);
        if ($(".m-uishell-content").scrollTop() !== 0)
            $(".success-banner").css("position", "sticky");
        else
            $(".success-banner").css("position", "absolute");
        $(".success-banner")
            .removeClass("hide")
            .css("display", "flex")
            .fadeIn(300);
        setTimeout(() => {
            $(".success-banner").fadeOut(0);
            $(".success-banner").addClass("hide");
        }, (showSeconds ? showSeconds * 1000 : 5000));
    }
    /**
     * Briefly shows a red error banner underneath the header
     * @param msg Success messaging
     */
    showErrorMessage(msg, showSeconds) {
        $(".error-banner-message").text(msg);
        if ($(".m-uishell-content").scrollTop() !== 0)
            $(".error-banner").css("position", "sticky");
        else
            $(".error-banner").css("position", "absolute");
        $(".error-banner")
            .removeClass("hide")
            .css("display", "flex")
            .fadeIn(300);
        setTimeout(() => {
            $(".error-banner").fadeOut(0);
            $(".error-banner").addClass("hide");
        }, (showSeconds ? showSeconds * 1000 : 5000));
    }
    /**
     * Handler for dismissing the success message prior to it auto dismissing
     * */
    static closeSuccessMessage() {
        $(".success-banner").fadeOut(0);
        $(".success-banner").addClass("hide");
    }
    /**
     * Handler for dismissing the error message prior to it auto dismissing
     * */
    static closeErrorMessage() {
        $(".error-banner").fadeOut(0);
        $(".error-banner").addClass("hide");
    }
    /**
     * Shows a null state page blocker
     * @param msg Success messaging
     */
    showNullState(msg) {
        $(".null-state-message").text(msg);
        $(".null-state").removeClass("hide");
    }
    hideNullState() {
        $(".null-state").addClass("hide");
    }
    /**
     * Retrieves a list of miner models currently unsupported by OptiFleet
     * */
    getUnsupportedModels() {
        return this.get(this.unsupportedModelsUrl)
            .then((resp) => {
            this.unsupportedModels = resp.unsupportedModels;
            return resp.unsupportedModels;
        });
    }
    /**
     * Shows the list of unsupported miner models to the user
     * */
    showUnsupportedModels() {
        $(".unsupported-models-panel-close").click((ev) => {
            $(".unsupported-models-wrapper").removeClass("active");
        });
        $(".unsupported-model-list").children().remove();
        this.unsupportedModels.forEach((model) => {
            $(".unsupported-model-list").append(`<div class="unsupported-model">${model}</div>`);
        });
        $(".unsupported-models-wrapper").addClass("active");
    }
    hasMiners(companyId) {
        if (companyId <= 0) {
            return true;
        }
        const storedCompanies = JSON.parse(localStorage.getItem("storedCompanies"));
        const company = storedCompanies.companies.filter((company) => {
            return parseInt(company.id) == companyId;
        })[0];
        if (!company) {
            return false;
        }
        return company.minerCount > 0;
    }
    confirm(title, message, onSubmit) {
        if (onSubmit) {
            confirmationModal.setOnSubmit(onSubmit);
        }
        confirmationModal.beforeOpen({ primaryText: message, headingText: title });
        confirmationModal.open();
    }
    getQueryStringValue(variable) {
        const query = window.location.search.substring(1);
        const variables = query.split("&");
        for (let i = 0; i < variables.length; i++) {
            const keyPair = variables[i].split("=");
            if (decodeURIComponent(keyPair[0]).toLowerCase() === variable.toLowerCase()) {
                return decodeURIComponent(keyPair[1]);
            }
        }
        return null;
    }
    getQueryStringValues(variable) {
        let vals = [];
        const query = window.location.search.substring(1);
        const variables = query.split("&");
        for (let i = 0; i < variables.length; i++) {
            const keyPair = variables[i].split("=");
            if (decodeURIComponent(keyPair[0]).toLowerCase() === variable.toLowerCase()) {
                vals.push(keyPair[1]);
            }
        }
        return vals;
    }
    toggleDropdownMenu(id) {
        const elem = id.indexOf("#") === 0 ? $(id) : $(`#${id}`);
        const isHidden = elem.attr("aria-hidden");
        elem.attr("aria-hidden", isHidden ? "" : "true");
        $(".m-menu-item").removeAttr("aria-current");
        // FIND AND CLOSE ALL SUBMENUS
        elem.find(".m-dropdown-menu")
            .attr("aria-hidden", "true");
    }
}
// needed for when a single page uses multiple OptifleetPage classes
OptiFleetPage.init = false;

class CdMaster extends OptiFleetService {
    constructor(init = false) {
        super();
        this.companiesUrl = "/Companies";
        this.sitesUrl = "/sites";
        this.weatherUrl = "Weather";
        this.sessionHandler = new SessionHandler();
        init && this.init();
        this.companyDropdown = new CdDropdown("cdCompanies");
        this.companyDropdown.onSelectionChanged = this.onCompanyChanged.bind(this);
        this.sitesDropdown = new SiteFilterCache(true, true);
        this.profileModal = new OpProfileModal(this, "ProfileModal");
        CdMaster.selectedCompanyId = JSON.parse(localStorage.getItem("selectedCompany"));
        CdMaster.selectedCompanyName = localStorage.getItem("selectedCompanyName");
        $(document).on("companyFilterChanged", (ev, companyId) => {
            CdMaster.selectedCompanyId = companyId;
            CdMaster.selectedCompanyName = localStorage.getItem("selectedCompanyName");
            if (this.onCompanyFilterChanged) {
                //this.setCompanyTitle();
                this.onCompanyFilterChanged(companyId);
            }
        });
        CdMaster.selectedSiteId = JSON.parse(localStorage.getItem("selectedSite"));
        CdMaster.selectedSiteName = localStorage.getItem("selectedSiteName");
        $(document).on("siteFilterChanged", (ev, siteId) => {
            CdMaster.selectedSiteId = siteId;
            CdMaster.selectedSiteName = localStorage.getItem("selectedSiteName");
            if (this.onSiteFilterChanged) {
                this.onSiteFilterChanged(siteId);
            }
            this.loadWeather();
            this.getSupportAddress();
        });
        this.initPromises();
        this.loadCompanies();
        this.sessionHandler.keepSessionAlive();
    }
    init() {
        document.getElementById("profile").onclick = this.toggleProfileDropdownMenu.bind(this);
        document.getElementById("profileOverlay").onclick = this.toggleProfileDropdownMenu.bind(this);
    }
    initPromises() {
        const sitePromise = this.getSupportAddress();
        Promise.all([sitePromise]);
    }
    getSupportAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteId = CdMaster.selectedSiteId;
            const defaultEmail = "mailto:mindensiteops@foundrydigital.com";
            let email;
            if (siteId === -1) {
                email = defaultEmail;
            }
            else {
                const resp = yield this.get(`/site?siteId=${siteId}`);
                email = !resp.site.supportEmail ? defaultEmail : `mailto:${resp.site.supportEmail}`;
            }
            $("#support-email").attr("href", email);
        });
    }
    loadWeather() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteId = CdMaster.selectedSiteId;
            const res = yield this.get(`${this.weatherUrl}?siteId=${siteId}`);
            if (!res.siteName) {
                this.hideWeatherBanner();
            }
            else {
                this.showWeatherBanner();
            }
            this.populateWeatherData(res);
        });
    }
    hideWeatherBanner() {
        $("#weatherBanner").removeClass('active');
    }
    showWeatherBanner() {
        if (!$("#weatherBanner").hasClass('active')) {
            $("#weatherBanner").addClass('active');
        }
    }
    populateWeatherData(resp) {
        const celsius = Math.round((resp.temperature - 32) * (5 / 9));
        $('#weatherLocation').text(resp.siteName);
        $('#weatherTemperature').text(`${resp.temperature}Â°F (${celsius}Â°C)`);
        $('#weatherHumidity').text(`${resp.humidity}%`);
        $('#weatherWind').text(`${resp.windSpeed}mph ${resp.windDirection}`);
    }
    loadCompanies() {
        const OptiFleetID = localStorage.getItem("OptiFleetID");
        const storedCompanies = JSON.parse(localStorage.getItem("storedCompanies"));
        if (storedCompanies && storedCompanies.companies
            && storedCompanies.companies.length > 1 && Date.now() / 1000 - storedCompanies.lastSync < 600
            && storedCompanies.OptiFleetId === OptiFleetID) {
            this.populateCompaniesDropDown(storedCompanies.companies, storedCompanies.allowAllCompanies);
            return;
        }
        if (storedCompanies && storedCompanies.OptiFleetId !== OptiFleetID) {
            SessionHandler.clearLocalStorage();
        }
        this.get(`${this.companiesUrl}?filterActive=true`)
            .then((resp) => {
            const storedCompanies = {
                companies: resp.companies,
                lastSync: Date.now() / 1000,
                OptiFleetId: OptiFleetID,
                allowAllCompanies: resp.allowAllCompanies
            };
            localStorage.setItem("storedCompanies", JSON.stringify(storedCompanies));
            this.populateCompaniesDropDown(resp.companies, resp.allowAllCompanies);
        });
    }
    populateCompaniesDropDown(companies, allowAllCompanies) {
        if (companies.length > 1 && companies[0].name !== "All Companies" && allowAllCompanies) {
            companies.unshift({
                name: "All Companies",
                id: -1
            });
        }
        let companyId, companyName, company;
        companyId = JSON.parse(localStorage.getItem("selectedCompany"));
        if (!companyId) {
            if (companies.length > 1) {
                companyId = -1;
                companyName = "All Companies";
            }
            else {
                companyId = companies[0].id;
                companyName = companies[0].name;
            }
        }
        else {
            company = companies.filter((company) => {
                return company.id == companyId;
            })[0];
            companyId = company.id;
            companyName = company.name;
        }
        const normalizedCompanies = companies.map(c => { return { id: c.id, value: c.name }; });
        this.companyDropdown.setOptions(normalizedCompanies);
        localStorage.setItem("selectedCompany", companyId.toString());
        localStorage.setItem("selectedCompanyName", companyName);
        this.companyDropdown.setDefaultValue(companyId);
        $(document).trigger("companyFilterChanged", companyId);
        this.sitesDropdown.loadSites();
    }
    onCompanyChanged() {
        return __awaiter(this, void 0, void 0, function* () {
            const selectedCompany = this.companyDropdown.getSelectedValue();
            const selectedCompanyId = selectedCompany.id;
            const selectedCompanyName = selectedCompany.value;
            localStorage.setItem("selectedCompany", JSON.stringify(selectedCompanyId));
            localStorage.setItem("selectedCompanyName", selectedCompanyName);
            $(document).trigger("companyFilterChanged", selectedCompanyId);
            yield this.post("/SelectedCompany", { selectedCompany: selectedCompanyId });
            this.sitesDropdown.loadSites();
            return;
        });
    }
    toggleProfileDropdownMenu() {
        const hasClass = $('#profileOverlay').hasClass('active');
        if (hasClass) {
            $('#profilePanel').removeClass('active');
            $('#profileOverlay').removeClass('active');
        }
        else {
            $('#profilePanel').addClass('active');
            $('#profileOverlay').addClass('active');
        }
    }
    openProfileModal() {
        this.toggleProfileDropdownMenu();
        this.profileModal.open();
    }
    logout() {
        this.sessionHandler.logout();
    }
    goTo(page) {
        if (self.window.location.href.indexOf("OptiFleet.Portal") > -1) {
            window.location.href = "/OptiFleet.Portal/Content/" + page;
        }
        else {
            window.location.href = "/Content/" + page;
        }
    }
    getSiteId() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.sitesDropdown.getSiteId();
        });
    }
    getSiteName() {
        return this.sitesDropdown.getSiteName();
    }
}

/**
 * apexcharts radial bar implementation
 * */
class Gauge extends PrometheusRange {
    constructor(query, busySelector) {
        super(query, busySelector);
        this.chartType = ChartType.Gauge;
        this.extraOptions = {};
        this.isInitialized = false;
        this.extraOptions.formatter = (val) => val;
    }
    render() {
        this.chartRef.updateSeries([this.stat]);
    }
    init() {
        if (this.isInitialized) {
            return;
        }
        const foundry = "var(--green-9)";
        var options = {
            series: [0],
            chart: {
                type: 'radialBar',
                offsetY: -10,
                sparkline: {
                    enabled: true
                },
                height: (this.extraOptions.height ? `${this.extraOptions.height}px` : "100%"),
                redrawOnParentResize: false,
                redrawOnWindowResize: false,
                foreColor: "var(--color-text-default)",
                background: "var(--gray-1)",
                fontFamily: "var(--font-family)"
            },
            plotOptions: {
                radialBar: {
                    startAngle: -120,
                    endAngle: 120,
                    track: {
                        background: "var(--gray-4)",
                        startAngle: -120,
                        endAngle: 120,
                    },
                    dataLabels: {
                        name: {
                            show: true
                        },
                        value: {
                            offsetY: 10,
                            fontSize: "var(--text-5-font-size)",
                            fontFamily: "var(--font-family)",
                            color: "var(--color-text-default)",
                            fontWeight: 500,
                            formatter: (val) => { return this.extraOptions.formatter(val); }
                        }
                    }
                }
            },
            labels: ["Hash Rate Efficiency"],
            responsive: [{
                    breakpoint: 1367,
                    options: {
                        chart: {
                            offsetY: 10,
                            height: "100%"
                        },
                        title: {
                            offsetY: 20,
                            style: {
                                fontSize: "1.2857142857rem"
                            }
                        },
                        plotOptions: {
                            radialBar: {
                                dataLabels: {
                                    value: {
                                        offsetY: 10,
                                        fontSize: '36px',
                                    }
                                }
                            }
                        }
                    }
                },
                {
                    breakpoint: 1025,
                    options: {
                        chart: {
                            offsetY: 10,
                            height: "100%"
                        },
                        title: {
                            offsetY: 20,
                            style: {
                                fontSize: "1.14285714285714rem"
                            }
                        },
                        plotOptions: {
                            radialBar: {
                                dataLabels: {
                                    value: {
                                        offsetY: 10,
                                        fontSize: '30px',
                                    }
                                }
                            }
                        }
                    }
                },
                {
                    breakpoint: 769,
                    options: {
                        chart: {
                            offsetY: 10,
                            height: "375px"
                        },
                        title: {
                            offsetY: 20,
                            style: {
                                fontSize: "1.14285714285714rem"
                            }
                        },
                        plotOptions: {
                            radialBar: {
                                dataLabels: {
                                    value: {
                                        offsetY: 10,
                                        fontSize: '30px',
                                    }
                                }
                            }
                        }
                    }
                },
                {
                    breakpoint: 480,
                    options: {
                        chart: {
                            offsetY: 10,
                            height: "300px"
                        },
                        title: {
                            offsetY: 20,
                            style: {
                                fontSize: "1.14285714285714rem"
                            }
                        },
                        plotOptions: {
                            radialBar: {
                                dataLabels: {
                                    value: {
                                        offsetY: 10,
                                        fontSize: '30px',
                                    }
                                }
                            }
                        }
                    }
                }],
            fill: {
                type: 'solid',
                colors: [foundry],
            },
            grid: {
                padding: {
                    top: -10,
                    bottom: 50
                }
            }
        };
        const chart = new self.ApexCharts(document.querySelector(`#${this.elementSelector}`), options);
        chart.render();
        this.chartRef = chart;
    }
}

/**
 * Read-only intervals for the time ranges of a chart or query
 * */
class GraphIntervals {
    static getIntervals() {
        return [
            {
                text: "Last 5 minutes",
                value: GraphIntervals.LAST_5_MINUTES
            }, {
                text: "Last 15 minutes",
                value: GraphIntervals.LAST_15_MINUTES
            }, {
                text: "Last 30 minutes",
                value: GraphIntervals.LAST_30_MINUTES
            }, {
                text: "Last 1 hour",
                value: GraphIntervals.LAST_1_HOUR
            }, {
                text: "Last 3 hours",
                value: GraphIntervals.LAST_3_HOURS
            }, {
                text: "Last 6 hours",
                value: GraphIntervals.LAST_6_HOURS
            }, {
                text: "Last 12 hours",
                value: GraphIntervals.LAST_12_HOURS
            }, {
                text: "Last 24 hours",
                value: GraphIntervals.LAST_24_HOURS
            }, {
                text: "Last 2 days",
                value: GraphIntervals.LAST_2_DAYS
            }, {
                text: "Last 7 days",
                value: GraphIntervals.LAST_7_DAYS
            }, {
                text: "Last 30 days",
                value: GraphIntervals.LAST_30_DAYS
            }, {
                text: "Previous Month",
                value: GraphIntervals.PREVIOUS_MONTH
            }
        ];
    }
}
GraphIntervals.MINUTE = 60 * 1000;
GraphIntervals.LAST_5_MINUTES = GraphIntervals.MINUTE * 5;
GraphIntervals.LAST_15_MINUTES = GraphIntervals.MINUTE * 15;
GraphIntervals.LAST_30_MINUTES = GraphIntervals.MINUTE * 30;
GraphIntervals.LAST_1_HOUR = GraphIntervals.MINUTE * 60;
GraphIntervals.LAST_3_HOURS = GraphIntervals.MINUTE * 180;
GraphIntervals.LAST_6_HOURS = GraphIntervals.MINUTE * 360;
GraphIntervals.LAST_12_HOURS = GraphIntervals.MINUTE * 720;
GraphIntervals.LAST_24_HOURS = GraphIntervals.MINUTE * 1440;
GraphIntervals.LAST_2_DAYS = GraphIntervals.MINUTE * 2880;
GraphIntervals.LAST_7_DAYS = GraphIntervals.MINUTE * 10080;
GraphIntervals.LAST_30_DAYS = GraphIntervals.MINUTE * 43200;
GraphIntervals.PREVIOUS_MONTH = GraphIntervals.MINUTE * 86400;

var ChartType;
(function (ChartType) {
    ChartType[ChartType["Line"] = 0] = "Line";
    ChartType[ChartType["Bar"] = 1] = "Bar";
    ChartType[ChartType["Gauge"] = 2] = "Gauge";
    ChartType[ChartType["Column"] = 3] = "Column";
})(ChartType || (ChartType = {}));

/**
 * apexcharts area chart implementation
 * */
class LineChart extends PrometheusRange {
    constructor(queries, busySelector) {
        super(queries, busySelector);
        this.chartType = ChartType.Line;
        this.extraOptions = {};
        this.annotations = [];
        this.hasData = false;
        this.isInitialized = false;
        this.extraOptions.formatter = (val, index) => val;
    }
    getSerieData() {
        this.hasData = false;
        if (!this.series) {
            return [{ data: [] }];
        }
        this.series.forEach((serie) => {
            if (serie.data.length > 0) {
                this.hasData = true;
            }
        });
        if (!this.hasData) {
            return [{ data: [] }];
        }
        return this.series;
    }
    /**
     * Destroys the line chart
     * */
    destroy() {
        this.chartRef.destroy();
        this.isInitialized = false;
        const parent = $(`#${this.elementSelector}`).parent();
        $(`#${this.elementSelector}`).remove();
        const chart = document.createElement("div");
        chart.id = this.elementSelector;
        $(parent).append(chart);
    }
    updateChart() {
        const data = this.getSerieData();
        this.chartRef.updateOptions({
            xaxis: {
                labels: {
                    show: this.hasData
                }
            }
        });
        this.chartRef.clearAnnotations();
        for (let annotation of this.annotations) {
            this.chartRef.addXaxisAnnotation(annotation);
        }
        this.chartRef.updateSeries(data);
    }
    /**
     * Renders the line chart
     * */
    render() {
        if (this.isInitialized) {
            this.updateChart();
            return;
        }
        this.isInitialized = true;
        const serieData = this.getSerieData();
        let options;
        if (this.overrideOptions) {
            options = Object.assign({ series: serieData }, this.overrideOptions);
        }
        else {
            options = {
                series: serieData,
                chart: {
                    events: {
                        legendClick: function (chartContext, seriesIndex, config) {
                            let series = Array.from(chartContext.series.getAllSeriesEls());
                            // all series are visible
                            if (series.every((element) => !chartContext.series.isSeriesHidden(element.getAttribute("seriesName")).isHidden)) {
                                series.forEach((element, index) => {
                                    if (index != seriesIndex) {
                                        chartContext.series.hideSeries(element.getAttribute("seriesName"));
                                    }
                                });
                            }
                            // excluding the selected series, at least one other series is visible
                            else if (series.filter((_, index) => index != seriesIndex).some((element) => !chartContext.series.isSeriesHidden(element.getAttribute("seriesName")).isHidden)) {
                                chartContext.series.toggleSeries(series[seriesIndex].getAttribute("seriesName"));
                            }
                            // only selected series is visible
                            else {
                                series.forEach((element) => chartContext.series.showSeries(element.getAttribute("seriesName")));
                            }
                        }
                    },
                    animations: {
                        enabled: false
                    },
                    background: "var(--color-background-default)",
                    foreColor: "var(--color-text-default)",
                    fontFamily: "var(--font-family)",
                    id: `${this.elementSelector}${Date.now()}`,
                    type: this.extraOptions.lineType || "area",
                    stacked: this.extraOptions.stacked || false,
                    height: "100%",
                    group: this.extraOptions.group || "group",
                    zoom: {
                        type: 'x',
                        enabled: true,
                        autoScaleYaxis: true
                    },
                    toolbar: {
                        tools: {
                            zoomin: false,
                            zoomout: false,
                            pan: false,
                            download: true,
                            reset: true
                        },
                        export: this.extraOptions.export,
                    },
                },
                grid: {
                    yaxis: {
                        lines: {
                            show: false
                        }
                    }
                },
                dataLabels: {
                    enabled: false
                },
                noData: {
                    text: 'No data is available for this time range'
                },
                stroke: {
                    curve: 'smooth',
                    width: 1.5
                },
                fill: {
                    type: 'gradient',
                    gradient: {
                        opacityFrom: 0.6,
                        opacityTo: 0.8,
                    }
                },
                xaxis: {
                    type: 'datetime',
                    labels: {
                        hideOverlappingLabels: true,
                        datetimeUTC: false,
                        datetimeFormatter: {
                            year: 'yyyy',
                            month: "d MMM",
                            day: 'd MMM',
                            hour: 'HH:mm',
                            minute: 'HH:mm'
                        }
                    },
                    tooltip: {
                        enabled: false
                    }
                },
                yaxis: {
                    labels: {
                        show: this.extraOptions.showYLabels === false ? false : true,
                        formatter: (val, index) => {
                            if (this.extraOptions.formatter) {
                                return this.extraOptions.formatter(val, index);
                            }
                            return val;
                        },
                        minWidth: 60,
                    },
                    decimalsInFloat: 0,
                    forceNiceScale: true,
                    min: this.extraOptions.minY,
                    max: this.extraOptions.maxY,
                },
                tooltip: this.extraOptions.tooltip ||
                    {
                        shared: true,
                        inverseOrder: true,
                        x: {
                            show: true,
                            format: 'yyyy-MM-dd hh:mm:ss TT'
                        },
                    },
                animations: {
                    enabled: true,
                    easing: 'easeinout',
                    speed: 800,
                    animateGradually: {
                        enabled: true,
                        delay: 150
                    },
                    dynamicAnimation: {
                        enabled: true,
                        speed: 350
                    }
                },
                responsive: this.extraOptions.responsiveSettings || [],
                legend: Object.assign(Object.assign({}, this.extraOptions.legend), { onItemClick: { toggleDataSeries: false } })
            };
            const color1 = "#92ceac";
            const foundry = "#00e67e";
            if (!this.extraOptions.autoColor) {
                options["colors"] = [foundry, color1];
            }
        }
        const chart = new self.ApexCharts(document.querySelector(`#${this.elementSelector}`), options);
        chart.render();
        this.chartRef = chart;
    }
}

/**
 * Tracks a users session and handles expiring sessions
 * */
class SessionHandler extends OptiFleetService {
    constructor() {
        super();
        this.aliveUrl = "/SessionAlive";
        this.timeRemaining = 0;
        this.trackTabID();
        this.keepSessionAlive();
        $(window).focus(() => {
            this.checkSessionState();
        });
    }
    static setInitialTimeLeft(timeLeft) {
        const timeLeftTracker = {
            endTs: Math.round(Date.now() / 1000) + timeLeft
        };
        localStorage.setItem("timeleft", JSON.stringify(timeLeftTracker));
    }
    checkSessionState() {
        const timeLeftObj = JSON.parse(localStorage.getItem("timeleft"));
        const currentTimeSecs = Math.round(Date.now() / 1000);
        if (currentTimeSecs > timeLeftObj.endTs) {
            this.logout();
        }
        else {
            this.keepSessionAlive();
        }
    }
    trackTabID() {
        const tabId = JSON.parse(sessionStorage.getItem("tabId"));
        if (!tabId) {
            this.tabId = Math.random() * 1000000;
            sessionStorage.setItem("tabId", JSON.stringify(this.tabId));
            return;
        }
        this.tabId = tabId;
    }
    /**
     * Keeps a users session alive when the stay logged in button is pressed
     * */
    keepSessionAlive() {
        if ($(".auto-logout-wrapper").hasClass("active")) {
            if (!this.shouldCancelCountdown()) {
                return null;
            }
            $(".auto-logout-wrapper").removeClass("active");
        }
        return this.post(this.aliveUrl)
            .then((resp) => {
            this.handleSession(resp);
            return resp;
        });
    }
    handleSession(resp) {
        if (!resp || !resp.isAlive) {
            if (resp.message === "aborting for navigation" || resp.message === "Network Error") {
                return;
            }
            return this.logout(true);
        }
        this.handleCountdown(resp.timeLeft);
    }
    handleCountdown(timeleft) {
        clearInterval(this.countDownLeftInterval);
        clearInterval(this.countDownInterval);
        this.timeRemaining = Math.round(timeleft);
        if (this.timeRemaining == 0)
            this.logout();
        const timeLeftTracker = {
            tabId: this.tabId,
            timeLeft: this.timeRemaining,
            ts: Math.round(Date.now() / 1000),
            endTs: Math.round(Date.now() / 1000) + this.timeRemaining
        };
        localStorage.setItem("timeleft", JSON.stringify(timeLeftTracker));
        this.countDownLeftInterval = setInterval(() => {
            this.timeRemaining = this.timeRemaining - 1;
            if (this.timeRemaining < 121) {
                if (!this.shouldCancelCountdown()) {
                    clearInterval(this.countDownLeftInterval);
                    clearInterval(this.countDownInterval);
                    this.beginCountdown();
                }
                return;
            }
        }, 1000);
    }
    beginCountdown() {
        $("#autoLogoutSeconds").text(this.timeRemaining);
        $(".auto-logout-wrapper").addClass("active");
        this.countDownInterval = setInterval(() => {
            $("#autoLogoutSeconds").text(this.timeRemaining);
            this.timeRemaining = this.timeRemaining - 1;
            if (this.timeRemaining <= 0) {
                clearInterval(this.countDownInterval);
                if (this.shouldCancelCountdown()) {
                    return;
                }
                this.logout(true);
                return;
            }
        }, 1000);
    }
    shouldCancelCountdown() {
        const otherTabTime = JSON.parse(localStorage.getItem("timeleft"));
        if (otherTabTime.tabId !== this.tabId && otherTabTime.timeLeft > this.timeRemaining) {
            const diff = Math.round(Date.now() / 1000) - otherTabTime.ts;
            const timeRemaining = otherTabTime.timeLeft - diff;
            clearInterval(this.countDownLeftInterval);
            clearInterval(this.countDownInterval);
            this.handleCountdown(timeRemaining);
            return true;
        }
        return false;
    }
    /**
     * Logs out a user
     * @param isAutoLogout
     */
    logout(isAutoLogout) {
        if (!isAutoLogout) {
            this.post("/logout")
                .then(() => {
                SessionHandler.clearLocalStorage();
                window.location.href = "/Content/Login/Start.aspx";
            });
            return;
        }
        this.post("/logout").then(() => {
            SessionHandler.clearLocalStorage();
            window.location.href = "/Content/Login/Start.aspx?autoLogout=true";
        });
    }
    continueSession() {
        clearInterval(this.countDownInterval);
        $(".auto-logout-wrapper").removeClass("active");
    }
    /**
     * Clears session objects from local storage
     * */
    static clearLocalStorage() {
        localStorage.removeItem("selectedCompany");
        localStorage.removeItem("selectedCompanyName");
        localStorage.removeItem("storedCompanies");
    }
}

class SiteFilterCache extends OptiFleetService {
    constructor(persist = true, includeAllSites = true, id) {
        super();
        this.persist = persist;
        this.includeAllSites = includeAllSites;
        this.companiesUrl = "/Companies";
        this.sitesUrl = "/sites";
        this.sites = [];
        if (id) {
            this.dropdownEl = document.getElementById(id);
            this.dropdownEl.addEventListener("on-change", (e) => this.onSiteChanged(e.detail));
        }
        else {
            $(document).trigger("siteFilterChanged", this.siteId);
        }
        //this.loadSites();
    }
    /**
     * public function that should be called onCompanyFilterChanged
     */
    loadSites() {
        return __awaiter(this, void 0, void 0, function* () {
            let prevSites = this.sites;
            yield this.fetchSites();
            this.initDefaultSiteId();
            if (prevSites !== this.sites) {
                this.populateSitesDropDown();
            }
        });
    }
    fetchSites() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.get(`${this.sitesUrl}`);
            this.sites = resp.sites;
        });
    }
    /**
     * we default to all sites. initDefaultSiteId will handle the case where includeAllSites = false
     * @returns the current siteId (default to AllSites)
     */
    _tryGetSitesId() {
        return parseInt(localStorage.getItem(SiteFilterCache.siteIdKey)) || -1;
    }
    /**
     * use to get the current selected company from local storage. initCache() handles retries if the companyId is
     * not yet set in local storage
     * @returns
     */
    _tryGetCompanyId() {
        return parseInt(localStorage.getItem("selectedCompany")) || undefined;
    }
    /**
     * sets site data in the kendo dropdown
     */
    populateSitesDropDown() {
        let sites = [...this.sites];
        if ((sites.length !== 1 && (this.includeAllSites || this.siteId === -1))
            ||
                sites.length === 0) {
            sites.unshift({
                siteName: "All Sites",
                siteId: -1
            });
        }
        let siteName, site;
        if (!this.siteId || this.siteId === -1) {
            if (sites.length > 1) {
                this.siteId = -1;
                siteName = "All Sites";
            }
            else {
                this.siteId = sites[0].siteId;
                siteName = sites[0].siteName;
            }
        }
        else {
            site = sites.find((site) => {
                return site.siteId === this.siteId;
            });
            if (!site) {
                site = sites[0];
            }
            this.siteId = site.siteId;
            siteName = site.siteName;
        }
        if (this.dropdownEl) {
            this.dropdownEl.options = sites.map(site => {
                return { label: site.siteName, value: "site_" + site.siteId.toString() };
            });
            this.dropdownEl.selected = this.siteId.toString();
        }
        localStorage.setItem("selectedSite", this.siteId.toString());
        localStorage.setItem("selectedSiteName", siteName);
        $(document).trigger("siteFilterChanged", this.siteId);
    }
    /**
     * this function should always be called in case this.includeAllSites = false.
     * If this.includeAllSites = false and this.site.length == 0 the best we can do is default to all sites
     * (-1 will already be set before through this.initCache in this case)
     * @returns
     */
    initDefaultSiteId() {
        var _a;
        let siteId = this._tryGetSitesId();
        if (((_a = this.sites) === null || _a === void 0 ? void 0 : _a.findIndex(site => site.siteId == siteId)) > -1) {
            this.siteId = siteId;
            return siteId;
        }
        if ((!this.includeAllSites && this.sites.length > 0) || this.sites.length == 1) {
            this.siteId = this.sites[0].siteId;
            return this.siteId;
        }
        this.siteId = -1;
        return this.siteId;
    }
    onSiteChanged({ value, label }) {
        const selectedSiteId = value.split("_")[1];
        const selectedSiteName = label;
        if (selectedSiteId !== this.siteId.toString()) {
            this.siteId = parseInt(selectedSiteId);
            if (this.persist) {
                localStorage.setItem("selectedSite", selectedSiteId);
                localStorage.setItem("selectedSiteName", selectedSiteName);
            }
            $(document).trigger("siteFilterChanged", selectedSiteId);
        }
    }
    setSiteId(value) {
        try {
            this.dropdownEl.selected = value;
        }
        catch (_a) {
            return;
        }
        if (this.persist) {
            localStorage.setItem("selectedSite", value);
        }
        this.siteId = parseInt(value);
    }
    getSiteId() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.siteId == null) {
                yield asyncSleep(250);
                return yield this.getSiteId();
            }
            return String(this.siteId);
        });
    }
    getSiteName() {
        return this.siteId == -1 ? "All Sites" : this.sites.find(s => s.siteId === this.siteId).siteName;
    }
    getSites() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.sites == null) {
                yield asyncSleep(250);
                return this.getSites();
            }
            return this.sites;
        });
    }
}
SiteFilterCache.siteCacheKey = "siteCache";
SiteFilterCache.siteIdKey = "selectedSite";

var ProgressionModalSubmitType;
(function (ProgressionModalSubmitType) {
    ProgressionModalSubmitType[ProgressionModalSubmitType["POST"] = 0] = "POST";
    ProgressionModalSubmitType[ProgressionModalSubmitType["PATCH"] = 1] = "PATCH";
})(ProgressionModalSubmitType || (ProgressionModalSubmitType = {}));
const DEFAULT_PROPS$1 = {
    submitUrl: "/NoEndpoint",
    submitType: ProgressionModalSubmitType.POST
};
/** This class should be inherited */
class OpProgressionModalBase extends OptiFleetService {
    /**
     *
     * @param Id must be referenced by the ID attribute in the Modal UserControl
     */
    constructor(Id, views, props = DEFAULT_PROPS$1) {
        super();
        this.Id = Id;
        this.views = views;
        this.props = props;
        this.viewCursor = 0;
        this.invalidViewIndeces = [];
        this.elem = document.getElementById(Id);
        if (this.elem === null)
            return;
        // init offclick, close, cancel, continue, back, and submit buttons
        this.initModalButtons();
        this.initViews();
    }
    initViews() {
        this.views.forEach((view, index) => {
            // load data into views
            view.load();
            // init pages
            const templateHtml = document.getElementById("progressBarPageTemplate").innerHTML;
            const data = { index };
            const template = self.Mustache.to_html(templateHtml, data);
            $(`#${this.Id}ProgressBar`).append(template);
        });
        // highlight first page bar
        $(`#${this.Id}Page0`).addClass("active");
        // add title to first page
        this.setViewTitle();
        try {
            this.views[this.viewCursor].show();
        }
        catch (_a) {
        }
        // init buttons
        if (this.views.length <= 1) {
            $(`#${this.Id}ProgressBar`).removeClass("active");
            this.showSubmitButton();
        }
        else {
            this.showContinueButton();
        }
    }
    initModalButtons() {
        // offclick close
        this.elem.onclick = this.close.bind(this);
        let closeIcon = $(this.elem).find(".close-icon").get(0);
        closeIcon.onclick = this.close.bind(this);
        $(`#${this.Id}BackButton`).click(this.previousPage.bind(this));
        $(`#${this.Id}ContinueButton`).click(this.nextPage.bind(this));
        $(`#${this.Id}SubmitButton`).click(this.submit.bind(this));
    }
    open() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isOpen = true;
            this.elem.style.display = "flex";
            this.toggleModalBusy(true);
            const proms = this.views.map(view => view.load());
            yield Promise.all(proms);
            this.toggleModalBusy(false);
        });
    }
    close(e, forceClose = false) {
        const shouldClose = (e === null || e === void 0 ? void 0 : e.target.closest(".close-icon"))
            || (e === null || e === void 0 ? void 0 : e.target.classname) === "modal-wrapper";
        if (shouldClose || forceClose) {
            this._close();
        }
    }
    /**
     * Close without checks and close handlers
     * @param e
     * @param forceClose
     */
    _close() {
        this.isOpen = false;
        this.elem.style.display = "none";
        this.onClose && this.onClose();
    }
    reset() {
        this.views.forEach(view => view.reset());
        // reset to first page
        this.views[this.viewCursor].hide();
        this.viewCursor = 0;
        this.views[this.viewCursor].show();
        this.invalidViewIndeces = [];
        if (this.views.length <= 1) {
            this.showSubmitButton();
        }
        else {
            this.hideSubmitButton();
            this.showContinueButton();
        }
    }
    setViewTitle() {
        const title = this.views[this.viewCursor].title();
        $(`#${this.Id}ViewTitle`).text(title);
    }
    nextPage() {
        // validate view before continuing
        const activeView = this.views[this.viewCursor];
        if (!activeView.validate())
            return;
        // handle page nav
        activeView.hide();
        this.viewCursor += 1;
        const nextView = this.views[this.viewCursor];
        nextView.show();
        // if view cursor == 1, show back button
        if (this.viewCursor === 1) {
            // show back button
            this.showBackButton();
        }
        // on last page
        if (this.viewCursor === this.views.length - 1) {
            this.hideContinueButton();
            this.showSubmitButton();
        }
        // handle progress bar style
        $(`#${this.Id}Page${this.viewCursor}`).addClass("active");
        // update view title
        this.setViewTitle();
    }
    previousPage() {
        // handle progress bar style
        $(`#${this.Id}Page${this.viewCursor}`).removeClass("active");
        // handle page nav
        const activeView = this.views[this.viewCursor];
        activeView.hide();
        this.viewCursor -= 1;
        const nextView = this.views[this.viewCursor];
        nextView.show();
        // back on first page
        if (this.viewCursor === 0) {
            // hide back button
            this.hideBackButton();
        }
        // previous page was last page
        if (this.viewCursor === this.views.length - 2) {
            // hide submit button and show continue button
            this.hideSubmitButton();
            this.showContinueButton();
        }
        // update view title
        this.setViewTitle();
    }
    /**
     * uses previousPage() and nextPage() to reuse element show/hide logic easily
     * @param pageIndex
     */
    goToPage(pageIndex) {
        if (pageIndex < this.viewCursor) {
            this.previousPage();
            this.goToPage(pageIndex);
        }
        else if (pageIndex > this.viewCursor) {
            this.nextPage();
            this.goToPage(pageIndex);
        }
    }
    submit() {
        // can only use confirmation with one modal with the current setup
        if (this.views.length === 1) {
            this.views[0].confirm(this._submit.bind(this));
        }
        else {
            this._submit();
        }
    }
    _submit() {
        // validate views
        this.invalidViewIndeces = this.views
            .map((view, index) => view.validate() ? -1 : index)
            .filter(val => val > -1);
        // if any views are invalid, return early and nav to the first invalid page
        if (this.invalidViewIndeces.length > 0) {
            this.goToPage(this.invalidViewIndeces[0]);
            return;
        }
        // if all views are valid accumulate data for http call
        let dataObject = {};
        this.views.forEach(view => {
            view.updateSubmitData(dataObject, this.props.submitType);
        });
        // fire http call
        let request;
        switch (this.props.submitType) {
            case ProgressionModalSubmitType.POST:
                request = this.post(this.props.submitUrl, dataObject);
                break;
            case ProgressionModalSubmitType.PATCH:
                request = this.patch(this.props.submitUrl, dataObject);
                break;
            default:
                throw "ProgressionModalSubmitType Not Implemented";
        }
        this.toggleModalBusy(true);
        request.then((res) => {
            this.toggleModalBusy(false);
            if (!res.success) {
                // show error message
                this.showErrorMessage(res.message);
                return;
            }
            this.hideErrorMessage();
            try {
                this.onClose && this.onClose();
            }
            catch (_a) { }
            this._close();
            this.reset();
        });
    }
    /** UTILS **/
    hideBackButton() { $(`#${this.Id}BackButton`).removeClass("active"); }
    showBackButton() { $(`#${this.Id}BackButton`).addClass("active"); }
    hideContinueButton() { $(`#${this.Id}ContinueButton`).removeClass("active"); }
    showContinueButton() { $(`#${this.Id}ContinueButton`).addClass("active"); }
    hideSubmitButton() { $(`#${this.Id}SubmitButton`).removeClass("active"); }
    showSubmitButton() { $(`#${this.Id}SubmitButton`).addClass("active"); }
    toggleSubmitButton(val) {
        val ?
            $(".submit-button-wrapper").removeClass("disable-submit-button")
            :
                $(".submit-button-wrapper").addClass("disable-submit-button");
    }
    allowSubmitButton() {
        $(".submit-button-wrapper").removeClass("disable-submit-button");
    }
    showErrorMessage(msg) {
        const banner = $(`#${this.Id}ErrorBanner`);
        banner.css("display", "flex");
        banner.text(msg);
    }
    hideErrorMessage() {
        const banner = $(`#${this.Id}ErrorBanner`);
        banner.css("display", "none");
        banner.text("");
    }
    toggleModalBusy(isBusy) {
        if (!isBusy) {
            $(`#${this.Id}ModalBusy`).css("display", "none");
            return;
        }
        $(`#${this.Id}ModalBusy`).css("display", "block");
    }
}

class AgentMustacheTemplates {
}
AgentMustacheTemplates.AGENT_CARDS = `
            <div class="m-grid-list is-size-l">
                {{#agents}}
                    <div class="m-box has-space-none">
                        <div class="m-box is-variant-ghost">
                            <div class="m-stack is-horizontal has-space-between">
                                <div class="m-stack is-horizontal is-align-center">   
                                    <m-icon id="building-icon" name="building-2" size="l"></m-icon>
                                    <h2 class="m-heading is-size-xl">{{agentName}}</h2>
                                </div>
                                <a href="/Content/Administration/AgentDetails?agentId={{agentId}}" style="color: var(--color-text-accent);">
                                    <m-icon size="xl" id="arrow-icon" name="arrow-right" class="agent-arrow-icon"></m-icon>
                                </a>
                            </div>
                        </div>
                        <div class="m-divider has-space-xs"></div>
                        <div class="m-grid-list site-stats">
                            <div class="m-box is-variant-ghost">
                                <div class="m-stack has-space-s">
                                    <div class="m-heading is-size-m is-tertiary has-space-l">Miners Monitored</div>
                                    <div class="m-text is-size-xl">{{minerCount}}</div>
                                </div>
                            </div>
                            <div class="m-box is-variant-ghost">
                                <div class="m-stack has-space-s">
                                    <div class="m-heading is-size-m is-tertiary has-space-l">Online Status</div>
                                    <div class="m-text is-size-xl">{{onlineStatus}}</div>
                                </div>
                            </div>
                            <div class="m-box is-variant-ghost">
                                <div class="m-stack has-space-s">
                                    <div class="m-heading is-size-m is-tertiary has-space-l">Zones Monitored</div>
                                    <div class="m-text is-size-xl">{{zoneCount}}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                {{/agents}}
            </div>
        `;

class AssetManufacturers extends OptiFleetPage {
    constructor() {
        super();
        this.assetManufacturersUrl = "/AssetManufacturers";
        this.assetManufacturers = [];
        this.grid = $("#manufacturersGrid");
        this.initGrid();
        this.addForm = new AssetManufacturersFormView("AddAssetManufacturerModalView", $("#AddAssetManufacturerModalViewWrapper"));
        this.addFormModal = new OpProgressionModalBase("AddAssetManufacturerModal", [this.addForm], { submitUrl: this.assetManufacturersUrl, submitType: ProgressionModalSubmitType.POST });
        this.addFormModal.onClose = this.load.bind(this);
        this.editForm = new AssetManufacturersFormView("EditAssetManufacturerModalView", $("#EditAssetManufacturerModalViewWrapper"));
        this.editFormModal = new OpProgressionModalBase("EditAssetManufacturerModal", [this.editForm], { submitUrl: this.assetManufacturersUrl, submitType: ProgressionModalSubmitType.PATCH });
        this.editFormModal.onClose = this.load.bind(this);
        this.deleteAssetManufacturersModal = new OpConfirmationModal("DeleteAssetManufacturersModal", this.confirmDelete.bind(this));
        this.deleteAssetManufacturersModal.afterClose = this.load.bind(this);
        this.load();
    }
    openAddAssetManufacturer() {
        this.addForm.companyId = this.getSelectedCompanyId();
        this.addForm.show();
        this.addFormModal.open();
    }
    getManufacturer(manufacturerId) {
        return this.assetManufacturers.filter((manufacturer) => {
            return manufacturer.id === manufacturerId;
        })[0];
    }
    initGrid() {
        const openEditModalHandler = this.openEditAssetModel.bind(this);
        this.grid.kendoGrid({
            pageable: {
                pageSizes: [10, 100, 500],
                buttonCount: 5
            },
            sortable: true,
            mobile: true,
            resizable: true,
            scrollable: true,
            selectable: "multiple",
            change: this.handleSelection.bind(this),
            columns: [
                { selectable: true, width: "55px" },
                {
                    command: {
                        name: "Edit", iconClass: { edit: "pencil" }, click: function (e) {
                            e.preventDefault();
                            const tr = $(e.target).closest("tr");
                            const data = this.dataItem(tr);
                            openEditModalHandler(data);
                        },
                    },
                    width: "105px",
                },
                { field: "id", title: "ID", width: "55px", },
                { field: "name", title: "Name", width: "100px", },
                { field: "description", title: "Description", width: "400px", },
            ],
            dataBound: this.onDataBound.bind(this),
        });
    }
    onDataBound(e) {
        let grid = e.sender;
        grid.tbody.find("tr").each(function () {
            let dataItem = grid.dataItem(this);
            if (!dataItem.companyName) {
                $(this).find(".k-grid-Edit").hide(); // Why is the class k-grid-Edit instead of k-grid-edit?
            }
        });
    }
    handleSelection() {
        const grid = this.grid.data("kendoGrid");
        const selectedItems = grid.selectedKeyNames();
        this.selectedAssetManufacturers = selectedItems;
        if (this.selectedAssetManufacturers.length > 0) {
            this.toggleDeleteButtonVisible(true);
        }
        else {
            this.toggleDeleteButtonVisible(false);
        }
    }
    toggleDeleteButtonVisible(active) {
        $("#btnDeleteAssetManufacturers").css("display", active ? "flex" : "none");
    }
    populateGrid(manufacturers) {
        const grid = this.grid.data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: manufacturers,
            pageSize: 100,
            schema: {
                model: {
                    id: "id"
                }
            }
        });
        grid.setDataSource(dataSource);
        // remove edit ability on OptiFleet default asset types
        this.grid.find(".k-grid-Edit").each(function () {
            const row = $(this).closest("tr");
            const currentDataItem = grid.dataItem(row);
            if (currentDataItem.companyName == "Default") {
                row.parent().find(".k-checkbox").first().prop("disabled", true);
                $(this).remove();
            }
        });
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            this.getAssetManufacturers();
        });
    }
    getAssetManufacturers() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.get(this.assetManufacturersUrl);
            if (!res.success) {
                this.showErrorMessage("Failed to fetch Asset Manufacturers");
                return;
            }
            this.populateGrid(res.assetManufacturers);
            this.assetManufacturers = res.assetManufacturers;
        });
    }
    openEditAssetModel(row) {
        this.editForm.load(row);
        this.editForm.companyId = this.getSelectedCompanyId();
        this.addForm.show();
        this.editFormModal.open();
    }
    promptDeleteConfirmation() {
        const numMiners = this.selectedAssetManufacturers.length;
        const initData = OpConfirmationModal.getDeleteModalInitData(numMiners);
        this.deleteAssetManufacturersModal.open(initData);
    }
    confirmDelete() {
        this.delete(this.assetManufacturersUrl, { ids: this.selectedAssetManufacturers }).then((res) => {
            this.toggleDeleteButtonVisible(false);
            this.load();
        });
    }
    getManufacturersDropdownData() {
        return this.assetManufacturers.map(assetManufacturer => {
            return { "text": assetManufacturer.name, "value": assetManufacturer.id.toString() };
        });
    }
}

class AssetModels extends OptiFleetPage {
    constructor(assetTypes, manufacturers) {
        super();
        this.assetTypes = assetTypes;
        this.manufacturers = manufacturers;
        this.assetModelsUrl = "/AssetModels";
        this.grid = $("#modelsGrid");
        this.initGrid();
        this.addForm = new AssetModelsFormView("AddAssetModelModalView", $("#AddAssetModelModalViewWrapper"), assetTypes, manufacturers);
        this.addFormModal = new OpProgressionModalBase("AddAssetModelModal", [this.addForm], { submitUrl: this.assetModelsUrl, submitType: ProgressionModalSubmitType.POST });
        this.addFormModal.onClose = this.load.bind(this);
        this.editForm = new AssetModelsFormView("EditAssetModelModalView", $("#EditAssetModelModalViewWrapper"), assetTypes, manufacturers);
        this.editFormModal = new OpProgressionModalBase("EditAssetModelModal", [this.editForm], { submitUrl: this.assetModelsUrl, submitType: ProgressionModalSubmitType.PATCH });
        this.editFormModal.onClose = this.load.bind(this);
        this.deleteAssetModelsModal = new OpConfirmationModal("DeleteAssetModelsModal", this.confirmDelete.bind(this));
        this.deleteAssetModelsModal.afterClose = this.load.bind(this);
        this.load();
    }
    initGrid() {
        const openEditModalHandler = this.openEditAssetModel.bind(this);
        this.grid.kendoGrid({
            pageable: {
                pageSizes: [10, 100, 500],
                buttonCount: 5
            },
            sortable: true,
            mobile: true,
            resizable: true,
            scrollable: true,
            selectable: "multiple",
            change: this.handleSelection.bind(this),
            columns: [
                { selectable: true, width: "55px" },
                {
                    command: {
                        name: "Edit", iconClass: { edit: "pencil" }, click: function (e) {
                            e.preventDefault();
                            const tr = $(e.target).closest("tr");
                            const data = this.dataItem(tr);
                            openEditModalHandler(data);
                        },
                    },
                    width: "105px",
                },
                { field: "id", title: "ID", width: "55px", },
                { field: "modelName", title: "Model", width: "40%", },
                { field: "manufacturerName", title: "Manufacturer", width: "150px", },
                { field: "assetTypeName", title: "Asset Type", width: "40%", },
                { field: "imageUrl", title: "Image Url", width: "40%", },
                { field: "sku", title: "Sku", width: "40%", },
                { field: "description", title: "Description", width: "40%", },
            ],
            dataBound: this.onDataBound.bind(this),
        });
    }
    onDataBound(e) {
        let grid = e.sender;
        grid.tbody.find("tr").each(function () {
            let dataItem = grid.dataItem(this);
            if (!dataItem.companyName) {
                $(this).find(".k-grid-Edit").hide(); // Why is the class k-grid-Edit instead of k-grid-edit?
            }
        });
    }
    handleSelection() {
        const grid = this.grid.data("kendoGrid");
        const selectedItems = grid.selectedKeyNames();
        this.selectedAssetModels = selectedItems;
        if (this.selectedAssetModels.length > 0) {
            this.toggleDeleteButtonVisible(true);
        }
        else {
            this.toggleDeleteButtonVisible(false);
        }
    }
    populateGrid(models) {
        const grid = this.grid.data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: models,
            pageSize: 100,
            schema: {
                model: {
                    id: "id"
                }
            }
        });
        grid.setDataSource(dataSource);
        // remove edit ability on OptiFleet default asset types
        this.grid.find(".k-grid-Edit").each(function () {
            const row = $(this).closest("tr");
            const currentDataItem = grid.dataItem(row);
            if (currentDataItem.companyName == "Default") {
                row.parent().find(".k-checkbox").first().prop("disabled", true);
                $(this).remove();
            }
        });
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            this.getAssetModels();
        });
    }
    getAssetModels() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.get(this.assetModelsUrl);
            if (!res.success) {
                this.showErrorMessage("Failed to fetch Asset Models");
                return;
            }
            this.populateGrid(res.assetModels);
            this.assetModels = res.assetModels;
        });
    }
    openAddAssetModel() {
        this.addForm.companyId = this.getSelectedCompanyId();
        this.addForm.show();
        this.addFormModal.open();
    }
    openEditAssetModel(row) {
        this.editForm.load(row);
        this.editForm.companyId = this.getSelectedCompanyId();
        this.addForm.show();
        this.editFormModal.open();
    }
    promptDeleteConfirmation() {
        const numMiners = this.selectedAssetModels.length;
        const initData = OpConfirmationModal.getDeleteModalInitData(numMiners);
        this.deleteAssetModelsModal.open(initData);
    }
    confirmDelete() {
        this.delete(this.assetModelsUrl, { ids: this.selectedAssetModels }).then((res) => {
            this.toggleDeleteButtonVisible(false);
            this.load();
        });
    }
    toggleDeleteButtonVisible(active) {
        $("#btnDeleteAssetModels").css("display", active ? "flex" : "none");
    }
}

class AssetsFilters extends OptiFleetPage {
    constructor(assetsPage) {
        super();
        this.assetsPage = assetsPage;
        this.storedFiltersSelector = "assetsSelectedFilters";
        this.assets;
        this.assetIdFilter;
        this.assetNameFilter;
        this.assetTypeNameFilter;
        this.statusFilter;
        this.serialNumberFilter;
        this.skuFilter;
        this.manufacturerNameFilter;
        this.modelNameFilter;
        this.modelDescriptionFilter;
        this.stateFilter;
        this.cityFilter;
        this.addressFilter;
        // show means the filter is visible in the filter section
        this.filters = [
            { label: "Asset ID", id: "assetId", show: false, options: [] },
            { label: "Asset Name", id: "assetName", show: true, options: [] },
            { label: "Type", id: "assetTypeName", show: false, options: [] },
            { label: "Status", id: "status", show: false, options: [] },
            { label: "Serial Number", id: "serialNumber", show: false, options: [] },
            { label: "SKU", id: "sku", show: false, options: [] },
            { label: "Manufacturer", id: "manufacturerName", show: false, options: [] },
            { label: "Model", id: "modelName", show: false, options: [] },
            { label: "Model Description", id: "modelDescription", show: false, options: [] },
            { label: "State", id: "state", show: false, options: [] },
            { label: "City", id: "city", show: false, options: [] },
            { label: "Address", id: "address", show: false, options: [] },
        ];
        this.activeFilters = {};
        this.init();
    }
    init() {
        this.initFilters();
        let opFilters = [];
        this.filters.forEach(filter => {
            const filterName = `${filter.id}Filter`;
            this[filterName] = new OpFilter(filter.id, this.filterAssets.bind(this), this.clearFilter.bind(this), filter.options);
            opFilters.push(this[filterName]);
            if (!filter.show) {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
        });
        new SelectFilters("moreFilters", this.filters, this.changeActiveFilters.bind(this));
        new ClearFilters("clearFilters", opFilters);
    }
    initFilters() {
        const storedFiltersStr = localStorage.getItem(this.storedFiltersSelector);
        let storedFilters;
        try {
            storedFilters = JSON.parse(storedFiltersStr);
        }
        catch (e) {
            return;
        }
        if (!storedFilters) {
            return;
        }
        storedFilters.forEach(storedFilter => {
            // if is filter
            if (storedFilter.hasOwnProperty("id") && storedFilter.hasOwnProperty("label") && storedFilter.hasOwnProperty("show")) {
                var filter = this.filters.find((filter) => filter.id === storedFilter.id);
                if (filter) {
                    filter.show = storedFilter.show;
                }
            }
        });
    }
    filterAssets(formVal, propertyVal) {
        this.activeFilters[propertyVal] = formVal;
        let filteredAssets = this.assets;
        if (!filteredAssets) {
            return;
        }
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (!formVal || formVal === "" || formVal.length === 0) {
                return;
            }
            if (isTextInput) {
                filteredAssets = filteredAssets.filter(asset => {
                    const property = asset[filter.id] ? asset[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredAssets = filteredAssets.filter(asset => {
                    const property = asset[filter.id] ? asset[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        this.assetsPage.populateAssetsGrid(filteredAssets);
    }
    applyFilters(view) {
        let filteredAssets = this.assets;
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (isTextInput) {
                filteredAssets = filteredAssets.filter(asset => {
                    const property = asset[filter.id] ? asset[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredAssets = filteredAssets.filter(asset => {
                    const property = asset[filter.id] ? asset[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        this.assetsPage.populateAssetsGrid(filteredAssets);
    }
    clearFilter(id) {
        this.activeFilters[id] = "";
        this.filterAssets(id, "");
    }
    changeActiveFilters(newFilters) {
        this.filters = newFilters;
        this.filters.forEach(filter => {
            let filterRemoved = false;
            // If the filter is active and it's being remove
            if ($(`[c-id=${filter.id}]`).hasClass("active") && filter.show === false) {
                // Then clear the active state and remove the filting on the miner grid
                this[`${filter.id}Filter`].deactivateFilter();
                this.activeFilters[filter.id] = "";
                filterRemoved = true;
            }
            if (filter.show) {
                $(`[c-id=${filter.id}]`).removeClass("hide");
            }
            else {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
            if (filterRemoved) {
                this.filterAssets("", "");
            }
        });
        localStorage.setItem(this.storedFiltersSelector, JSON.stringify(this.filters));
    }
}

class AssetTypes extends OptiFleetPage {
    constructor() {
        super();
        this.assetTypesUrl = "/AssetTypes";
        this.assetTypes = [];
        this.activeFilters = {};
        this.grid = $("#assetTypesGrid");
        // search
        $("#assetTypesSearch").on("keyup", function (event) {
            if (event.keyCode == 13) {
                this.search();
            }
        }.bind(this));
        this.initGrid();
        this.initFilters();
        this.addForm = new AssetTypesFormView("AddAssetTypeModalView", $("#AddAssetTypeModalViewWrapper"));
        this.addFormModal = new OpProgressionModalBase("AddAssetTypeModal", [this.addForm], { submitUrl: this.assetTypesUrl, submitType: ProgressionModalSubmitType.POST });
        this.addFormModal.onClose = this.load.bind(this);
        this.editForm = new AssetTypesFormView("EditAssetTypeModalView", $("#EditAssetTypeModalViewWrapper"));
        this.editFormModal = new OpProgressionModalBase("EditAssetTypeModal", [this.editForm], { submitUrl: this.assetTypesUrl, submitType: ProgressionModalSubmitType.PATCH });
        this.editFormModal.onClose = this.load.bind(this);
        this.deleteAssetTypesModal = new OpConfirmationModal("DeleteAssetTypesModal", this.confirmDelete.bind(this));
        this.deleteAssetTypesModal.afterClose = this.load.bind(this);
        this.load();
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            this.getAssetsTypes();
        });
    }
    getAssetsTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.get(this.assetTypesUrl);
            if (!res.success) {
                this.showErrorMessage("Failed to fetch Asset Types");
                return;
            }
            this.populateGrid(res.assetTypes);
            this.assetTypes = res.assetTypes;
        });
    }
    initFilters() {
        this.filters = [
            { label: "Type", id: "assetTypesConsumable", field: "type", show: false, options: [{ id: "Consumable", label: "Consumable" }, { id: "Non-Consumable", label: "Non-Consumable" }] }
        ];
        this.consumableFilter = new OpFilter("assetTypesConsumable", this.filterAssets.bind(this), this.clearFilter.bind(this), this.filters[0].options);
        new ClearFilters("clearAssetTypesFilters", [this.consumableFilter]);
    }
    initGrid() {
        const openEditModalHandler = this.openEditAssetType.bind(this);
        this.grid.kendoGrid({
            pageable: {
                pageSizes: [10, 100, 500, 1000, 5000],
                buttonCount: 5
            },
            sortable: true,
            mobile: true,
            resizable: true,
            scrollable: true,
            selectable: "multiple",
            change: this.handleSelection.bind(this),
            columns: [
                { selectable: true, width: "55px" },
                {
                    command: {
                        name: "Edit", iconClass: { edit: "pencil" }, click: function (e) {
                            e.preventDefault();
                            const tr = $(e.target).closest("tr");
                            const data = this.dataItem(tr);
                            openEditModalHandler(data);
                        },
                    },
                    width: "105px",
                },
                { field: "id", title: "ID", width: "55px", },
                { field: "name", title: "Name", width: "100px", },
                { field: "companyName", title: "Company" },
                { field: "type", title: "Type" },
                { field: "description", title: "Description", width: "40%", },
            ]
        });
    }
    handleSelection() {
        const grid = this.grid.data("kendoGrid");
        const selectedItems = grid.selectedKeyNames();
        this.selectedAssetTypes = selectedItems;
        if (this.selectedAssetTypes.length > 0) {
            this.toggleDeleteButtonVisible(true);
        }
        else {
            this.toggleDeleteButtonVisible(false);
        }
    }
    populateGrid(assets) {
        const grid = this.grid.data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: assets,
            pageSize: 100,
            schema: {
                model: {
                    id: "id"
                }
            }
        });
        grid.setDataSource(dataSource);
        // remove edit ability on OptiFleet default asset types
        this.grid.find(".k-grid-Edit").each(function () {
            const row = $(this).closest("tr");
            const currentDataItem = grid.dataItem(row);
            if (currentDataItem.companyName == "Default") {
                row.parent().find(".k-checkbox").first().prop("disabled", true);
                $(this).remove();
            }
        });
        grid.refresh();
    }
    search() {
        const searchQuery = $("#assetTypesSearch").val();
        const searchQueryCleaned = searchQuery.toLowerCase();
        let filtered = this.applyFilters(this.assetTypes);
        if (searchQueryCleaned) {
            filtered = filtered.filter(item => {
                const company = item.companyName.toLowerCase();
                return (company.includes(searchQueryCleaned) || company == "Default") ||
                    item.description.toLowerCase().includes(searchQueryCleaned) ||
                    item.name.toLowerCase().includes(searchQueryCleaned) ||
                    item.id == searchQueryCleaned;
            });
        }
        this.populateGrid(filtered);
        if (searchQuery) {
            const el = $("#assetTypesSearchQuery");
            el.text(searchQueryCleaned);
            el.parent().show();
        }
        else {
            const el = $("#assetTypesSearchQuery");
            el.parent().hide();
        }
    }
    filterAssets(formVal, propertyVal) {
        this.activeFilters[propertyVal] = formVal;
        this.search();
    }
    applyFilters(list) {
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (!searchValue) {
                return;
            }
            if (isTextInput) {
                list = list.filter(asset => {
                    const property = asset[filter.id] ? asset[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                list = list.filter(asset => {
                    const property = asset[filter.field] ? asset[filter.field].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        return list;
    }
    clearFilter(id) {
        this.activeFilters[id] = "";
        $("#assetTypesSearch").val("");
        this.filterAssets(id, "");
    }
    toggleDeleteButtonVisible(active) {
        $("#btnDeleteAssetTypes").css("display", active ? "flex" : "none");
    }
    openAddAssetType() {
        this.addForm.companyId = this.getSelectedCompanyId();
        this.addForm.show();
        this.addFormModal.open();
    }
    openEditAssetType(row) {
        this.editForm.load(row);
        this.editForm.companyId = this.getSelectedCompanyId();
        this.editForm.show();
        this.editFormModal.open();
    }
    promptDeleteConfirmation() {
        const numMiners = this.selectedAssetTypes.length;
        const initData = OpConfirmationModal.getDeleteModalInitData(numMiners);
        this.deleteAssetTypesModal.open(initData);
    }
    confirmDelete() {
        this.delete(this.assetTypesUrl, { ids: this.selectedAssetTypes }).then((res) => {
            this.toggleDeleteButtonVisible(false);
            this.load();
        });
    }
    getAssetTypesDropdownData() {
        return this.assetTypes.map(assetType => {
            return { "text": assetType.name, "value": assetType.id.toString() };
        });
    }
}

class InventoryItems extends OptiFleetPage {
    constructor() {
        super();
        this.inventoryItemDialog = document.getElementById("dialogInventoryItem");
        this.inventoryGrid = $("#inventoryItemsGrid");
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        $("#manufacturerSelect")
            .on("change", () => this.populateManufacturerModels(this.manufacturersToModels.find((m => m.manufacturer.id == $("#manufacturerSelect").val())).manufacturer));
        // search
        $("#inventoryItemsSearch").on("keyup", function (event) {
            if (event.keyCode == 13) {
                this.search();
            }
        }.bind(this));
        this.initGrid();
        this.load();
    }
    handleCompanyFilterChanged(companyId) {
        this.siteCache.loadSites();
    }
    initGrid() {
        this.inventoryGrid.kendoGrid({
            pageable: {
                pageSizes: [10, 100, 500, 1000, 5000],
                buttonCount: 5
            },
            sortable: true,
            mobile: true,
            resizable: true,
            scrollable: true,
            selectable: "multiple",
            change: (e) => {
                this.selectedGridIds = e.sender.selectedKeyNames();
                if (this.selectedGridIds.length == 1) {
                    this.toggleEditButtonVisible(true);
                }
                else {
                    this.toggleEditButtonVisible(false);
                }
                if (this.selectedGridIds.length > 0) {
                    this.toggleDeleteButtonVisible(true);
                }
                else {
                    this.toggleDeleteButtonVisible(false);
                }
            },
            dataBound: function () {
                this.autoFitColumns();
            },
            columns: [
                { selectable: true, width: "55px" },
                { template: (item) => { return `<img src='${item.imageUrl}' style="width: var(--size-avatar-l)" />`; } },
                { field: "id", title: "ID" },
                { field: "name", title: "Name" },
                { field: "sku", title: "SKU" },
                { field: "manufacturer", title: "Manufacturer", template: (item) => { return item.manufacturer.name; } },
                { field: "model", title: "Model", template: (item) => { return item.model.name; } }
            ]
        });
    }
    load() {
        this.selectedGridIds = [];
        this.toggleEditButtonVisible(false);
        this.toggleDeleteButtonVisible(false);
        this.get("ManufacturerModels")
            .then((res) => {
            if (res.isAxiosError) {
                this.showErrorMessage("An error occured while fetching manufacturers and models.");
                $("#addInventoryItemBtn").prop("disabled", true);
                $("#editInventoryItemBtn").prop("disabled", true);
                return;
            }
            $("#addInventoryItemBtn").removeProp("disabled");
            $("#editInventoryItemBtn").removeProp("disabled");
            this.manufacturersToModels = res;
        });
        return this.getInventoryItems().then(inventoryItems => {
            this.loadedInventoryItems = inventoryItems;
            this.populateInventoryItemsGrid(inventoryItems);
        });
    }
    getInventoryItems() {
        return this.get("/inventory/items");
    }
    populateInventoryItemsGrid(inventoryItems) {
        const grid = this.inventoryGrid.data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: inventoryItems,
            pageSize: 100,
            schema: {
                model: {
                    id: "id"
                }
            }
        });
        grid.setDataSource(dataSource);
    }
    openInventoryItemDialog(dialogType) {
        $("#dialogInventoryItemSubmitBtn").off().on("click", this.submitNewInventoryItem.bind(this, dialogType));
        this.populateManufacturers();
        if (dialogType == "new") {
            $("#dialogInventoryItemHeader").text("New Item");
        }
        else {
            $("#dialogInventoryItemHeader").text("Edit Item");
            let selectedItem = this.loadedInventoryItems.find(item => item.id == this.selectedGridIds[0]);
            $("#inventoryItemNameInput").val(selectedItem.name);
            $("#inventoryItemSKUInput").val(selectedItem.sku);
            $("#inventoryItemImageUrlInput").val(selectedItem.imageUrl);
            $("#manufacturerSelect").val(selectedItem.manufacturer.id);
            $("#manufacturerSelect").trigger('change');
            $("#manufacturerModelSelect").val(selectedItem.model.id);
        }
        this.inventoryItemDialog.showModal();
    }
    closeInventoryItemDialog() {
        this.inventoryItemDialog.close();
        $("#inventoryItemNameInput").val("");
        $("#inventoryItemSKUInput").val("");
        $("#inventoryItemImageUrlInput").val("");
        $(this.inventoryItemDialog).find(".m-input.is-error").removeClass("is-error");
    }
    submitNewInventoryItem(dialogType) {
        var _a, _b, _c;
        $(this.inventoryItemDialog).find(".m-input.is-error").removeClass("is-error");
        let itemName = (_a = $("#inventoryItemNameInput").val()) !== null && _a !== void 0 ? _a : "";
        let itemSku = (_b = $("#inventoryItemSKUInput").val()) !== null && _b !== void 0 ? _b : "";
        let itemImageUrl = (_c = $("#inventoryItemImageUrlInput").val()) !== null && _c !== void 0 ? _c : "";
        let selectedManufacturerId = parseInt($("#manufacturerSelect").val());
        let selectedManufacturerModelId = parseInt($("#manufacturerModelSelect").val());
        if (itemName.length == 0) {
            $("#inventoryItemNameInput").addClass("is-error");
        }
        const error = $(this.inventoryItemDialog).find(".m-input.is-error").first();
        if (error.length > 0) {
            error.focus();
            return;
        }
        let item = {
            name: itemName,
            sku: itemSku,
            imageUrl: itemImageUrl,
            model: { id: selectedManufacturerModelId, name: this.manufacturersToModels.find(m => m.manufacturer.id == selectedManufacturerId).models.find(m => m.id == selectedManufacturerModelId).name },
            manufacturer: { id: selectedManufacturerId, name: this.manufacturersToModels.find(m => m.manufacturer.id == selectedManufacturerId).manufacturer.name }
        };
        this.toggleBusy(true);
        if (dialogType == "new") {
            this.post("/inventory/items", item, true)
                .then((res) => {
                if (res.isAxiosError) {
                    this.showErrorMessage("An error occured while creating inventory item.");
                }
                this.load()
                    .then(() => {
                    this.closeInventoryItemDialog();
                    this.toggleBusy(false);
                });
            });
        }
        else {
            let selectedItem = this.loadedInventoryItems.find(item => item.id == this.selectedGridIds[0]);
            this.patch(`/inventory/items/${selectedItem.id}`, item, true)
                .then((res) => {
                if (res.isAxiosError) {
                    this.showErrorMessage("An error occured while updating inventory item.");
                }
                this.load()
                    .then(() => {
                    this.closeInventoryItemDialog();
                    this.toggleBusy(false);
                });
            });
        }
    }
    deleteSelectedInventoryItems() {
        this.confirm("Delete Item", `Are you sure you want to delete ${this.selectedGridIds.length} inventory item${this.selectedGridIds.length > 1 ? "s" : ""}?`, () => {
            let urlQuery = `itemIds=${this.selectedGridIds.join("&itemIds=")}`;
            this.toggleBusy(true);
            this.delete(`/inventory/items?${urlQuery}`, undefined, true)
                .then((res) => {
                if (res.isAxiosError) {
                    this.showErrorMessage("An error occured while deleting inventory item(s).");
                }
                this.load().then(() => this.toggleBusy(false));
            });
        });
    }
    search() {
        const searchQuery = $("#inventoryItemsSearch").val();
        const searchQueryCleaned = searchQuery.toLowerCase();
        let filteredItems = this.loadedInventoryItems;
        if (searchQueryCleaned) {
            filteredItems = this.loadedInventoryItems.filter(item => {
                return item.id == searchQueryCleaned ||
                    item.name.toLowerCase().includes(searchQueryCleaned) ||
                    item.sku.toLowerCase().includes(searchQueryCleaned) ||
                    item.manufacturer.name.toLowerCase().includes(searchQueryCleaned) ||
                    item.model.name.toLowerCase().includes(searchQueryCleaned);
            });
        }
        this.populateInventoryItemsGrid(filteredItems);
        if (searchQuery) {
            const el = $("#inventoryItemsSearchQuery");
            el.text(searchQueryCleaned);
            el.parent().show();
        }
        else {
            const el = $("#inventoryItemsSearchQuery");
            el.parent().hide();
        }
    }
    populateManufacturers() {
        let manufacturerOptions = "";
        this.manufacturersToModels.forEach(manufacturerToModels => {
            manufacturerOptions += `
                    <option value="${manufacturerToModels.manufacturer.id}">${manufacturerToModels.manufacturer.name}</option>
                `;
        });
        $("#manufacturerSelect").empty().append(manufacturerOptions);
        this.populateManufacturerModels();
    }
    populateManufacturerModels(selectedManufacturer) {
        var _a;
        let modelOptions = "";
        let manufacturerToModels = (_a = this.manufacturersToModels.find(manufacturerToModels => manufacturerToModels.manufacturer == selectedManufacturer)) !== null && _a !== void 0 ? _a : this.manufacturersToModels[0];
        manufacturerToModels.models.forEach(model => {
            modelOptions += `
                    <option value="${model.id}">${model.name}</option>
                `;
        });
        $("#manufacturerModelSelect").empty().append(modelOptions);
    }
    toggleDeleteButtonVisible(active) {
        active ? $("#deleteInventoryItemsBtn").show() : $("#deleteInventoryItemsBtn").hide();
    }
    toggleEditButtonVisible(active) {
        active ? $("#editInventoryItemBtn").show() : $("#editInventoryItemBtn").hide();
    }
}

class Companies extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.companiesUrl = "/AllCompanies";
        this.upsertCompanyUrl = "/UpsertCompany";
        this.canEdit = false;
        this.canEdit = $(`#${window.hfId}`).val() === "true";
        this.initGrid();
        this.loadCompanies();
    }
    loadCompanies() {
        this.get(this.companiesUrl)
            .then((resp) => {
            this.populateCompaniesGrid(resp.companies);
        });
    }
    initGrid() {
        this.toggleBusy(true);
        let columns = [
            { field: "name", title: "Name" },
            { field: "email", title: "Contact Email", },
            { field: "minerCount", title: "Miner Count" },
            { field: "dateCreated", title: "Created", template: '#= dateCreated ? kendo.toString(dateCreated ,"MM/dd/yyyy") : "" #' },
            { field: "active", title: "Active Customer" }
        ];
        let toolbar = ["search"];
        if (this.canEdit) {
            columns = [
                { command: ["edit"], title: "&nbsp;", width: "125px" },
                ...columns
            ];
            toolbar = [
                { name: "create", text: "Add New Company" },
                ...toolbar
            ];
        }
        $("#companiesList").kendoGrid({
            dataSource: {
                data: []
            },
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            toolbar,
            search: {
                fields: [
                    { name: "name", operator: "contains" },
                    { name: "sonarId", operator: "eq" },
                    { name: "hubspotId", operator: "eq" },
                ]
            },
            editable: "inline",
            beforeEdit: this.onEdit.bind(this),
            save: this.onSave.bind(this),
            columns,
        });
    }
    onEdit(e) {
        e.model.fields.name.editable = e.model.isNew();
    }
    onSave(e) {
        const saveData = this.getCompanyData(e.model);
        this.toggleBusy(true);
        this.post(this.upsertCompanyUrl, { company: saveData })
            .then((resp) => {
            this.toggleBusy(false);
            if (!resp.successful) {
                this.showErrorMessage(resp.errorMessage);
                return;
            }
            this.showSuccessMessage("Saved!");
            this.loadCompanies();
        });
    }
    getCompanyData(model) {
        return {
            id: model.id,
            name: model.name,
            email: model.email,
            sonarId: model.sonarId,
            hubspotId: model.hubspotId,
            performanceBased: model.performanceBased,
            active: model.active
        };
    }
    populateCompaniesGrid(companies) {
        const grid = $("#companiesList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: companies,
            schema: {
                model: {
                    id: "id",
                    fields: {
                        id: { editable: false, nullable: true },
                        name: { validation: { required: true } },
                        email: { validation: { required: false } },
                        sonarId: { validation: { required: false } },
                        hubspotId: { validation: { required: false } },
                        performanceBased: { type: "boolean", validation: { required: false } },
                        minerCount: { type: "number", editable: false },
                        dateCreated: { type: "date", editable: false },
                        active: { type: "boolean", validation: { required: false } },
                    }
                }
            }
        });
        grid.setDataSource(dataSource);
        this.toggleBusy(false);
    }
}

class HashingTypes {
    static getUnits(hashingTypeId) {
        for (const unitType of HashingTypes.HashingUnits) {
            if (unitType.hashingTypeId === hashingTypeId) {
                return unitType.scales;
            }
        }
        return [];
    }
}
HashingTypes.HashingUnits = [
    {
        hashingTypeId: 1,
        scales: ["Hs", "KHs", "MHs", "GHs", "THs", "PHs"],
    },
    {
        hashingTypeId: 2,
        scales: ["Sol/s", "KSol/s", "MSol/s", "GSol/s", "TSol/s", "PSol/s"],
    },
    {
        hashingTypeId: 3,
        scales: ["Gps", "KGps", "MGps", "GGps", "TGps", "PGps"],
    },
];

class ActiveModelsPanel {
    constructor(httpService) {
        this.httpService = httpService;
        this.siteModelsUrl = "/sitesModels";
        this.initActiveModelsGrid();
    }
    initActiveModelsGrid() {
        $("#activeModelsGrid").kendoGrid(Object.assign(Object.assign({}, DEFAULT_GRID_OPTIONS$2), { dataSource: {
                data: [],
                pageSize: 20
            }, columns: [
                { field: "modelName", title: "Model Name", filterable: { multi: true } },
                { field: "modelCount", title: "Count", filterable: false },
                { field: "powerConsumption", title: "Power Consumption (W)" },
                {
                    field: "hashRate", title: "Hash Rate",
                    template: ({ modelName, hashRate }) => HashrateUtil.parseHashrate(parseInt(hashRate), undefined, modelName.toLowerCase().includes("z15")),
                    sortable: {
                        compare: function (a, b) {
                            return parseInt(a.hashRate) - parseInt(b.hashRate);
                        }
                    }
                },
                {
                    field: "sumExpectedHashrate", title: "Total Exp. Hash Rate",
                    template: ({ modelName, sumExpectedHashrate }) => HashrateUtil.parseHashrate(parseInt(sumExpectedHashrate), undefined, modelName.toLowerCase().includes("z15")),
                    sortable: {
                        compare: function (a, b) {
                            return parseInt(a.sumExpectedHashrate) - parseInt(b.sumExpectedHashrate);
                        }
                    }
                }
            ] }));
    }
    populateActiveModelsGrid(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.httpService.get(`${this.siteModelsUrl}?siteId=${siteId}`);
            this._populateActiveModelsGrid(resp);
        });
    }
    _populateActiveModelsGrid(data) {
        const models = data === null || data === void 0 ? void 0 : data.siteModels;
        const grid = $("#activeModelsGrid").data("kendoGrid");
        let options = DEFAULT_GRID_OPTIONS$2;
        options.dataSource = [];
        if (models) {
            const dataSource = new self.kendo.data.DataSource({
                data: models,
                pageSize: models.length,
                schema: {
                    model: {
                        id: "modelId",
                        fields: {
                            modelName: { editable: false, nullable: false },
                            powerConsumption: { validation: { required: true } },
                            hashRate: { validation: { required: true } },
                            modelCount: { validation: { required: true } },
                            sumExpectedHashrate: { validation: { required: false } }
                        }
                    }
                },
            });
            options.dataSource = dataSource;
            // needed to render pagination element
            grid.refresh();
        }
        grid.setOptions(Object.assign({}, options));
        grid.dataSource.read();
    }
    exportToExcel() {
        $("#activeModelsGrid")
            .data("kendoGrid")
            .saveAsExcel();
    }
}
const NO_RECORDS_TEMPLATE$1 = `
        <div class="m-stack is-horizontal">
            <div class="ee-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="24" viewBox="0 0 25 24" fill="none">
                    <path d="M21.5 3L3.5 21M21.5 12C21.5 16.9706 17.4706 21 12.5 21C7.52944 21 3.5 16.9706 3.5 12C3.5 7.02944 7.52944 3 12.5 3C17.4706 3 21.5 7.02944 21.5 12Z" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
            </div>
            <span class="m-text is-tertiary is-size-l">There are no active models...</span>
        </div>
    `;
const DEFAULT_GRID_OPTIONS$2 = {
    pageable: {
        pageSize: 20,
        numeric: false,
        previousNext: false,
        input: false,
        info: true,
        responsive: false
    },
    autoBind: false,
    excel: {
        allPages: true
    },
    scrollable: {
        endless: true
    },
    filterable: true,
    persistSelection: true,
    groupable: false,
    sortable: true,
    resizable: true,
    noRecords: {
        template: () => NO_RECORDS_TEMPLATE$1
    },
};

class SiteSettingsPanel {
    constructor(httpService) {
        this.httpService = httpService;
        this.poolConfigUrl = "/ApprovedPoolConfigs";
        this.whitelistedPoolsUrl = "/WhitelistedPools";
        this.rebootRestrictionsUrl = "/RebootRestrictions";
        this.siteSettingsUrl = "/SiteSettings";
        this.minersByURL = "/MinersBy";
        this.canEdit = $(`#${window.hfId}`).val() === "true";
        this.initApprovedPoolConfigsGrid();
        this.initRebootRestrictionGrid();
        this.initCooldownDropdown();
        this.poolConfigModal = new OpApprovedPoolConfigModal(httpService, "ApprovedPoolConfigModal");
        this.whitelistedPoolsModal = new OpWhitelistedPoolsModal(httpService, "WhitelistedPoolsModal", $("#WhitelistedPoolsModalContent"));
        this.poolConfigModal.onSave = this.refresh.bind(this);
        this.rebootRestrictionsModal = new RebootRestrictionModal("RebootRestrictionsModal");
        this.rebootRestrictionsModal.onClose = this.refresh.bind(this);
        $("#whitelistedpoolslink").click((event) => {
            event.preventDefault();
            this.openWhitelistedPools();
        });
    }
    refresh(siteId) {
        if (siteId) {
            this.siteId = siteId;
            this.rebootRestrictionsModal.setSiteId(siteId);
        }
        this.httpService.get(`${this.whitelistedPoolsUrl}?siteId=${this.siteId}`)
            .then((resp) => {
            this.whitelistedPoolConfigs = {
                whitelistedPools: resp.whitelistedPools,
                whitelistedSubaccounts: resp.whitelistedSubaccounts,
                siteId: siteId
            };
        });
        this.httpService.get(`${this.poolConfigUrl}?siteId=${this.siteId}`)
            .then((resp) => {
            this.approvedPoolConfigs = resp.approvedPoolConfigs;
            this.populatePoolConfigsGrid(resp.approvedPoolConfigs);
        });
        this.httpService.get(`${this.rebootRestrictionsUrl}?siteId=${this.siteId}`)
            .then((resp) => {
            this.rebootRestrictions = resp.rebootRestrictions;
            this.populateRebootRestrictionsGrid(resp);
        });
        this.httpService.get(`${this.minersByURL}?siteId=${siteId}`).then((resp) => {
            this.rebootRestrictionsModal.setMiners(resp.miners);
        });
        this.httpService.get(`${this.siteSettingsUrl}?siteIds=${this.siteId}`).then((resp) => {
            for (const siteSetting of resp.siteSettings) {
                if (siteSetting.siteId == this.siteId) {
                    $("#rebootCooldownPicker").data("kendoDropDownList").value(siteSetting.rebootCooldownMinutes.toString());
                    return;
                }
            }
            $("#rebootCooldownPicker").data("kendoDropDownList").value("0");
        });
    }
    initCooldownDropdown() {
        $("#rebootCooldownPicker").kendoDropDownList({
            dataSource: kendo.data.DataSource.create({
                data: [
                    { name: "No Cooldown", value: 0 },
                    { name: "30 Minutes", value: 30 },
                    { name: "1 Hours", value: 60 },
                    { name: "2 Hours", value: 120 },
                ]
            }),
            dataTextField: "name",
            dataValueField: "value",
            value: "0",
            change: this.updateSiteSettings.bind(this),
        });
        if (!this.canEdit) {
            const dd = $(".cooldown-dropdown").find(".dropdown").first();
            dd.prop("onclick", "");
            dd.removeClass("clickable");
        }
    }
    initApprovedPoolConfigsGrid() {
        let commands = [];
        if (this.canEdit) {
            commands = [
                {
                    name: "edit",
                    className: "k-grid-edit-row",
                    text: "",
                    iconClass: "k-icon k-i-edit",
                    click: this.editPoolConfig.bind(this),
                },
                {
                    name: "delete",
                    className: "k-grid-delete-row",
                    text: "",
                    iconClass: "k-icon k-i-delete",
                    click: this.deletePoolConfig.bind(this)
                }
            ];
        }
        $("#approvedPoolGrid").kendoGrid(Object.assign(Object.assign({}, DEFAULT_GRID_OPTIONS$1), { noRecords: {
                template: () => NO_RECORDS_TEMPLATE("approved pool configs")
            }, dataSource: {
                data: [],
                pageSize: 20
            }, columns: [
                {
                    command: commands,
                    title: "&nbsp;", width: this.canEdit ? "100px" : "15px"
                },
                { field: "poolConfigName", title: "Configuration", filterable: false },
                { title: "Date Created", filterable: false, template: '#= dateCreated ? kendo.toString(new Date(dateCreated) ,"MM/dd/yyyy") : "" #' },
                { field: "username", title: "User Created", filterable: false },
            ] }));
    }
    initRebootRestrictionGrid() {
        let commands = [];
        if (this.canEdit) {
            commands = [
                {
                    name: "edit",
                    click: this.openEditRebootRestriction.bind(this),
                },
                {
                    className: "k-grid-delete-row",
                    text: "Delete",
                    iconClass: "k-icon k-i-delete",
                    click: this.deleteRestriction.bind(this),
                }
            ];
        }
        this.restrictionsGrid = $("#rebootRestrictionsGrid").kendoGrid(Object.assign(Object.assign({}, DEFAULT_GRID_OPTIONS$1), { noRecords: {
                template: () => NO_RECORDS_TEMPLATE("reboot restrictions")
            }, columns: [
                {
                    command: commands,
                    title: "&nbsp;", width: "125px"
                },
                { field: "startTime", title: "Start Time", template: this.startTimeFormatter.bind(this) },
                { field: "repeat", title: "Repeat", template: this.repeatFormatter.bind(this) },
                { field: "duration", width: "240px", title: "Duration", template: this.durationFormatter.bind(this), },
                { field: "zones", title: "Zone Boundary", template: this.zoneListFormatter.bind(this) },
                { field: "miners", title: "Miner Boundary", template: this.minerListFormatter.bind(this) },
            ] })).data("kendoGrid");
    }
    populatePoolConfigsGrid(configs) {
        const grid = $("#approvedPoolGrid").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: configs,
            pageSize: 20,
        });
        grid.setDataSource(dataSource);
        grid.dataSource.read();
        $(".k-grid-edit-row").attr("style", "background-color: transparent !important;");
        $(".k-grid-delete-row").attr("style", "background-color: transparent !important;");
    }
    populateRebootRestrictionsGrid(data) {
        data.rebootRestrictions.forEach(r => r.startTime = new Date(r.startTime));
        const grid = $("#rebootRestrictionsGrid").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: data.rebootRestrictions,
            pageSize: 20,
        });
        grid.setDataSource(dataSource);
        grid.dataSource.read();
    }
    openAddPoolConfig() {
        this.whitelistedPoolConfigs = this.whitelistedPoolsModal.whitelistedPoolsData == null ? this.whitelistedPoolConfigs : this.whitelistedPoolsModal.whitelistedPoolsData;
        this.poolConfigModal.open({
            poolConfig: null,
            whitelistedPoolsData: this.whitelistedPoolConfigs,
            siteId: this.siteId
        });
    }
    openWhitelistedPools() {
        this.whitelistedPoolConfigs = this.whitelistedPoolsModal.whitelistedPoolsData == null ? this.whitelistedPoolConfigs : this.whitelistedPoolsModal.whitelistedPoolsData;
        this.whitelistedPoolsModal.open(this.whitelistedPoolConfigs);
    }
    editPoolConfig(e) {
        const grid = $("#approvedPoolGrid").data("kendoGrid");
        const row = $(e.currentTarget).closest("tr");
        const dataItem = grid.dataItem(row);
        const id = dataItem.get("approvedPoolConfigId");
        const config = this.approvedPoolConfigs.find(c => c.approvedPoolConfigId == id);
        if (!config) {
            return;
        }
        this.whitelistedPoolConfigs = this.whitelistedPoolsModal.whitelistedPoolsData == null ? this.whitelistedPoolConfigs : this.whitelistedPoolsModal.whitelistedPoolsData;
        this.poolConfigModal.open({
            poolConfig: config,
            whitelistedPoolsData: this.whitelistedPoolConfigs,
            siteId: this.siteId
        });
    }
    openAddRebootRestriction() {
        this.rebootRestrictionsModal.open();
    }
    openEditRebootRestriction(event) {
        const row = $(event.currentTarget).closest("tr");
        const dataItem = this.restrictionsGrid.dataItem(row);
        const rebootRestrictionsId = dataItem.get("rebootRestrictionsId");
        const editData = this.rebootRestrictions.find(item => item.rebootRestrictionsId === Number(rebootRestrictionsId));
        this.rebootRestrictionsModal.open();
        this.rebootRestrictionsModal.loadData(editData);
    }
    deletePoolConfig(e) {
        e.preventDefault();
        const grid = $("#approvedPoolGrid").data("kendoGrid");
        const row = $(e.currentTarget).closest("tr");
        const dataItem = grid.dataItem(row);
        const id = dataItem.get("approvedPoolConfigId");
        const name = dataItem.get("poolConfigName");
        this.httpService.confirm("Delete Pool Configuration", `Are you sure you want to delete ${name}?`, () => {
            this.httpService.delete(this.poolConfigUrl, { approvedPoolConfigId: id })
                .then(() => {
                this.refresh(this.siteId);
            });
        });
    }
    deleteRestriction(event) {
        event.preventDefault();
        this.httpService.confirm("Delete Reboot Restriction", "Are you sure you want to remove this restriction?", () => {
            const row = $(event.currentTarget).closest("tr");
            const dataItem = this.restrictionsGrid.dataItem(row);
            const rebootRestrictionsId = dataItem.get("rebootRestrictionsId");
            const data = {
                rebootRestrictionsId: rebootRestrictionsId
            };
            this.httpService.delete(this.rebootRestrictionsUrl, data).then((resp) => {
                this.refresh(this.siteId);
            });
        });
    }
    updateSiteSettings(e) {
        const saveData = {
            siteId: this.siteId,
            rebootCooldownMinutes: e.sender.value()
        };
        $(".reboot-cooldown-save-icon").addClass("active");
        this.httpService.post(this.siteSettingsUrl, saveData).then((resp) => {
            $(".reboot-cooldown-save-icon").removeClass("active");
        });
    }
    setZones(zones) {
        this.rebootRestrictionsModal.setZones(zones);
    }
    // Formatters
    repeatFormatter(model) {
        return model.repeat ? "Daily" : "None";
    }
    startTimeFormatter(model) {
        const formatted = kendo.toString(new Date(model.startTime), "MM/dd/yyyy hh:mm tt");
        return formatted;
    }
    durationFormatter(model) {
        const minutes = parseInt(model.duration);
        if (minutes % 60 == 0) {
            const hours = (minutes / 60);
            return `${hours} hour${hours > 1 ? "s" : ""}`;
        }
        return `${minutes} minute${minutes > 1 ? "s" : ""}`;
    }
    minerListFormatter(model) {
        if (!model.miners || model.miners.length < 1) {
            return "All Miners";
        }
        const templateData = { items: model.miners.map(miner => miner.minerName) };
        return self.Mustache.to_html(SiteSettingsPanel.ListItemTemplate, templateData);
    }
    zoneListFormatter(model) {
        if ((!model.zones || model.zones.length < 1) && model.miners.length < 1) {
            return "All Zones";
        }
        const templateData = { items: model.zones.map(zone => zone.zoneName) };
        return self.Mustache.to_html(SiteSettingsPanel.ListItemTemplate, templateData);
    }
}
SiteSettingsPanel.ListItemTemplate = `
            <div>
                <ul class="m-stack" style="padding: 0px;grid-row-gap: var(--space-xs);">
                
                {{#items}}
                    <li class="m-chip">
                        <span unselectable="on">{{.}}</span>
                    </li>
                {{/items}}
                </ul>
            </div>
        `;
function NO_RECORDS_TEMPLATE(text) {
    return `
        <div class="m-stack is-horizontal">
            <div class="ee-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="24" viewBox="0 0 25 24" fill="none">
                    <path d="M21.5 3L3.5 21M21.5 12C21.5 16.9706 17.4706 21 12.5 21C7.52944 21 3.5 16.9706 3.5 12C3.5 7.02944 7.52944 3 12.5 3C17.4706 3 21.5 7.02944 21.5 12Z" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
            </div>
            <span class="m-text is-tertiary is-size-l">There are no ${text}...</span>
        </div>
    `;
}
const DEFAULT_GRID_OPTIONS$1 = {
    pageable: {
        pageSize: 20,
        numeric: false,
        previousNext: false,
        input: false,
        info: true,
        responsive: false
    },
    autoBind: false,
    excel: {
        allPages: true
    },
    scrollable: {
        endless: true
    },
    filterable: true,
    persistSelection: true,
    groupable: false,
    sortable: true,
    resizable: true,
};

const CONFIRMATION_TEXT$1 = "Deleting this zone will also delete its' racks and unassign any linked miners. Are you sure you want to continue?";
class ZonePanel extends OptiFleetPage {
    constructor(siteId) {
        super();
        this.locations = null;
        this.siteDetails = null;
        this.siteLayout = [];
        this.canEdit = false;
        this.invertRowsUrl = "/InvertRows";
        this.siteId = siteId.toString();
        this.zoneId = "";
        this.canEdit = this.canEdit = $(`#${window.hfId}`).val() === "true";
        this.addZoneModalView = new RackDetailsFormView($("#AddZoneModalViewWrapper"), RackDetailsFormType.AddZone);
        this.addZoneModal = new OpProgressionModalBase("AddZoneModal", [this.addZoneModalView], { submitUrl: "/Zones", submitType: ProgressionModalSubmitType.POST });
        this.deleteZoneModal = new OpConfirmationModal("DeleteZoneConfirmationModal", this.confirmDeleteZone.bind(this));
        this.addRackModalView = new RackDetailsFormView($("#AddRackModalViewWrapper"), RackDetailsFormType.AddRack);
        this.addRackModal = new OpProgressionModalBase("AddRackModal", [this.addRackModalView], { submitUrl: "/Rack", submitType: ProgressionModalSubmitType.POST });
        this.editRackModalView = new RackDetailsFormView($("#EditRackModalViewWrapper"), RackDetailsFormType.EditRack);
        this.editRackModal = new OpProgressionModalBase("EditRackModal", [this.editRackModalView], { submitUrl: "/Rack", submitType: ProgressionModalSubmitType.PATCH });
        this.editRackModalView.progressionModal = this.editRackModal; // edit modal needs progression modal methods to handle delete rack submission
        this.addZoneModal.onClose = this.refreshData.bind(this);
        this.addRackModal.onClose = this.refreshSiteLayout.bind(this);
        this.editRackModal.onClose = this.refreshSiteLayout.bind(this);
        this.toggleBusy(true);
        this.initData().then(() => {
            this.refreshData();
        });
        this.toggleBusy(false);
    }
    minerStats(linkedMinerCount, totalSlots) {
        $("#zone-linked").empty().append(linkedMinerCount + " LINKED MINERS");
        $("#zone-total-slots").empty().append(totalSlots + " SLOTS");
    }
    renderRacks() {
        $("#racks").empty();
        let linkedMinerCount = 0;
        let totalSlots = 0;
        if (!this.zones.some(zone => zone.zoneId == Number(this.zoneId))) {
            $(".show-if-zone").hide();
            return;
        }
        $(".show-if-zone").show();
        const currentLayout = this.siteLayout.find(zone => zone.zoneId == Number(this.zoneId));
        if (!currentLayout) {
            $(".show-if-rack").hide();
            $(".show-if-not-rack").show();
            return;
        }
        $(".show-if-rack").show();
        $(".show-if-not-rack").hide();
        currentLayout.invertedRows ?
            $("#invertRowsInput").attr("checked", "checked") :
            $("#invertRowsInput").removeAttr("checked");
        currentLayout.racks = currentLayout.racks.sort(alphaNumRackSortFn);
        currentLayout.racks.forEach((rack, _) => {
            let rackData = {
                rackName: "",
                agentName: "",
                tableData: "",
                linkedMiners: 0,
                totalSlots: 0,
                canEdit: this.canEdit
            };
            rackData.rackName = rack.name;
            rackData.agentName = rack.agents.join(",");
            rackData.tableData = "";
            let rows = rack.rows;
            if (currentLayout.invertedRows) {
                if (rows.length > 0 && rows[0].name < rows[rows.length - 1].name) {
                    rows = rows.reverse();
                }
            }
            rows.forEach((row, rowIndex) => {
                if (rowIndex === 0) {
                    rackData.tableData += "<tr>";
                    rackData.tableData += self.Mustache.to_html(SitesMustacheTemplates.ROW_START, { row: row.name });
                }
                else {
                    // new row but not first
                    rackData.tableData += "</tr><tr>";
                    rackData.tableData += self.Mustache.to_html(SitesMustacheTemplates.ROW_START, { row: row.name });
                }
                for (let slotIndex = 0; slotIndex < row.numSlots; slotIndex++) {
                    if (row.filledSlotIndeces.includes(slotIndex)) {
                        rackData.tableData += self.Mustache.to_html(SitesMustacheTemplates.FILLED_RACK_POSITION);
                        rackData.linkedMiners += 1;
                    }
                    else {
                        rackData.tableData += self.Mustache.to_html(SitesMustacheTemplates.EMPTY_RACK_POSITION);
                    }
                    rackData.totalSlots += 1;
                }
            });
            totalSlots += rackData.totalSlots;
            linkedMinerCount += rackData.linkedMiners;
            this.renderRack(rackData);
        });
        this.minerStats(linkedMinerCount, totalSlots);
    }
    initData() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initZones();
        });
    }
    refreshData() {
        return __awaiter(this, void 0, void 0, function* () {
            const ddl = $("#ddlZones").data("kendoDropDownList");
            ddl.dataSource.data([]);
            yield this.initZones();
            yield this.refreshSiteLayout();
        });
    }
    refreshSiteLayout() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.fetchSiteLayout().then(() => this.renderRacks());
        });
    }
    fetchSiteLayout() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.get(`/Layout?siteId=${this.siteId}`);
            this.siteLayout = resp.zones;
        });
    }
    renderRack(rack) {
        rack.tableData += "</tr>";
        const template = $(self.Mustache.to_html(SitesMustacheTemplates.RACK_CARD, rack));
        $("#racks").append(template);
        template.find(".edit-rack-btn").click(this.openEditRackModal.bind(this, rack.rackName));
    }
    initZones() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.get(`/Zones`)
                .then((resp) => {
                this.zones = resp.zones.filter(zone => zone.siteId == +this.siteId && zone.zoneName !== "All Zones");
                const zonesDataSource = this.zones.map(zone => {
                    return {
                        name: zone.zoneName,
                        id: zone.zoneId,
                    };
                });
                const dataSource = new self.kendo.data.DataSource({
                    data: zonesDataSource
                });
                if (zonesDataSource.length > 0)
                    this.zoneId = zonesDataSource[0].id.toString();
                const ddlZones = $("#ddlZones").data("kendoDropDownList");
                if (!ddlZones || !ddlZones.dataSource || ddlZones.dataSource.data().length === 0) {
                    $("#ddlZones").kendoDropDownList({
                        dataSource: dataSource,
                        height: 200,
                        dataTextField: "name",
                        dataValueField: "id",
                        change: (e) => {
                            this.zoneId = e.sender.value();
                            this.renderRacks();
                        }
                    });
                    return;
                }
                ddlZones.setDataSource(dataSource);
            });
        });
    }
    handleDuplicateZoneBtnClick() {
        let dupZone;
        this.addZoneModal.reset();
        this.addZoneModalView.siteId = this.siteId;
        let zoneToDup = this.siteLayout.filter(l => l.zoneId == Number(this.zoneId));
        if (zoneToDup.length != 1) {
            const zone = this.zones.find(zone => zone.zoneId == Number(this.zoneId));
            dupZone = { zoneId: zone.zoneId, zoneName: zone.zoneName, agentName: zone.agentName, racks: [], invertedRows: false };
        }
        else {
            dupZone = JSON.parse(JSON.stringify(zoneToDup[0]));
        }
        dupZone.zoneName = dupZone.zoneName + " (Duplicate)";
        dupZone.racks.forEach(rack => {
            rack.rows.forEach(row => {
                row.filledSlotIndeces = [];
                row.slotData = [];
            });
        });
        this.addZoneModalView.load([dupZone]);
        this.addZoneModal.open();
    }
    openAddZoneModal() {
        this.addZoneModal.reset();
        this.addZoneModalView.siteId = this.siteId;
        this.addZoneModal.open();
    }
    openAddRackModal() {
        this.addRackModal.reset();
        this.addRackModalView.siteId = this.siteId;
        const zone = this.zones.find(zone => zone.zoneId == Number(this.zoneId));
        const initData = { zoneId: zone.zoneId, zoneName: zone.zoneName, agentName: zone.agentName, racks: [RackCard.DEFAULT_RACK], invertedRows: false };
        this.addRackModalView.load([initData]);
        this.addRackModal.open();
    }
    openEditRackModal(rackName) {
        this.editRackModal.reset();
        this.editRackModalView.siteId = this.siteId;
        let initData = structuredClone(this.siteLayout.find(z => z.zoneId == Number(this.zoneId)));
        initData.racks = [initData.racks.find(rack => rack.name === rackName)];
        this.editRackModalView.load([initData]);
        this.editRackModal.open();
    }
    promptDeleteZoneConfirmation() {
        this.deleteZoneModal.open({ primaryText: CONFIRMATION_TEXT$1 });
    }
    confirmDeleteZone() {
        this.delete("/Zone", { zoneId: this.zoneId }).then(() => {
            this.refreshData();
        });
    }
    invertRows(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const invertedRows = event.checked;
            const zoneId = this.zoneId;
            const resp = yield this.post(this.invertRowsUrl, { zoneId, invertedRows });
            if (!resp.success) {
                this.showErrorMessage("Failed to invert rows for zone");
                return;
            }
            this.toggleBusy(true);
            yield this.fetchSiteLayout();
            this.renderRacks();
            this.toggleBusy(false);
        });
    }
}
function alphaNumRackSortFn(rackA, rackB) {
    return sortFn(rackA.name, rackB.name);
}
const regex = /^([a-z]*)(\d*)/i;
function sortFn(a, b) {
    var _a = a.match(regex);
    var _b = b.match(regex);
    // if the alphabetic part of a is less than that of b => -1
    if (_a[1] < _b[1])
        return -1;
    // if the alphabetic part of a is greater than that of b => 1
    if (_a[1] > _b[1])
        return 1;
    // if the alphabetic parts are equal, check the number parts
    var _n = parseInt(_a[2]) - parseInt(_b[2]);
    if (_n == 0) // if the number parts are equal start a recursive test on the rest
        return sortFn(a.substr(_a[0].length), b.substr(_b[0].length));
    // else, just sort using the numbers parts
    return _n;
}

var styles$2 = i$4`#tag-table::part(table) {
  vertical-align: middle !important;
  overflow: auto;
}

#tag-table::part(header) {
  color: var(--color-text-tertiary);
  position: sticky;
  top: 0px;
  background: var(--color-background-secondary);
  z-index: 1;
}`;

const canEdit = $(`#${window.hfId}`).val() === "true";
const columnHelper$1 = createColumnHelper();
const columns$1 = [
    columnHelper$1.accessor("visible", {
        cell: (info) => {
            const visible = info.row.original.visible;
            if (!canEdit) {
                if (visible)
                    return x `<div class="m-checkbox" >
                        <input type="checkbox" class="visible-checkbox" id="checkbox-${info.cell.id}" onchange="s.tagsPanel.changeTagVisiblity('${info.cell.row.original.name}')" disabled checked />
                        <label class="m-label" for="checkbox-${info.cell.id}"></label>
                        </div>`;
                else
                    return x `<div class="m-checkbox" >
                        <input type="checkbox" class="visible-checkbox" id="checkbox-${info.cell.id}" onchange="s.tagsPanel.changeTagVisiblity('${info.cell.row.original.name}')" disabled />
                        <label class="m-label" for="checkbox-${info.cell.id}"></label>
                        </div>`;
            }
            if (visible)
                return x `<div class="m-checkbox" >
                        <input type="checkbox" class="visible-checkbox" id="checkbox-${info.cell.id}" onchange="s.tagsPanel.changeTagVisiblity('${info.cell.row.original.name}')" checked />
                        <label class="m-label" for="checkbox-${info.cell.id}"></label>
                        </div>`;
            else
                return x `<div class="m-checkbox" >
                        <input type="checkbox" class="visible-checkbox" id="checkbox-${info.cell.id}" onchange="s.tagsPanel.changeTagVisiblity('${info.cell.row.original.name}')" />
                        <label class="m-label" for="checkbox-${info.cell.id}"></label>
                        </div>`;
        },
        header: "Visible",
    }), columnHelper$1.accessor("name", {
        cell: (info) => { return info.row.original.name; },
        header: "Tag Name",
    }),
    columnHelper$1.accessor("dateCreated", {
        cell: (info) => `${kendo.toString(new Date(info.row.original.dateCreated), "MM/dd/yyyy")}`,
        header: "Date Created",
    }),
    columnHelper$1.accessor("username", {
        cell: (info) => { return info.row.original.username.split("@")[0]; },
        header: "Created By",
    }),
    columnHelper$1.accessor("count", {
        cell: (info) => { return info.row.original.count; },
        header: "Instances",
    }),
    columnHelper$1.accessor("removeAll", {
        cell: (info) => {
            const tagName = info.row.original.name;
            if (info.row.original.count > 0 && canEdit)
                return x `  <m-button icon="x-circle" variant="tertiary" onclick="s.tagsPanel.ClearInstances('${tagName}')" style="display:block; width:fit-content; margin-left:2rem;">
                            </m-button>`;
            else
                return x `  <m-button icon="x-circle" variant="tertiary" onclick="s.tagsPanel.ClearInstances('${tagName}')" style="display:block; width:fit-content; margin-left:2rem;" disabled>
                            </m-button>`;
        },
        header: "Clear Instances",
    }),
    columnHelper$1.accessor("removeAll", {
        cell: (info) => {
            const tagName = info.row.original.name;
            if (canEdit)
                return x `  <m-button variant="tertiary" align-icon="end" icon="trash-2" onclick="s.tagsPanel.DeleteTag('${tagName}')" style="display:block; width:fit-content; margin-left:1rem;">
                            </m-button>`;
            else
                return x `  <m-button variant="tertiary" align-icon="end" icon="trash-2" onclick="s.tagsPanel.DeleteTag('${tagName}')" style="display:block; width:fit-content; margin-left:1rem;" disabled>
                            </m-button>`;
        },
        header: "Delete Tag",
    }),
];
let TagsTable = class TagsTable extends s$1 {
    constructor() {
        super(...arguments);
        this.tags = [];
    }
    render() {
        return x `<m-table
        id="tag-table"
            .data=${this.tags}
            .columns=${columns$1}
            layout="auto"
            variant="ghost"
        >
        </m-table>`;
    }
};
TagsTable.styles = styles$2;
__decorate([
    n$1()
], TagsTable.prototype, "tags", void 0);
TagsTable = __decorate([
    t$2("tags-table")
], TagsTable);

class TagsPanel extends OptiFleetPage {
    constructor(siteId) {
        // this.toggleNoTagsDisplay();
        super();
        this.tagsUrl = "/Tags";
        this.tagsToAdd = [];
        this.tagsToDelete = [];
        this.tagsList = [];
        this.siteId = siteId.toString();
        this.init();
        $("#add-tags").on("click", this.toggleNoTagsDisplay.bind(this));
    }
    toggleNoTagsDisplay() {
        $(".no-tags-display").removeClass("active");
        $(".tags-view").addClass("active");
    }
    init() {
        this.get(`${this.tagsUrl}?siteId=${this.siteId}&includeInvisible=true`).then((resp) => {
            if (resp.tags.length > 0) {
                this.originalTagsList = resp.tags;
                this.tagsList = JSON.parse(JSON.stringify(resp.tags));
                this.PopulateTaglist(false);
                this.toggleNoTagsDisplay();
            }
        });
    }
    AddNewTag() {
        var _a;
        const tagName = (_a = $("#TagInput").val()) === null || _a === void 0 ? void 0 : _a.toString().trim();
        if (tagName.length < 1) {
            $('#validTagNameError').addClass("active");
            return;
        }
        $('#validTagNameError').removeClass("active");
        if (this.tagsList.find(tag => tag.name == tagName)) {
            $('#duplicateTagNameError').addClass("active");
            return;
        }
        $('#duplicateTagNameError').removeClass("active");
        const user = JSON.parse(localStorage.getItem("user"));
        $("#TagInput").val("");
        const newTag = {
            id: -1,
            name: tagName,
            dateCreated: new Date(),
            username: user["username"],
            count: 0,
            visible: true
        };
        this.tagsToAdd.push(tagName);
        this.tagsList.push(newTag);
        this.PopulateTaglist(true);
    }
    HandleCancelClick() {
        this.toggleBusy(true);
        this.tagsToAdd = [];
        this.tagsToDelete = [];
        this.tagsList = this.originalTagsList ? JSON.parse(JSON.stringify(this.originalTagsList)) : [];
        this.PopulateTaglist(false);
        this.toggleBusy(false);
    }
    changeTagVisiblity(name) {
        this.tagsList.find(tag => tag.name == name).visible = !this.tagsList.find(tag => tag.name == name).visible;
        $("#SaveTagChanges").removeAttr("disabled");
    }
    SaveChanges() {
        this.toggleBusy(true);
        this.SaveTags().then((success) => {
            this.toggleBusy(false);
            if (success) {
                this.showSuccessMessage("Changes saved successfully!");
                this.refresh();
                $("#SaveTagChanges").attr("disabled", "true");
            }
        });
    }
    SaveTags() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            var success = false;
            if (this.tagsToDelete.length > 0) {
                const saveData = {
                    siteId: this.siteId,
                    TagIds: this.tagsToDelete
                };
                const resp = yield this.delete(this.tagsUrl, saveData);
                if (!resp.success) {
                    this.showErrorMessage("Something went wrong while saving.  Please try again.");
                    return false;
                }
                success = true;
            }
            if (this.tagsToAdd.length > 0) {
                const saveData = {
                    siteId: this.siteId,
                    TagNames: this.tagsToAdd
                };
                const resp = yield this.post(this.tagsUrl, saveData);
                if (!resp.success) {
                    this.showErrorMessage("Something went wrong while saving.  Please try again.");
                    return false;
                }
                success = true;
            }
            var tagsToUpdate = [];
            (_a = this.originalTagsList) === null || _a === void 0 ? void 0 : _a.forEach((tag) => {
                const updatedTag = this.tagsList.find(x => x.name == tag.name);
                if (updatedTag && (tag.visible !== updatedTag.visible))
                    tagsToUpdate.push(updatedTag);
            });
            if (tagsToUpdate.length > 0) {
                const saveData = {
                    siteId: this.siteId,
                    Tags: tagsToUpdate
                };
                const resp = yield this.post(`${this.tagsUrl}/update`, saveData);
                if (!resp.success) {
                    this.showErrorMessage("Something went wrong while saving.  Please try again.");
                    return false;
                }
                success = true;
            }
            return success;
        });
    }
    DeleteTag(tagName) {
        const tag = this.tagsList.find(x => x.name == tagName);
        if (tag.id == -1) {
            this.tagsList = this.tagsList.filter(x => x.name != tag.name);
            this.tagsToAdd = this.tagsToAdd.filter(x => x != tag.name);
        }
        else {
            this.tagsToDelete.push(tag.id);
            this.tagsList = this.tagsList.filter(x => x.id != tag.id);
        }
        this.PopulateTaglist(true);
    }
    ClearInstances(tagName) {
        const tag = this.tagsList.find(x => x.name == tagName);
        this.confirm("Clear Instances", `Are you sure you want to clear this tag from all miners?`, () => {
            this.delete(`/Miners${this.tagsUrl}/${tag.id.toString()}`)
                .then((resp) => {
                if (resp.success) {
                    this.showSuccessMessage("Instances Cleared!");
                    this.tagsList.find(x => x.name == tagName).count = 0;
                    this.originalTagsList.find(x => x.name == tagName).count = 0;
                    this.PopulateTaglist(false);
                }
                else
                    this.showErrorMessage("Unable to Clear Instances, try againn!");
            });
        });
    }
    PopulateTaglist(enableSaveButton) {
        const tagList = document.querySelector("tags-table");
        tagList.tags = [...this.tagsList];
        enableSaveButton ? $("#SaveTagChanges").removeAttr("disabled")
            : $("#SaveTagChanges").attr("disabled", "true");
    }
    refresh() {
        this.tagsToAdd = [];
        this.tagsToDelete = [];
        this.originalTagsList = [];
        $('#validTagNameError').removeClass("active");
        $('#duplicateTagNameError').removeClass("active");
        this.init();
    }
}

class LayoutBuilder {
    constructor() {
        //noop
    }
    static BuildZone(zone) {
        const tables = [];
        for (let rack = 0; rack < zone.racks; rack++) {
            const table = document.createElement("table");
            table.className = `miner-rack rack-${rack + 1}`;
            const tableHeader = document.createElement("th");
            tableHeader.colSpan = zone.positions + 1;
            tableHeader.className = "rack-header";
            if (/^[A-Z]/.test(zone.topRack)) {
                tableHeader.innerText = `Rack ${String.fromCharCode(rack + 65)}`;
            }
            else {
                tableHeader.innerText = `Rack ${rack + 1}`;
            }
            table.appendChild(tableHeader);
            const tableHeaderRow = document.createElement("tr");
            for (let headerCell = 0; headerCell < zone.positions + 1; headerCell++) {
                const cell = document.createElement("td");
                if (headerCell == 0) {
                    cell.innerText = "Row";
                    cell.className = `row-0 column-${headerCell}`;
                }
                else {
                    cell.innerText = headerCell.toString();
                    cell.style.textAlign = "center";
                    cell.className = `row-0 column-${headerCell}`;
                }
                tableHeaderRow.appendChild(cell);
            }
            table.appendChild(tableHeaderRow);
            for (let row = 0; row < zone.rows; row++) {
                const tableRow = document.createElement("tr");
                for (let position = 0; position < zone.positions + 1; position++) {
                    const cell = document.createElement("td");
                    if (position == 0) {
                        cell.innerText = `${row + 1}`;
                        cell.className = `row-${row + 1} column-${position}`;
                    }
                    else {
                        cell.className = `miner-position-cell row-${row + 1} column-${position}`;
                    }
                    if (/^[A-Z]/.test(zone.topRack)) {
                        cell.setAttribute("position", `${String.fromCharCode(rack + 65)}-${row + 1}-${position}`);
                        cell.setAttribute("location", `${zone.zoneName}-${String.fromCharCode(rack + 65)}-${row + 1}-${position}`);
                    }
                    else {
                        cell.setAttribute("position", `${rack + 1}-${row + 1}-${position}`);
                        cell.setAttribute("location", `${zone.zoneName}-${rack + 1}-${row + 1}-${position}`);
                    }
                    tableRow.appendChild(cell);
                }
                table.appendChild(tableRow);
            }
            const tableFooter = document.createElement("tfoot");
            tableFooter.className = "rack-footer";
            table.appendChild(tableFooter);
            tables.push(table);
        }
        return tables;
    }
}

class Sites extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.sitesUrl = "/sites";
        this.canEdit = $(`#${window.hfId}`).val() === "true";
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.init();
        const siteDetailsFormView = new SiteDetailsFormView("SiteDetailsFormView");
        const agentDetailsFormView = new AgentDetailsFormView("AgentDetailsFormView", $("#AddSiteModalViewWrapper"), { initNullFields: true, allowDelete: true });
        const zoneDetailsFormView = new RackDetailsFormView($("#AddSiteModalViewWrapper"), RackDetailsFormType.CreateSite);
        let views = [siteDetailsFormView, agentDetailsFormView, zoneDetailsFormView];
        this.addSiteModal = new OpProgressionModalBase("AddSiteModal", views, { submitUrl: this.sitesUrl, submitType: ProgressionModalSubmitType.POST });
        this.addSiteModal.onClose = this.getSites.bind(this);
    }
    handleCompanyFilterChanged() {
        if (this.getSelectedCompanyId() <= 0) {
            this.toggleSelectCompany(true);
            return;
        }
        this.toggleSelectCompany(false);
        this.getSites();
    }
    init() {
        if (!this.canEdit) {
            $('.m-input').prop("disabled", true);
            $('.m-input').prop("type", "text");
        }
        this.getSites();
    }
    getSites() {
        this.toggleBusy(true);
        this.get(this.sitesUrl)
            .then((resp) => {
            this.loadSites(resp.sites);
            this.toggleBusy(false);
        });
    }
    showSiteDetails(e) {
        e.preventDefault();
        const grid = $("#siteGrid").data("kendoGrid");
        const row = $(e.currentTarget).closest("tr");
        const dataItem = grid.dataItem(row);
        const siteId = dataItem.get("siteId");
        if (!siteId) {
            return;
        }
        this.editSite(siteId);
    }
    loadSites(sites) {
        $("#site-grid").empty();
        sites.forEach((site) => {
            const template = self.Mustache.to_html(SitesMustacheTemplates.SITE_CARD, site);
            $("#site-grid").append(template);
        });
    }
    editSite(siteId) {
        OptiFleetMaster.goTo(`Administration/SiteDetails?siteId=${siteId}`);
    }
    createSite() {
        this.addSiteModal.reset();
        this.addSiteModal.open();
    }
    openHelp() {
        $("#mainHelp").addClass("active");
    }
    closeHelp() {
        $("#mainHelp").removeClass("active");
    }
    exportToExcel() {
        //this.siteDetailsPanel.exportToExcel();
    }
}

class SitesMustacheTemplates {
}
SitesMustacheTemplates.SITE_CARD = `
            <div class="m-box has-space-none">
                    <div class="m-box is-variant-ghost">
                        <div class="m-stack is-horizontal site-title-row">
                            <div class="m-stack is-horizontal is-align-center">   
                                <m-icon id="building-icon" name="building-2" size="l"></m-icon>
                                <h2>{{siteName}}</h2>
                            </div>
                        <div onClick="s.editSite({{siteId}})"><m-icon size="xl" id="arrow-icon" name="arrow-right"></m-icon></div>
                    </div>
                </div>
                <div class="m-divider has-space-xs"></div>
                <div class="m-grid-list site-stats">
                    <div class="m-box is-variant-ghost">
                        <div class="m-stack has-space-s">
                            <div class="m-heading is-size-m is-tertiary has-space-l">Miner Capacity</div>
                            <div class="m-text is-size-xl">{{capacity}}</div>
                        </div>
                    </div>
                    <div class="m-box is-variant-ghost">
                        <div class="m-stack has-space-s">
                            <div class="m-heading is-size-m is-tertiary has-space-l">Miners Monitored</div>
                            <div class="m-text is-size-xl">{{onlineCount}}</div>
                        </div>
                    </div>
                    <div class="m-box is-variant-ghost">
                        <div class="m-stack has-space-s">
                            <div class="m-heading is-size-m is-tertiary has-space-l">Agents Configured</div>
                            <div class="m-text is-size-xl">{{agentCount}}</div>
                        </div>
                    </div>
                    <div class="m-box is-variant-ghost">
                        <div class="m-stack has-space-s">
                            <div class="m-heading is-size-m is-tertiary has-space-l">Zones Configured</div>
                            <div class="m-text is-size-xl">{{zoneCount}}</div>
                        </div>
                    </div>
                    <div class="m-box is-variant-ghost">
                        <div class="m-stack has-space-s">
                            <div class="m-heading is-size-m is-tertiary has-space-l">Unreachable Miners</div>
                            <div class="m-text is-size-xl">{{unreachableCount}}</div>
                        </div>
                    </div>
                    <div class="m-box is-variant-ghost">
                        <div class="m-stack has-space-s">
                            <div class="m-heading is-size-m is-tertiary has-space-l">Unassigned Miners</div>
                            <div class="m-text is-size-xl">{{unassignedLocations}}</div>
                        </div>
                    </div>
                </div>
            </div>
        `;
SitesMustacheTemplates.RACK_CARD = `
            <div class="m-box rack-panel">
                <div class="m-stack is-horizontal has-space-between" id="rack-header">
                    <h3>Rack Name</h3>
                    {{#canEdit}}
                    <button class="m-button is-tertiary edit-rack-btn" type="button">Edit</button>
                    {{/canEdit}}
                </div>
                <div class="m-stack is-horizontal">
                    <div class="m-box has-space-s rack-details">
                        <p class="m-text is-tertiary">{{rackName}}</p>
                    </div>
                </div>
                <div id="rack-grid" style="overflow-x: auto; overflow-y: auto;">
                    <table id="rack-{{rackName}}" class="rack-table" style="overflow-x: auto; overflow-y: auto;">
                        {{{tableData}}}
                    </table>
                </div>
                <div id="linked-miner-count">
                    <span class="is-accent m-text linked">{{linkedMiners}} LINKED MINERS</span>
                    <span class="is-tertiary m-text divider">/</span>
                    <span class="is-tertiary m-text">{{totalSlots}} SLOTS</span>
                </div>
            </div>
        `;
SitesMustacheTemplates.ROW_START = `<td class="m-text m-table-cell table-cell row-start">{{row}}</td>`;
SitesMustacheTemplates.FILLED_RACK_POSITION = `<td class="m-text m-table-cell table-cell success"></td>`;
SitesMustacheTemplates.EMPTY_RACK_POSITION = `<td class="m-text m-table-cell table-cell"></td>`;

class TicketDetailsPanel {
    constructor(ticketing, preselectedMiners, canEdit = false) {
        this.ticketing = ticketing;
        this.canEdit = canEdit;
        this.ticketDetailUrl = "/TicketDetails";
        this.createTicketUrl = "/Ticketing";
        this.noteUrl = "/TicketNote";
        this.statusUrl = "/TicketStatus";
        this.ticketMinersUrl = "/TicketMiners";
        this.ticketEventsUrl = "/TicketEvents";
        this.linkedMiners = [];
        this.editLock = false;
        this.detailsPanel = new OpMinerDetailsPanel(canEdit);
        this.statusFieldComponent = new OpTicketFieldDropdown("StatusField", DefaultTickeFieldDropdownList.Status);
        this.statusFieldComponent.canEdit = canEdit;
        this.priorityFieldComponent = new OpTicketFieldDropdown("PriorityField", DefaultTickeFieldDropdownList.Priority);
        this.priorityFieldComponent.canEdit = canEdit;
        this.assignFieldComponent = new OpTicketFieldDropdown("AssignField", DefaultTickeFieldDropdownList.NULL);
        this.assignFieldComponent.canEdit = canEdit;
        this.siteFieldComponent = new OpTicketFieldDropdown("SiteField", DefaultTickeFieldDropdownList.NULL, SITE_ICON);
        this.siteFieldComponent.canEdit = canEdit;
        this.labelFieldComponent = new OpTicketFieldDropdown("LabelField", DefaultTickeFieldDropdownList.Label, TICKET_LABEL_ICON);
        this.labelFieldComponent.canEdit = canEdit;
        this.resolutionModal = new OpTicketResolutionModal(this.ticketing, "TicketResolutionModal", this.handleResolutionModalClose.bind(this));
        if ((preselectedMiners === null || preselectedMiners === void 0 ? void 0 : preselectedMiners.length) > 0) {
            this.linkedMiners = preselectedMiners.map(m => parseInt(m));
        }
        if (this.canEdit) {
            $("#createTicketCancelButton").on("click", this.close.bind(this));
            $("#createTicketSubmitButton").on("click", this.saveNewTicket.bind(this));
        }
        if (window.sessionStorage["site_cache"]) {
            const site = JSON.parse(window.sessionStorage.getItem("site_cache"));
            this.preselectedSite = site;
        }
    }
    open(ticketId) {
        this.reset();
        $(".ticket-details-panel").addClass("active");
        if (ticketId === undefined) {
            this.initCreatePage();
        }
        else {
            this.initDetailsPage(ticketId);
        }
        $("#ticketList").hide();
    }
    initCreatePage() {
        $("#detailsPageHeader").text("New Ticket");
        $("#createTicketHeaderCorner").addClass("active");
        $("#newTicketCommentButton").hasClass('active') && $("#newTicketCommentButton").removeClass("active");
        this.statusFieldComponent.onSelectionChanged = null;
        this.priorityFieldComponent.onSelectionChanged = null;
        this.assignFieldComponent.onSelectionChanged = null;
        this.siteFieldComponent.onSelectionChanged = null;
        this.labelFieldComponent.onSelectionChanged = null;
        $("#ticketTitle").off("focusout");
        $("#ticketDescription").off("focusout");
        $("#newTicketComment").off("focusout");
        if (window.localStorage["selectedSite"]) {
            this.siteFieldComponent.setOptions(this.sites, window.localStorage["selectedSite"]);
        }
        const initData = {
            allMiners: this.miners,
            preselectedMiners: this.linkedMiners
        };
        this.detailsPanel.openCreateTicketView(initData);
    }
    initDetailsPage(ticketId) {
        this.ticketId = ticketId;
        $("#detailsPageHeader").text("Ticket:");
        $("#ticketDetailsHeaderCorner").addClass("active");
        $("#newTicketCommentButton").hasClass('active') || $("#newTicketCommentButton").removeClass("active");
        if (this.canEdit) {
            this.statusFieldComponent.onSelectionChanged = this.handleTicketStatusUpdate.bind(this);
            this.priorityFieldComponent.onSelectionChanged = this.updateTicketFields.bind(this);
            this.assignFieldComponent.onSelectionChanged = this.updateTicketFields.bind(this);
            this.siteFieldComponent.onSelectionChanged = this.updateTicketFields.bind(this);
            this.labelFieldComponent.onSelectionChanged = this.updateTicketFields.bind(this);
            $("#ticketTitle").focusout(this.updateTicketFields.bind(this));
            $("#ticketDescription").focusout(this.updateTicketFields.bind(this));
            $("#newTicketComment").focusout(this.saveComment.bind(this));
        }
        else {
            $("#newTicketComment").hide();
            $("#ticketTitle").prop("contenteditable", "false");
            $("#ticketDescription").prop("contenteditable", "false");
        }
        const initData = {
            allMiners: this.miners
        };
        this.detailsPanel.openTicketDetailsView(initData, this.loadTicketDependencies.bind(this), this.updateTicketMiner.bind(this));
        this.loadTicketDependencies();
    }
    initSites(sites) {
        const siteOptions = sites.map(s => {
            return {
                id: s.siteId,
                icon: "",
                label: s.siteName
            };
        });
        this.sites = siteOptions;
        this.siteFieldComponent.setOptions(siteOptions);
    }
    initAssignees(users) {
        const unassigned = {
            id: -1,
            label: "Unassigned",
            el: Avatar.genUnassigned()
        };
        let assignees = users.map(u => {
            return {
                id: u.userId,
                label: u.email,
                el: Avatar.gen(u.userId, "", 'assignee-avatar'),
            };
        });
        assignees = [unassigned, ...assignees];
        this.assignFieldComponent.setOptions(assignees);
    }
    initMiners(miners) {
        this.miners = miners;
    }
    close() {
        //$(".ticket-details-panel").removeClass("active");
        //$(".ticket-details-column").removeClass("active");
        //$("#createTicketMinersPanel").removeClass("active");
        //$("#allMinerDetails").removeClass("active");
        //$("#createTicketHeaderCorner").removeClass("active");
        //$("#ticketDetailsHeaderCorner").removeClass("active");
        //$("#createTicketCancelButton").off("click");
        //$("#createTicketSubmitButton").off("click");
        $("#ticketTitle").off('focusout');
        $("#ticketDescription").off('focusout');
        $("#newTicketComment").off('focusout');
        this.reset();
        //$("#createTicketMinersPanel").html("");
        $("#activityList").html("");
        this.linkedMiners = [];
        this.ticketId = undefined;
        this.detailsPanel.close();
        $("#ticketList").show();
    }
    resetTicketFields() {
        this.statusFieldComponent.reset();
        this.priorityFieldComponent.reset();
        this.assignFieldComponent.reset();
        this.siteFieldComponent.reset();
        this.labelFieldComponent.reset();
    }
    reset() {
        $("#lblTicketId").text("");
        $("#lblTicketId").text("");
        $("#ticketTitle").text("");
        $("#ticketDescription").text("");
        this.detailsPanel.reset();
        this.resetTicketFields();
    }
    loadTicketDependencies() {
        return __awaiter(this, void 0, void 0, function* () {
            this.ticketing.toggleBusy(true);
            const details = this.loadTicketDetails();
            const activity = this.loadTicketActivity();
            yield Promise.all([details, activity]);
            this.ticketing.toggleBusy(false);
        });
    }
    loadTicketDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            const ticketProps = yield this.ticketing.get(`${this.ticketDetailUrl}?ticketId=${this.ticketId}`);
            this.ticket = ticketProps;
            this.populateTicketDetails(ticketProps);
        });
    }
    loadTicketActivity() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.ticketing.get(`${this.ticketEventsUrl}?ticketId=${this.ticketId}`);
            this.populateTicketActivity(resp);
        });
    }
    populateTicketActivity(resp) {
        $("#activityList").html("");
        const user = JSON.parse(localStorage.getItem("user"));
        const now = window.moment(Date.now());
        resp.events.forEach((event, index) => {
            event['index'] = index;
            event['eventText'] = TicketDetailTemplates.TICKET_ACTIVITY_TEXT[event.ticketEventTypeId];
            const start = window.moment(new Date(event.eventDate));
            event['elapsedTime'] = window.moment.duration(now.diff(start)).humanize();
            let template;
            if ((event.ticketEventTypeId == 6 || event.ticketEventTypeId == 8) && event.ticketNoteId && (user === null || user === void 0 ? void 0 : user.username) === event.initiator) {
                const html = event.ticketEventTypeId == 6 ? TicketDetailTemplates.ACTIVITY_COMMENT_EDITABLE : TicketDetailTemplates.ACTIVITY_RESOLUTION_EDITABLE;
                template = self.Mustache.to_html(html, event);
                const commentInputElId = `#editComment${index}`;
                $("#activityList").append(template);
                $(`#commentMenuIcon${index}`).click(this.toggleCommentMenu.bind(this, index));
                $(`#commentMenuEdit${index}`).click(this.openEditComment.bind(this, index));
                $(`#commentMenuDelete${index}`).click(this.deleteComment.bind(this, event.ticketNoteId));
                $(`#commentSubmitButton${index}`).click(this.editComment.bind(this, commentInputElId, event.ticketNoteId, event.newValue));
                $(`#commentMenuEdit${index}`).off('focusout');
                $(commentInputElId).focusout(this.resetComment.bind(this, commentInputElId, index, event.newValue));
            }
            else {
                template = self.Mustache.to_html(TicketDetailTemplates.TICKET_ACTIVITY_TEMPLATE_MAP[event.ticketEventTypeId], event);
                $("#activityList").append(template);
            }
            const icon = Avatar.gen(event.initiatorId, event.initiator, 'activity-icon');
            $(`#activityIcon${index}`).append(icon);
        });
        this.initUserCommentInput();
    }
    initUserCommentInput() {
        const user = JSON.parse(localStorage.getItem("user"));
        let avatar;
        if ((user === null || user === void 0 ? void 0 : user.userId) && (user === null || user === void 0 ? void 0 : user.username)) {
            avatar = Avatar.gen(user.userId, user.username, 'activity-icon');
        }
        else {
            avatar = Avatar.genUnassigned(false);
        }
        $("#newTicketComment").text("");
        $("#currentUserCommentAvatar").html("");
        $("#currentUserCommentAvatar").append(avatar);
    }
    toggleCommentMenu(eventIndex, e) {
        const menuId = `#commentMenu${eventIndex}`;
        const isActive = $(menuId).hasClass('active');
        const iconId = menuId.replace("commentMenu", "commentMenuIcon");
        if (isActive) {
            $(menuId).removeClass('active');
            $(iconId).removeClass('active');
        }
        else {
            $(menuId).addClass('active');
            $(iconId).addClass('active');
        }
    }
    populateTicketDetails(resp) {
        $("#lblTicketId").text(`${resp.id}`);
        $("#ticketTitle").text(resp.name);
        $("#ticketDescription").text(resp.description);
        this.statusFieldComponent.setDefaultValue(parseInt(resp.statusId));
        this.priorityFieldComponent.setDefaultValue(parseInt(resp.priorityId));
        this.siteFieldComponent.setDefaultValue(parseInt(resp.siteId));
        this.labelFieldComponent.setDefaultValue(parseInt(resp.categoryId));
        this.assignFieldComponent.setDefaultValue(resp.owner || "Unassigned");
        this.detailsPanel.updateData(resp);
    }
    handleTicketStatusUpdate(id, value, prevValue) {
        return __awaiter(this, void 0, void 0, function* () {
            if (value.label === "Closed") {
                const initData = {
                    ticketId: this.ticketId,
                    oldValue: prevValue,
                    newValue: value
                };
                yield this.resolutionModal.open(initData);
            }
            else {
                yield this.updateTicketFields(id, value, prevValue);
            }
        });
    }
    handleResolutionModalClose(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data.success) {
                this.statusFieldComponent.setDefaultValue(data.initData.oldValue.id);
            }
            yield this.loadTicketDependencies();
            yield this.onTicketUpdated();
            this.statusFieldComponent.closeMenu();
        });
    }
    updateTicketFields(id, value, prevValue) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            if (!this.isTicketFormChange(this.ticket)) {
                return resolve();
            }
            let data = {};
            data['ticketId'] = this.ticket.id;
            data['statusId'] = this.statusFieldComponent.getSelectedValue().id;
            data['priorityId'] = this.priorityFieldComponent.getSelectedValue().id;
            data['owner'] = this.assignFieldComponent.getSelectedValue().label;
            data['siteId'] = this.siteFieldComponent.getSelectedValue().id;
            data['categoryId'] = this.labelFieldComponent.getSelectedValue().id;
            data['name'] = $(`#ticketTitle`).text();
            data['description'] = $(`#ticketDescription`).text();
            const resp = yield this.ticketing.patch(this.ticketDetailUrl, { tickets: [data] });
            if (!resp.success) {
                this.ticketing.showErrorMessage("An error occurred while saving.  Please try again.");
                resolve();
            }
            this.ticketing.showSuccessMessage("Ticket saved!");
            this.onTicketUpdated(false);
            yield this.loadTicketDependencies();
            resolve();
        }));
    }
    isTicketFormChange(ticket) {
        if (this.ticket.name !== $(`#ticketTitle`).text()) {
            return true;
        }
        if (ticket.description !== $(`#ticketDescription`).text()) {
            return true;
        }
        if (parseInt(this.ticket.statusId) !== this.statusFieldComponent.getSelectedValue().id) {
            return true;
        }
        if (parseInt(this.ticket.priorityId) !== this.priorityFieldComponent.getSelectedValue().id) {
            return true;
        }
        if (this.ticket.owner !== this.assignFieldComponent.getSelectedValue().label) {
            return true;
        }
        if (parseInt(this.ticket.siteId) !== this.siteFieldComponent.getSelectedValue().id) {
            return true;
        }
        if (parseInt(this.ticket.categoryId) !== this.labelFieldComponent.getSelectedValue().id) {
            return true;
        }
        return false;
    }
    saveNewTicket() {
        let data = {};
        data['statusId'] = this.statusFieldComponent.getSelectedValue().id;
        data['priorityId'] = this.priorityFieldComponent.getSelectedValue().id;
        data['owner'] = this.assignFieldComponent.getSelectedValue().label;
        data['siteId'] = this.siteFieldComponent.getSelectedValue().id;
        data['categoryId'] = this.labelFieldComponent.getSelectedValue().id;
        data['name'] = $(`#ticketTitle`).text();
        data['description'] = $(`#ticketDescription`).text();
        data['minerIds'] = this.linkedMiners;
        data['note'] = $("#newTicketComment").text().trim();
        this.ticketing.post(this.createTicketUrl, data).then((resp) => {
            if (!resp.success) {
                this.ticketing.showErrorMessage("An error occurred while saving.  Please try again.");
            }
            this.ticketing.showSuccessMessage("Ticket saved!");
            this.close();
            this.onTicketCreated();
        });
    }
    updateTicketMiner(minerId) {
        this.ticketing.toggleBusy(true);
        this.ticketing.patch(this.ticketMinersUrl, { ticketId: this.ticketId, minerId })
            .then((resp) => {
            this.ticketing.toggleBusy(false);
            if (!resp.success) {
                this.ticketing.showErrorMessage("An error occurred while saving.  Please try again.");
                return;
            }
            this.ticketing.showSuccessMessage("Ticket saved!");
            this.reset();
            this.loadTicketDependencies();
            this.onTicketUpdated();
        });
    }
    resetComment(inputId, eventIndex, prevValue, e) {
        // wait for lock to be set in case user is trying to submit
        setTimeout(() => {
            if (this.editLock) {
                this.editLock = false;
                return;
            }
            $(inputId).text(prevValue);
            this.closeEditComment(eventIndex);
        }, 250);
    }
    editComment(elId, noteId, prevValue, e) {
        this.editLock = true;
        const text = $(elId).text();
        if (!text || text == prevValue.trim())
            return;
        const req = {
            note: text,
            noteId
        };
        this.ticketing.patch(this.noteUrl, req).then((res) => __awaiter(this, void 0, void 0, function* () {
            if (!res.success) {
                this.ticketing.showErrorMessage("Unable to save comment");
                return;
            }
            yield this.loadTicketDependencies();
        }));
    }
    openEditComment(eventIndex) {
        const input = $(`#editComment${eventIndex}`);
        input.prop("contenteditable", "plaintext-only");
        input.focus();
        $(`#commentSubmitButton${eventIndex}`).addClass('active');
        this.toggleCommentMenu(eventIndex);
    }
    closeEditComment(eventIndex) {
        $(`#editComment${eventIndex}`).prop("contenteditable", "false");
        $(`#commentSubmitButton${eventIndex}`).removeClass('active');
    }
    deleteComment(commentId) {
        this.ticketing.delete(this.noteUrl, { noteId: commentId }).then((resp) => {
            if (!resp.success) {
                this.ticketing.showErrorMessage(resp.message);
                return;
            }
            this.loadTicketDependencies();
        });
    }
    saveComment(e) {
        const text = $("#newTicketComment").text();
        if (!text)
            return;
        this.ticketing.toggleBusy(true);
        this.ticketing.post(this.noteUrl, { note: text, ticketId: this.ticketId })
            .then((resp) => {
            this.ticketing.toggleBusy(false);
            if (!resp.success) {
                this.ticketing.showErrorMessage("An error occurred while saving your note.  Please try again.");
                return;
            }
            this.loadTicketDependencies();
        });
    }
}

class TicketDetailTemplates {
}
TicketDetailTemplates.MINER = `
            <div class="ticket-miner">
                <div class="ticket-miner-header">
                    <i class="icon-cpu miner-icon"></i>
                    <a class="miner-wrapper" href="/Content/Miners/IndividualMiner.aspx?Id={{minerId}}" target="_blank">
                        {{minerName}}
                    </a>
                </div>
                <div class="ticket-miner-property">
                    <div class="m-label">
                        Hashing Potential
                    </div>
                    <div class="hashrate-bar-wrapper">
                        <div class="hashrate-bar">
                            <div class="hashrate" style="width: {{hashratePercent}}%">
                                {{hashrateFormatted}}
                            </div>
                        </div>
                        {{expectedHashrateFormatted}}
                    </div>
                </div>

                <div class="ticket-miner-property">
                    <div class="m-label">
                        Uptime
                    </div>
                    <div class="miner-prop">
                        {{uptimeFormatted}}
                    </div>
                </div>

                <div class="ticket-miner-property">
                    <div class="m-label">
                        Location
                    </div>
                    <div class="miner-prop">
                        {{location}}
                    </div>
                </div>

                <div class="ticket-miner-property">
                    <div class="m-label">
                        Model
                    </div>
                    <div class="miner-prop">
                        {{modelName}}
                    </div>
                </div>

                <div class="ticket-miner-property">
                    <div class="m-label">
                        Worker
                    </div>
                    <div class="miner-prop">
                        {{accountWorker}}
                    </div>
                </div>
            </div>
        `;
TicketDetailTemplates.CHANGE_MINER_LIST_ITEM = `
            <div id="changeMinerItem{{ minerId }}" class="change-miner-list-item">
                <p class="miner-list-item-text">{{ ipAddress }}</p>
            </div>
        `;
TicketDetailTemplates.ADD_MINER_CHIP = `
            <div id="addedMinerItem{{ minerId }}" class="added-miner-chip m-chip">
                <p class="added-miner">{{ ipAddress }}</p>
                <i id='removeMiner{{ minerId }}' class="icon-minus-circle remove-miner-icon clickable"></i>
            </div>
        `;
TicketDetailTemplates.RECENT_TICKET = `
            <div id="recentTicket{{ id }}" class="recent-ticket m-stack is-horizontal has-space-between is-align-center clickable">
                <div class="recent-ticket-left m-stack is-horizontal is-align-center">
                    <div class="recent-ticket-number">{{ id }}</div>
                    <img class="recent-ticket-icon" src='data:image/svg+xml;base64,{{ icon }}' alt = "" />
                </div>
                <div class="recent-ticket-right m-chip"><p>{{ category }}</p></div>
            </div>
        `;
TicketDetailTemplates.ERROR_ROW = `
            <div class="info-row-value error-row">
                <p class='error-code-msg'>
                    {{ errorMsg}}
                </p>
                <span class="error-code m-chip">{{ code }}</span>
            </div>
        `;
TicketDetailTemplates.NOTE = `
            <div class="ticket-note">
                <div class="m-help-text">
                    On {{ticketDate}} at {{ticketTime}} {{user}} wrote: 
                </div>
                <div class="m-box">
                    {{note}}
                </div>
            </div>
        `;
TicketDetailTemplates.TICKET_DROPDOWN_LIST_ITEM = `
            <div id="{{ htmlId }}" class="m-menu-item">
                <span class="icon">
                    <img src='data:image/svg+xml;base64,{{ icon }}' alt = "" />
                </span>
                {{ label }}
            </div>
        `;
TicketDetailTemplates.TICKET_DROPDOWN_LIST_ITEM_WO_ICON = `
            <div id="{{ htmlId }}" class="ticket-field-list-item m-menu-item">
               {{ label }}
            </div>
        `;
TicketDetailTemplates.TICKET_DROPDOWN_LIST_ITEM_W_ELEMENT = `
            <div id="{{ htmlId }}" class="m-menu-item">
                <div id='ticketListItemE1{{ index }}' class="m-avatar is-rounded {{ variant }}">
                    <div class="m-avatar-fallback">
                        {{initial}}
                    </div>
                </div>
                {{ label }}
            </div>
        `;
/** TICKET ACTIVITY **/
TicketDetailTemplates.ACTIVITY_CREATE_TICKET = `
            <div class="activity-list-item m-stack is-horizontal is-align-center">
                <span id="activityIcon{{ index }}" class="activity-avatar">
                </span>
                <h6 class="m-heading">{{ initiator }}</h6> 
                <p class="m-text">created the ticket {{ elapsedTime }} ago</p>
            </div>
        `;
TicketDetailTemplates.ACTIVITY_ASSIGN_OWNER = `
            <div class="activity-list-item m-stack is-horizontal is-align-center">
                <span id="activityIcon{{ index }}" class="activity-avatar">
                </span>
                <h6 class="m-heading">{{ initiator }}</h6> 
                <p class="m-text">assigned</p> 
                <h6 class="m-heading">{{ newValue }}</h6>
                <p class="m-text">{{ elapsedTime }} ago</p>
            </div>
        `;
TicketDetailTemplates.ACTIVITY_PROPERTY_UPDATE = `
            <div class="activity-list-item m-stack is-horizontal is-align-center">
                <span id="activityIcon{{ index }}" class="activity-avatar">
                </span>
                <h6 class="m-heading">{{ initiator }}</h6> 
                <p class="m-text">{{ eventText }}</p>

                {{#oldValue}}
                    <p class="m-text">from</p>
                    <h6 class="m-heading">{{ oldValue }}</h6>
                {{/oldValue}}

                <p class="m-text">to</p>
                <h6 class="m-heading">{{ newValue }}</h6>
                
                <p class="m-text">{{ elapsedTime }} ago</p>
            </div>
        `;
TicketDetailTemplates.ACTIVITY_COMMENT = `
            <div class="activity-list-item with-comment m-stack is-horizontal">
                <span id="activityIcon{{ index }}" class="activity-avatar">
                </span>
                 <div class="activity-comment-box">
                    <div class="m-stack is-horizontal is-align-center">
                        <h6 class="m-heading">{{ initiator }}</h6> 
                        <p clas="m-text">{{ elapsedTime }} ago</p>
                    </div>
                    <p class="activity-comment-content">
                        {{ newValue }}
                    </p>
                </div>
            </div>
        `;
TicketDetailTemplates.ACTIVITY_COMMENT_EDITABLE = `
            <div class="activity-list-item with-comment m-stack is-horizontal">
                <span id="activityIcon{{ index }}" class="activity-avatar">
                </span>
                 <div class="activity-comment-box">
                    <div class="activity-comment-box-header">
                        <div class="m-stack is-horizontal">
                            <h6 class="m-heading">{{ initiator }}</h6> 
                            <p class="m-text">{{ elapsedTime }} ago</p>
                        </div>
                        <div class='comment-edit-menu-wrapper'>
                            <i id="commentMenuIcon{{ index }}" class="icon-more-horizontal comment-menu-icon clickable"></i>
                            <div id="commentMenu{{ index }}" class="comment-edit-menu">
                                <div id="commentMenuEdit{{ index }}" class="comment-edit-menu-item m-text is-tertiary">
                                    <i class="icon-pencil comment-menu-item-icon"></i>
                                    <p class="comment-menu-item-label">Edit</p>
                                </div>
                                <div id="commentMenuDelete{{ index }}" class="comment-edit-menu-item m-text is-tertiary">
                                    <i class="icon-trash-2 comment-menu-item-icon"></i>
                                    <p class="comment-menu-item-label">Delete</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div contenteditable="false" id="editComment{{ index }}" class="comment-text-area edit-comment">{{ newValue }}</div>
                    <button id="commentSubmitButton{{ index }}" class="comment-submit-button m-button is-secondary" type="button">Update</button>
                </div>
            </div>
        `;
TicketDetailTemplates.ACTIVITY_RESOLUTION_EDITABLE = `
            <div class="activity-list-item m-stack is-horizontal is-align-center">
                <span id="activityIcon{{ index }}" class="activity-avatar">
                </span>
                <div class="activity-comment-box resolution">
                    <div class="activity-comment-box-header">
                        <div class="activity-list-item">
                            <h6 class="m-heading">{{ initiator }}</h6> 
                            <p class="m-text">closed ticket {{ elapsedTime }} ago<p>
                        </div>
                        <div class='resolution-header-right'>
                            <div class="m-chip is-success resolution-chip">Closed</div>
                            <div class='comment-edit-menu-wrapper'>
                                <i id="commentMenuIcon{{ index }}" class="icon-more-horizontal comment-menu-icon clickable"></i>
                                <div id="commentMenu{{ index }}" class="comment-edit-menu">
                                    <div id="commentMenuEdit{{ index }}" class="comment-edit-menu-item m-text is-tertiary">
                                        <i class="icon-pencil comment-menu-item-icon"></i>
                                        <p class="comment-menu-item-label">Edit</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div contenteditable="false" id="editComment{{ index }}" class="comment-text-area edit-comment">{{ newValue }}</div>
                    <button id="commentSubmitButton{{ index }}" class="comment-submit-button m-button is-secondary" type="button">Update</button>
                </div>
            </div>
        `;
TicketDetailTemplates.ACTIVITY_RESOLUTION = `
            <div class="activity-list-item m-stack is-horizontal is-align-center">
                <span id="activityIcon{{ index }}" class="activity-avatar">
                </span>
                <div class="activity-comment-box resolution">
                    <div class="activity-comment-box-header">
                        <div class="activity-list-item">
                            <h6 class="m-heading">{{ initiator }}</h6> 
                            <p class="m-text">closed ticket {{ elapsedTime }} ago<p>
                        </div>
                        <div class='resolution-header-right'>
                            <div class="m-chip is-success resolution-chip">Closed</div>
                        </div>
                    </div>
                    <div contenteditable="false" id="editComment{{ index }}" class="comment-text-area edit-comment">{{ newValue }}</div>
                    <button id="commentSubmitButton{{ index }}" class="comment-submit-button m-button is-secondary" type="button">Update</button>
                </div>
            </div>
        `;
TicketDetailTemplates.TICKET_ACTIVITY_TEMPLATE_MAP = {
    1: TicketDetailTemplates.ACTIVITY_CREATE_TICKET,
    2: TicketDetailTemplates.ACTIVITY_ASSIGN_OWNER,
    3: TicketDetailTemplates.ACTIVITY_PROPERTY_UPDATE,
    4: TicketDetailTemplates.ACTIVITY_PROPERTY_UPDATE,
    5: TicketDetailTemplates.ACTIVITY_PROPERTY_UPDATE,
    6: TicketDetailTemplates.ACTIVITY_COMMENT,
    7: TicketDetailTemplates.ACTIVITY_PROPERTY_UPDATE,
    8: TicketDetailTemplates.ACTIVITY_RESOLUTION,
    9: TicketDetailTemplates.ACTIVITY_PROPERTY_UPDATE
};
TicketDetailTemplates.TICKET_ACTIVITY_TEXT = {
    1: "",
    2: "",
    3: "changed the priority",
    4: "changed the status",
    5: "changed the category",
    6: "",
    7: "changed miner",
    8: "",
    9: "changed site"
};

// GLOBAL DATA OBJECTS
const ticketsData = {
    "In Progress": {
        status: "In Progress",
        tickets: [],
    },
    "Open": {
        status: "Open",
        tickets: [],
    },
    "Done": {
        status: "Done",
        tickets: [],
    },
    "Canceled": {
        status: "Canceled",
        tickets: [],
    },
    "Duplicate": {
        status: "Duplicate",
        tickets: [],
    },
};
const ticketPriorities = {
    Low: 1,
    Medium: 2,
    High: 3,
    Critical: 4,
};
class Ticketing extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.pageInitialized = false;
        // FILTERS
        this.statusFilter = null;
        this.priorityFilter = null;
        this.assignFilter = null;
        this.siteFilter = null;
        this.labelFilter = null;
        this.zoneFilter = null;
        // MISC
        this.canEdit = false;
        this.selectedTickets = [];
        this.ticketDetailUrl = "/TicketDetails";
        this.isRendering = true;
        this.canEdit = $(`#${window.hfId}`).val() === "true";
        let preselectedMiners = [];
        // if ticket cache is specified in the params, pull data from
        // session storage, create ticket, autofill cached miners, and open createTicket page
        const load_create_ticket = this.getQueryStringValue("ticket_cache");
        const ticket_detail_id = this.getQueryStringValue("ticket_id");
        if (load_create_ticket) {
            preselectedMiners = JSON.parse(window.sessionStorage.getItem("ticket_cache"));
        }
        this.ticketDetailsPanel = new TicketDetailsPanel(this, preselectedMiners, this.canEdit);
        this.ticketDetailsPanel.onTicketUpdated = () => this.refreshTickets();
        this.ticketDetailsPanel.onTicketCreated = () => this.refreshTickets();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.loader = new TicketPropertiesLoader();
        this.toggleBusy(true);
        this.loadAndRenderAll(preselectedMiners).then(() => {
            this.toggleBusy(false);
            if (load_create_ticket) {
                this.ticketDetailsPanel.open();
            }
            else if (ticket_detail_id) {
                this.ticketDetailsPanel.open(parseInt(ticket_detail_id));
            }
            this.pageInitialized = true;
        });
        const w = $(window);
        w.click((e) => {
            const isInDropdown = e.target.closest("#actionButtonDropdown") !== null;
            if (!isInDropdown) {
                $(".actionDropdownMenu")
                    .attr("aria-hidden", "true")
                    .find(".m-menu-item")
                    .removeAttr("aria-current");
            }
        });
        w.on("focus", () => {
            if (this.isRendering)
                return;
            this.refreshTickets();
        });
    }
    loadAndRenderAll(preselectedMiners) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isRendering = true;
            const miners = this.loader
                .loadMiners()
                .then((resp) => {
                this.ticketDetailsPanel.initMiners(resp.miners);
            });
            const users = this.loader
                .loadUsers()
                .then((resp) => {
                this.ticketDetailsPanel.initAssignees(resp.ticketUsers);
                return resp;
            });
            const sites = this.loader
                .loadSites()
                .then((resp) => {
                return resp;
            });
            const tickets = this.loader
                .loadTickets()
                .then((resp) => {
                return resp;
            });
            const categories = this.loader
                .loadCategories()
                .then((resp) => {
                return resp;
            });
            const statuses = this.loader
                .loadStatuses()
                .then((resp) => {
                this.statusesResponse = resp;
                return resp;
            });
            const priorities = this.loader
                .loadPriorities()
                .then((resp) => {
                this.prioritiesResponse = resp;
                return resp;
            });
            yield Promise.all([users, sites, tickets, categories, statuses, priorities, miners])
                .then(([usersRes, sitesRes, ticketsRes, categoriesRes]) => {
                this.ticketUsersResponse = usersRes;
                this.sitesResponse = sitesRes;
                this.ticketsResponse = ticketsRes;
                this.categoriesResponse = categoriesRes;
                this.populateFilters();
                this.populateSubMenus();
                this.renderTickets();
                this.ticketDetailsPanel.initSites(sitesRes.sites);
                this.isRendering = false;
            });
        });
    }
    refreshTickets() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isRendering = true;
            const users = this.loader
                .loadUsers()
                .then((resp) => {
                this.ticketDetailsPanel.initAssignees(resp.ticketUsers);
                return resp;
            });
            const sites = this.loader
                .loadSites()
                .then((resp) => {
                return resp;
            });
            const tickets = this.loader
                .loadTickets()
                .then((resp) => {
                return resp;
            });
            const [usersRes, sitesRes, ticketsRes] = yield Promise.all([users, sites, tickets]);
            this.ticketUsersResponse = usersRes;
            this.sitesResponse = sitesRes;
            this.ticketsResponse = ticketsRes;
            this.populateFilters();
            this.populateSubMenus();
            this.renderTickets();
            this.ticketDetailsPanel.initSites(sitesRes.sites);
            this.isRendering = false;
        });
    }
    populateFilters() {
        const filtersAreInitialized = this.statusFilter !== null && typeof this.statusFilterValue !== "undefined";
        if (filtersAreInitialized) {
            // skip initialization if already initialized
            return;
        }
        const zones = uniq(this.ticketsResponse.tickets, (a, b) => a.zoneName === b.zoneName).map((t) => ({ value: t.zoneName }));
        const urlParams = new URLParams();
        function formatId(id) {
            return id.replace(/[^a-zA-Z]/g, '');
        }
        const statusOptions = Object.keys(ticketsData).map((status) => {
            return {
                id: formatId(status),
                label: status,
            };
        });
        const priorityOptions = Object.keys(ticketPriorities).map((priority) => {
            return {
                id: formatId(priority),
                label: priority,
            };
        });
        const assignOptions = this.ticketUsersResponse.ticketUsers.map((user) => {
            return {
                id: formatId(user.email),
                label: user.email,
            };
        });
        const siteOptions = this.sitesResponse.sites.map((site) => {
            return {
                id: formatId(site.siteName),
                label: site.siteName,
            };
        });
        const labelOptions = this.categoriesResponse.categories.map((category) => {
            return {
                id: formatId(category.category),
                label: category.category,
            };
        });
        if (!urlParams.has("statuses")) {
            urlParams.set("statuses", this.statusesResponse.ticketStatuses.map((s) => s.statusId).join(","));
        }
        if (!urlParams.has("priorities")) {
            urlParams.set("priorities", this.prioritiesResponse.ticketPriorities.map((p) => p.priorityId).join(","));
        }
        //if (!urlParams.has("assignees")) {
        //    urlParams.set("assignees", this.ticketUsersResponse.ticketUsers.map((u) => u.userId).join(","));
        //}
        if (!urlParams.has("labels")) {
            urlParams.set("labels", this.categoriesResponse.categories.map((c) => c.categoryId).join(","));
        }
        if (!urlParams.has("sites")) {
            urlParams.set("sites", this.sitesResponse.sites.map((s) => s.siteId).join(","));
        }
        if (!urlParams.has("zone")) {
            urlParams.set("zone", "All");
        }
        function formatUrlParamValue(paramKey) {
            return urlParams
                .get(paramKey)
                .split(",")
                // filter used to prevent empty strings in the array
                .filter(v => v);
        }
        const activeStatuses = where(formatUrlParamValue("statuses"), this.statusesResponse.ticketStatuses, (a, b) => Number(a) === b.statusId);
        const activePriorities = where(formatUrlParamValue("priorities"), this.prioritiesResponse.ticketPriorities, (a, b) => Number(a) === b.priorityId);
        const activeAssignees = this.ticketUsersResponse.ticketUsers;
        const activeLabels = where(formatUrlParamValue("labels"), this.categoriesResponse.categories, (a, b) => Number(a) === b.categoryId);
        let activeSites = where(formatUrlParamValue("sites"), this.sitesResponse.sites, (a, b) => Number(a) === b.siteId);
        if (activeSites.includes(undefined)) {
            activeSites = this.sitesResponse.sites;
        }
        this.statusFilterValue = activeStatuses.map((s) => s.statusName);
        this.priorityFilterValue = activePriorities.map((p) => p.priority);
        this.assignFilterValue = activeAssignees.map((a) => a.email);
        this.siteFilterValue = activeSites.map((s) => s.siteName);
        this.labelFilterValue = activeLabels.map((l) => l.category);
        this.zoneFilterValue = formatUrlParamValue("zone")[0];
        this.statusFilter = new FilterCheckbox({
            id: "statusFilter",
            onApply: (val) => {
                const statuses = where(val, this.statusesResponse.ticketStatuses, (a, b) => a.label === b.statusName);
                this.statusFilterValue = statuses.map((s) => s.statusName);
                urlParams.set("statuses", statuses.map((s) => s.statusId).join(","));
                this.renderTickets();
            },
            options: statusOptions,
            defaultValue: activeStatuses.map((s) => ({ id: formatId(s.statusName), checked: true, })),
        });
        this.priorityFilter = new FilterCheckbox({
            id: "priorityFilter",
            onApply: (val) => {
                const priorities = where(val, this.prioritiesResponse.ticketPriorities, (a, b) => a.label === b.priority);
                this.priorityFilterValue = priorities.map((v) => v.priority);
                urlParams.set("priorities", priorities.map((p) => p.priorityId).join(","));
                this.renderTickets();
            },
            options: priorityOptions,
            defaultValue: activePriorities.map((p) => ({ id: formatId(p.priority), checked: true, }))
        });
        this.assignFilter = new FilterCheckbox({
            id: "assignFilter",
            onApply: (val) => {
                this.assignFilterValue = val.map((v) => v.label);
                //urlParams.set("assignees", assignees.map((a) => a.userId).join(","));
                this.renderTickets();
            },
            options: assignOptions,
            defaultValue: activeAssignees.map((a) => ({ id: formatId(a.email), checked: true, })),
        });
        this.siteFilter = new FilterCheckbox({
            id: "siteFilter",
            onApply: (val) => {
                const sites = where(val, this.sitesResponse.sites, (a, b) => a.label === b.siteName);
                this.siteFilterValue = sites.map((v) => v.siteName);
                urlParams.set("sites", sites.map((s) => s.siteId).join(","));
                this.renderTickets();
            },
            options: siteOptions,
            defaultValue: activeSites.map((a) => ({ id: formatId(a.siteName), checked: true, })),
        });
        this.labelFilter = new FilterCheckbox({
            id: "labelFilter",
            onApply: (val) => {
                const labels = where(val, this.categoriesResponse.categories, (a, b) => a.label === b.category);
                this.labelFilterValue = labels.map((v) => v.category);
                urlParams.set("labels", labels.map((v) => v.categoryId).join(","));
                this.renderTickets();
            },
            options: labelOptions,
            defaultValue: activeLabels.map((l) => ({ id: formatId(l.category), checked: true, })),
        });
        this.zoneFilter = new OpDropDown(document.getElementById("zoneFilter"));
        const ds = [{ value: "All" }].concat(zones);
        this.zoneFilter.setDataSource(ds, "value", "value");
        $("#zoneFilter").data("kendoDropDownList").value(urlParams.get("zone"));
        this.zoneFilter.onSelectionChanged = (e) => {
            const val = e.value();
            this.zoneFilterValue = val;
            urlParams.set("zone", val);
            this.renderTickets();
        };
    }
    populateSubMenus() {
        $("#statusSubMenu").remove();
        $("#prioritySubMenu").remove();
        $("#assignSubMenu").remove();
        $("#siteSubMenu").remove();
        $("#labelSubMenu").remove();
        const subMenuTemplate = document.getElementById("subMenuTemplate").innerHTML;
        const mustache = window.Mustache;
        const subMenuStatus = mustache.to_html(subMenuTemplate, {
            id: "statusSubMenu",
            options: [
                {
                    icon: document.querySelector("[icon-template=iconOpen]").innerHTML,
                    label: "Open",
                    onSelect: "t.bulkActionStatus('Open');",
                },
                {
                    icon: document.querySelector("[icon-template=iconInProgress]").innerHTML,
                    label: "In Progress",
                    action: "status-open",
                    onSelect: "t.bulkActionStatus('In Progress');",
                },
                {
                    icon: document.querySelector("[icon-template=iconDone]").innerHTML,
                    label: "Done",
                    onSelect: "t.bulkActionStatus('Done');",
                },
                {
                    icon: document.querySelector("[icon-template=iconCanceled]").innerHTML,
                    label: "Canceled",
                    onSelect: "t.bulkActionStatus('Canceled');",
                },
                {
                    icon: document.querySelector("[icon-template=iconDuplicate]").innerHTML,
                    label: "Duplicate",
                    onSelect: "t.bulkActionStatus('Duplicate');",
                },
            ]
        });
        const subMenuPriority = mustache.to_html(subMenuTemplate, {
            id: "prioritySubMenu",
            options: [
                {
                    icon: document.querySelector("[icon-template=iconPriorityLow]").innerHTML,
                    label: "Low",
                    onSelect: "t.bulkActionPriority('Low');",
                },
                {
                    icon: document.querySelector("[icon-template=iconPriorityMedium]").innerHTML,
                    label: "Medium",
                    onSelect: "t.bulkActionPriority('Medium');",
                },
                {
                    icon: document.querySelector("[icon-template=iconPriorityHigh]").innerHTML,
                    label: "High",
                    onSelect: "t.bulkActionPriority('High');",
                },
                {
                    icon: document.querySelector("[icon-template=iconPriorityCritical]").innerHTML,
                    label: "Critical",
                    onSelect: "t.bulkActionPriority('Critical');",
                },
            ]
        });
        const subMenuAssign = mustache.to_html(subMenuTemplate, {
            id: "assignSubMenu",
            options: this.ticketUsersResponse.ticketUsers.map((user) => {
                return {
                    icon: Avatar.gen(user.userId, "", "activity-icon"),
                    label: user.email,
                    onSelect: `t.bulkActionAssign("${user.email}", ${user.userId});`
                };
            }),
        });
        const subMenuSite = mustache.to_html(subMenuTemplate, {
            id: "siteSubMenu",
            options: this.sitesResponse.sites.map((site) => {
                return {
                    icon: "",
                    label: site.siteName,
                    onSelect: `t.bulkActionSite("${site.siteName}", ${site.siteId})`,
                };
            }),
        });
        const subMenuLabel = mustache.to_html(subMenuTemplate, {
            id: "labelSubMenu",
            options: this.categoriesResponse.categories.map((category) => {
                return {
                    icon: document.querySelector("[icon-template=iconLayoutGrid]").innerHTML,
                    label: category.category,
                    onSelect: `t.bulkActionLabel("${category.category}");`
                };
            }),
        });
        $("#actionDropdownMenu")
            .append(subMenuStatus)
            .append(subMenuPriority)
            .append(subMenuAssign)
            .append(subMenuSite)
            .append(subMenuLabel);
    }
    renderTickets() {
        ticketsData["In Progress"].tickets = [];
        ticketsData["Open"].tickets = [];
        ticketsData["Done"].tickets = [];
        ticketsData["Canceled"].tickets = [];
        ticketsData["Duplicate"].tickets = [];
        for (const ticket of this.ticketsResponse.tickets) {
            if (!this.statusFilterValue.includes(ticket.status)) {
                continue;
            }
            if (!this.priorityFilterValue.includes(ticket.priority)) {
                continue;
            }
            if (!this.assignFilterValue.includes(ticket.owner) && ticket.owner !== "Unassigned") {
                continue;
            }
            if (!this.siteFilterValue.includes(ticket.site)) {
                continue;
            }
            if (!this.labelFilterValue.includes(ticket.category)) {
                continue;
            }
            if (this.zoneFilterValue !== "All" && this.zoneFilterValue !== ticket.zoneName) {
                continue;
            }
            // ONLY SHOW 100 DONE TICKETS IN THE UI
            if (ticket.status === "Done" && ticketsData["Done"].tickets.length >= 100) {
                continue;
            }
            const user = this.ticketUsersResponse.ticketUsers.find((user) => user.email === ticket.owner);
            const isSelected = Boolean(this.selectedTickets.find((t) => t.id === ticket.id));
            const ticketTemplateData = Object.assign(Object.assign({}, ticket), { dateCreatedFormatted: window.moment(ticket.created).format("MMM DD"), avatar: `<m-avatar 
                    email="${ticket.owner === "Unassigned" ? "" : ticket.owner}"
                    user-id="${user === null || user === void 0 ? void 0 : user.userId}"
                    rounded
                    ></m-avatar>`, iconStatus: document.querySelector(`[icon-template=icon${ticket.status.replace(/\s/g, "")}]`).innerHTML, iconPriority: document.querySelector(`[icon-template=iconPriority${ticket.priority}]`).innerHTML, checked: isSelected ? `checked="true"` : "", selectedClass: isSelected ? "selected" : "" });
            ticketsData[ticket.status].tickets.push(ticketTemplateData);
        }
        //populate ticketCounts
        for (const ticketSection of Object.values(ticketsData)) {
            const count = derive(() => {
                const length = ticketSection.tickets.length;
                if (ticketSection.status === "Done" && length === 100) {
                    return `${length}+`;
                }
                return length.toString();
            });
            $(`#ticketCount${noWhitespace(ticketSection.status)}`).text(count);
        }
        const ticketListTemplate = document.getElementById("ticketListTemplate").innerHTML;
        const mustache = window.Mustache;
        const ticketElemsInProgress = mustache.to_html(ticketListTemplate, ticketsData["In Progress"]);
        const ticketElemsOpen = mustache.to_html(ticketListTemplate, ticketsData["Open"]);
        const ticketElemsDone = mustache.to_html(ticketListTemplate, ticketsData["Done"]);
        const ticketElemsCanceled = mustache.to_html(ticketListTemplate, ticketsData["Canceled"]);
        const ticketElemsDuplicate = mustache.to_html(ticketListTemplate, ticketsData["Duplicate"]);
        $("#tSectionInProgress")
            .empty()
            .append(ticketElemsInProgress);
        $("#tSectionOpen")
            .empty()
            .append(ticketElemsOpen);
        $("#tSectionDone")
            .empty()
            .append(ticketElemsDone);
        $("#tSectionCanceled")
            .empty()
            .append(ticketElemsCanceled);
        $("#tSectionDuplicate")
            .empty()
            .append(ticketElemsDuplicate);
    }
    handleCompanyFilterChanged() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pageInitialized) {
                window.location.href = window.location.href.split("?")[0];
                window.location.reload();
            }
        });
    }
    hideSubMenus() {
        $("#statusSubMenu").attr("aria-hidden", "true");
        $("#prioritySubMenu").attr("aria-hidden", "true");
        $("#assignSubMenu").attr("aria-hidden", "true");
        $("#siteSubMenu").attr("aria-hidden", "true");
        $("#labelSubMenu").attr("aria-hidden", "true");
    }
    deselectAllTickets() {
        $("[elem=ticket-checkbox]").prop("checked", false);
        $(".ticket").removeClass("selected");
        this.selectedTickets = [];
    }
    updateTicket(data) {
        this.toggleBusy(true);
        const tickets = this.selectedTickets.map((t) => {
            return {
                ticketId: t.id,
                priorityId: data.priorityId || t.priorityId,
                owner: data.owner || t.owner,
                siteId: data.siteId || t.siteId,
                statusId: data.statusId || t.statusId,
                categoryId: data.categoryId || t.categoryId,
                name: data.name || t.name,
                description: data.description || t.description,
            };
        });
        const req = {
            tickets,
        };
        return this.patch(this.ticketDetailUrl, req)
            .then((resp) => {
            this.toggleBusy(false);
            if (!resp.success) {
                this.showErrorMessage("Failed to update tickets");
                return "Error";
            }
            this.refreshTickets();
        });
    }
    /* PUBLIC METHODS SECTION */
    createTicket() {
        if (!this.canEdit)
            return;
        this.ticketDetailsPanel.open();
    }
    openTicketDetails(id) {
        const tabToOpen = new URL(window.location.href);
        const tabToOpenParams = tabToOpen.searchParams;
        tabToOpenParams.has("ticket_id")
            ? tabToOpenParams.set("ticket_id", id.toString())
            : tabToOpenParams.append("ticket_id", id.toString());
        if (tabToOpenParams.has("ticket_cache")) {
            tabToOpenParams.delete("ticket_cache");
        }
        window.open(tabToOpen.href);
    }
    toggleTSection(status) {
        const ticketStatus = noWhitespace(status);
        $(`#tSection${ticketStatus}`).children().toggleClass("hide");
        $(`#chevronIcon${ticketStatus}`).toggleClass("closed");
    }
    toggleSubMenu(e, subMenu) {
        const optionElem = $(e.target.closest(".m-menu-item"));
        this.hideSubMenus();
        this.toggleDropdownMenu(`${subMenu.toLowerCase()}SubMenu`);
        $(".m-menu-item").removeAttr("aria-current");
        optionElem.attr("aria-current", "true");
    }
    exportToExcel() {
        // Tickets need to be derived from ticketsResponse in order to include all tickets, including thousands of "Done" tickets
        const includedTickets = this.ticketsResponse.tickets.filter((ticket) => {
            if (!this.statusFilterValue.includes(ticket.status)) {
                return false;
            }
            if (!this.priorityFilterValue.includes(ticket.priority)) {
                return false;
            }
            if (!this.assignFilterValue.includes(ticket.owner) && ticket.owner !== "Unassigned") {
                return false;
            }
            if (!this.siteFilterValue.includes(ticket.site)) {
                return false;
            }
            if (!this.labelFilterValue.includes(ticket.category)) {
                return false;
            }
            return true;
        });
        const headerFields = ["id", "name", "minerName", "minerModel", "minerAccount", "site", "status", "priority", "category", "owner", "created"];
        const headerTitles = ["ID", "Name", "Miner Name", "Miner Model", "Subaccount", "Site", "Status", "Priority", "Category", "Owner", "Created"];
        const rowsElems = includedTickets.map((ticket) => {
            const tr = document.createElement("tr");
            for (const headerField of headerFields) {
                const td = document.createElement("td");
                td.innerText = ticket[headerField];
                tr.append(td);
            }
            return tr;
        });
        const headerElems = headerTitles.map((headerTitle) => {
            const th = document.createElement("th");
            th.innerText = headerTitle;
            return th;
        });
        ExcelUtility.exportToExcel(headerElems, rowsElems);
    }
    handleCheckboxClick(e) {
        const elem = e.target.closest(".ticket");
        $(elem).toggleClass("selected");
        const ticketId = elem.getAttribute("ticket-id");
        const tickets = flat(Object.values(ticketsData).map((x) => x.tickets));
        const thisTicket = tickets.find((t) => t.id === parseInt(ticketId));
        this.selectedTickets.push(thisTicket);
    }
    bulkActionStatus(status) {
        this.confirm("Bulk update ticket status", `Are you sure you want to move ${this.selectedTickets.length} tickets to ${status.toUpperCase()}?`, () => __awaiter(this, void 0, void 0, function* () {
            const statusId = this.statusesResponse.ticketStatuses.find((s) => s.statusName === status).statusId;
            const resp = yield this.updateTicket({ statusId, }).catch(() => this.deselectAllTickets());
            if (resp !== "Error") {
                this.deselectAllTickets();
                this.toggleBusy(true);
                yield this.refreshTickets();
                this.toggleBusy(false);
            }
        }));
    }
    bulkActionPriority(priority) {
        this.confirm("Bulk update ticket priority", `Are you sure you want to move ${this.selectedTickets.length} tickets to ${priority.toUpperCase()} priority?`, () => __awaiter(this, void 0, void 0, function* () {
            const priorityId = this.prioritiesResponse.ticketPriorities.find((s) => s.priority === priority).priorityId;
            const resp = yield this.updateTicket({ priorityId, }).catch(() => this.deselectAllTickets());
            if (resp !== "Error") {
                this.deselectAllTickets();
                this.toggleBusy(true);
                yield this.refreshTickets();
                this.toggleBusy(false);
            }
        }));
    }
    bulkActionAssign(email, userId) {
        this.confirm("Bulk update ticket assignee", `Are you sure you want to assign ${this.selectedTickets.length} tickets to ${email}?`, () => __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.updateTicket({ owner: email, }).catch(() => this.deselectAllTickets());
            if (resp !== "Error") {
                this.deselectAllTickets();
                this.toggleBusy(true);
                yield this.refreshTickets();
                this.toggleBusy(false);
            }
        }));
    }
    bulkActionSite(siteName, siteId) {
        this.confirm("Bulk update ticket site", `Are you sure you want to move ${this.selectedTickets.length} tickets to site ${siteName}?`, () => __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.updateTicket({ siteId: siteId, }).catch(() => this.deselectAllTickets());
            if (resp !== "Error") {
                this.deselectAllTickets();
                this.toggleBusy(true);
                yield this.refreshTickets();
                this.toggleBusy(false);
            }
        }));
    }
    bulkActionLabel(category) {
        this.confirm("Bulk update ticket label", `Are you sure you want to label ${this.selectedTickets.length} tickets as ${category}?`, () => __awaiter(this, void 0, void 0, function* () {
            const categoryId = this.categoriesResponse.categories.find((c) => c.category === category).categoryId;
            const resp = yield this.updateTicket({ categoryId, }).catch(() => this.deselectAllTickets());
            if (resp !== "Error") {
                this.deselectAllTickets();
                this.toggleBusy(true);
                yield this.refreshTickets();
                this.toggleBusy(false);
            }
        }));
    }
    bulkActionDelete() {
        this.confirm("Bulk update ticket label", `Are you sure you want to DELETE ${this.selectedTickets.length} tickets?`, () => __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.delete("/Ticketing", { tickets: this.selectedTickets }).catch(() => this.deselectAllTickets());
            if (resp && resp.success) {
                this.deselectAllTickets();
                this.toggleBusy(true);
                yield this.refreshTickets();
                this.toggleBusy(false);
            }
            else {
                this.showErrorMessage(`Failed to delete ${this.selectedTickets.length} tickets.`);
            }
        }));
    }
}
// LOCAL UTILITIES
function where(array1, array2, comparer) {
    return array1.map((a) => {
        return array2.find((b) => comparer(a, b));
    });
}
function uniq(array, comparer) {
    const uniqArr = [];
    for (let i = 0; i < array.length; i++) {
        const item = array[i];
        let exists = false;
        for (let j = 0; j < uniqArr.length; j++) {
            if (comparer(uniqArr[j], item)) {
                exists = true;
            }
        }
        if (!exists) {
            uniqArr.push(item);
        }
    }
    return uniqArr;
}
function noWhitespace(str) {
    return str.replace(" ", "");
}
function flat(arr) {
    let newArr = [];
    for (let i = 0; i < arr.length; i++) {
        const item = arr[i];
        if (Array.isArray(item)) {
            newArr = newArr.concat(flat(item));
            continue;
        }
        newArr.push(item);
    }
    return newArr;
}
class URLParams {
    constructor() {
        const u = new URL(window.location.href);
        this.params = u.searchParams;
    }
    set(key, value) {
        if (this.params.has(key)) {
            this.params.set(key, value);
        }
        else {
            this.params.append(key, value);
        }
        const updatedSearchString = this.params.toString();
        const updatedURL = window.location.origin + window.location.pathname + '?' + updatedSearchString;
        window.history.pushState({}, '', updatedURL);
    }
    get(key) {
        return this.params.get(key);
    }
    has(key) {
        return this.params.has(key);
    }
}

class TicketPropertiesLoader extends OptiFleetService {
    constructor() {
        super();
        this.categoriesUrl = "/TicketCategories";
        this.prioritiesUrl = "/TicketPriority";
        this.minersUrl = "/TicketMiners";
        this.statusUrl = "/TicketStatus";
        this.sitesUrl = "/Sites";
        this.usersUrl = "/TicketUsers";
        this.ticketsUrl = "/Ticketing";
    }
    loadCategories() {
        return this.get(this.categoriesUrl);
    }
    loadPriorities() {
        return this.get(this.prioritiesUrl);
    }
    loadMiners() {
        return this.get(this.minersUrl);
    }
    loadStatuses() {
        return this.get(this.statusUrl);
    }
    loadSites() {
        return this.get(this.sitesUrl);
    }
    loadUsers() {
        return this.get(this.usersUrl);
    }
    loadTickets() {
        return this.get(this.ticketsUrl);
    }
}

class EditUser extends OptiFleetService {
    constructor(userLevel) {
        super();
        this.userLevel = userLevel;
        this.companiesUrl = "/UsersCompanies";
        this.teamsUrl = "/UsersTeams";
        this.userUpdateUrl = "/UpdateUser";
        this.deleteUpdateUrl = "/DeleteUser";
        this.dropdownEl = new OpDropDown(document.getElementById("ddlTeams"), "Select Team");
    }
    open(user) {
        this.user = user;
        if (this.userLevel < this.user.accessLevel) {
            $(".no-edit").addClass("active");
            $(".edit-user").removeClass("active");
            $(".edit-user-wrapper").addClass("slide-up");
            $(".delete-user").removeClass("active");
            return;
        }
        $(".no-edit").removeClass("active");
        $(".edit-user").addClass("active");
        $(".delete-user").addClass("active");
        this.resetPanel();
        this.loadCompanies();
        this.loadTeams();
    }
    close() {
        $(".edit-user-wrapper").removeClass("slide-up");
    }
    resetPanel() {
        this.cancelDelete();
        $("#editingUser").text(this.user.username);
        this.setPermission();
        this.initGrid();
        this.toggleCompanyList();
        const databoundGrid = $("#companyEditList").data("kendoGrid");
        if (databoundGrid) {
            try {
                databoundGrid.clearSelection();
            }
            catch (_a) {
                //eat
            }
        }
        $(".edit-user-wrapper").addClass("slide-up");
    }
    setPermission() {
        if (this.user.accessLevel == 3) {
            $("#rbMmsAdminEdit").prop("checked", true);
            return;
        }
        if (this.user.accessLevel == 2) {
            $("#rbFacilityAdminEdit").prop("checked", true);
            return;
        }
        if (this.user.accessLevel == 1) {
            $("#rbFacilityTechEdit").prop("checked", true);
            return;
        }
        $("#rbViewerEdit").prop("checked", true);
    }
    getRole() {
        const customer = $("#rbCustomerEdit").prop("checked");
        const viewer = $("#rbViewerEdit").prop("checked");
        const rbFacilityTech = $("#rbFacilityTechEdit").prop("checked");
        const rbFacilityAdmin = $("#rbFacilityAdminEdit").prop("checked");
        const rbMmsAdmin = $("#rbMmsAdminEdit").prop("checked");
        if (customer) {
            return -1;
        }
        if (viewer) {
            return 0;
        }
        if (rbFacilityTech) {
            return 1;
        }
        if (rbFacilityAdmin) {
            return 2;
        }
        if (rbMmsAdmin) {
            return 3;
        }
        return 0;
    }
    initGrid() {
        const grid = $("#companyEditList").get(0);
        const databoundGrid = $("#companyEditList").data("kendoGrid");
        if (!grid || databoundGrid) {
            return;
        }
        $("#companyEditList").kendoGrid({
            dataSource: {
                data: [],
                schema: {
                    model: {
                        id: "id"
                    }
                }
            },
            pageable: false,
            height: "350px",
            persistSelection: true,
            filterable: true,
            sortable: true,
            change: this.onchange.bind(this),
            columns: [
                { template: "<input type='checkbox' class='k-checkbox' id='#=(typeof(id) !== 'undefined' ? id : 1 )#' #= (typeof(hasCompany) !== 'undefined' && hasCompany) ? 'checked' : '' # /><label for='#=(typeof(companyId) !== 'undefined' ? companyId : 1 )#' class='k-checkbox-label k-no-text'></label>", width: "55px" },
                { field: "name", title: "Name" }
            ]
        });
    }
    onchange(e) {
        let selectedIds = [];
        var rows = e.sender.select();
        rows.each((row) => {
            const grid = $("#companyEditList").data("kendoGrid");
            const dataItem = grid.dataItem(rows[row]);
            selectedIds.push(dataItem.get("id"));
        });
    }
    loadTeams() {
        this.get(this.teamsUrl)
            .then((teamsResp) => {
            let teams = [];
            teamsResp.teams.forEach(t => {
                teams.push({ teamId: String(t.teamId), teamName: t.teamName });
            });
            this.dropdownEl.setDataSource(teams, "teamName", "teamId");
            this.dropdownEl.setDefaultValue(this.user.teamId);
        });
    }
    getSelectedTeam() {
        return this.dropdownEl.getSelectedValue() || null;
    }
    loadCompanies() {
        if (!$("#companyEditList").get(0)) {
            return;
        }
        this.toggleEditBusy(true);
        this.get(this.companiesUrl + `?EditUserId=${this.user.id}`)
            .then((resp) => {
            this.bindCompaniesGrid(resp.companies);
        });
    }
    bindCompaniesGrid(companies) {
        const grid = $("#companyEditList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: companies,
            schema: {
                model: {
                    id: "id"
                }
            }
        });
        grid.setDataSource(dataSource);
        this.toggleEditBusy(false);
    }
    toggleEditBusy(isBusy) {
        if (!isBusy) {
            $(".edit-busy").removeClass("active");
            return;
        }
        $(".edit-busy").addClass("active");
    }
    toggleCompanyList() {
        $(".company-assignment-edit").removeClass("hide");
        $(".company-admin-edit").removeClass("hide");
        $(".permission-admin-edit").addClass("hide");
    }
    confirmDelete() {
        $(".delete-user-confirm").removeClass("hide");
        $(".delete-user-text").addClass("hide");
    }
    cancelDelete() {
        $(".delete-user-confirm").addClass("hide");
        $(".delete-user-text").removeClass("hide");
    }
    saveUser() {
        $(".something-went-wrong").addClass("hide");
        $(".select-company-error").addClass("hide");
        const companies = this.getSelectedCompanies();
        if (!this.hasCompanySelected(companies)) {
            $(".select-company-error").removeClass("hide");
            return;
        }
        this.updateUser();
    }
    hasCompanySelected(companies) {
        return companies.filter((comp) => {
            return comp.hasAccess === true;
        }).length > 0;
    }
    updateUser() {
        this.toggleEditBusy(true);
        const data = {
            id: this.user.id,
            role: this.getRole(),
            companies: this.getSelectedCompanies(),
            teamId: this.getSelectedTeam()
        };
        this.post(this.userUpdateUrl, data)
            .then((resp) => {
            this.toggleEditBusy(false);
            if (!resp.success) {
                this.handleError();
                return;
            }
            this.onUserEdited();
            this.close();
        });
    }
    deleteUser() {
        this.toggleEditBusy(true);
        this.post(this.deleteUpdateUrl, { id: this.user.id })
            .then((resp) => {
            this.toggleEditBusy(false);
            if (!resp.success) {
                this.handleError();
                return;
            }
            this.onUserEdited();
            this.close();
        });
    }
    handleError() {
        $(".something-went-wrong").removeClass("hide");
    }
    getSelectedCompanies() {
        let companies = [];
        const grid = $("#companyEditList").data("kendoGrid");
        if (!grid) {
            return [-1];
        }
        const items = grid.items();
        items.each((e, tr) => {
            const dataItem = grid.dataItem(tr);
            const isChecked = $(tr).find("input").prop("checked");
            companies.push({
                id: dataItem.get("companyId"),
                hasAccess: isChecked
            });
        });
        return companies;
    }
}

class UserInvite extends OptiFleetService {
    constructor() {
        super();
        this.companiesUrl = "/Companies";
        this.inviteUrl = "/InviteUser";
        this.selectedCompanyIds = [];
    }
    open() {
        this.resetPanel();
        this.initGrid();
        this.loadCompanies();
    }
    resetPanel() {
        $("#txtEmail").val("");
        $("#rbViewer").prop("checked", true);
        $(".invalid-email").addClass("hide");
        $("#inviteButton").attr("disabled", "disabled");
        $(".invite-user-wrapper").addClass("slide-up");
        const databoundGrid = $("#companyList").data("kendoGrid");
        if (databoundGrid) {
            databoundGrid.clearSelection();
        }
    }
    initGrid() {
        const grid = $("#companyList").get(0);
        const databoundGrid = $("#companyList").data("kendoGrid");
        if (!grid || databoundGrid) {
            return;
        }
        $("#companyList").kendoGrid({
            dataSource: {
                data: [""],
                pageSize: 20,
                schema: {
                    model: {
                        id: "id"
                    }
                }
            },
            pageable: {
                numeric: false,
                previousNext: false,
            },
            scrollable: {
                virtual: true
            },
            persistSelection: true,
            filterable: true,
            sortable: true,
            change: this.onchange.bind(this),
            columns: [
                { selectable: true, width: "50px" },
                { field: "name", title: "Name", filterable: { extra: false, search: true } }
            ]
        });
    }
    onchange(e) {
        let selectedIds = [];
        var rows = e.sender.select();
        rows.each((row) => {
            const grid = $("#companyList").data("kendoGrid");
            const dataItem = grid.dataItem(rows[row]);
            selectedIds.push(dataItem.get("id"));
        });
        this.selectedCompanyIds = selectedIds;
        this.toggleInviteButton();
    }
    loadCompanies() {
        if (!$("#companyList").get(0)) {
            return;
        }
        this.toggleBusy(true);
        this.get(`${this.companiesUrl}?filterActive=true`)
            .then((resp) => {
            this.bindCompaniesGrid(resp.companies);
        });
    }
    bindCompaniesGrid(companies) {
        const grid = $("#companyList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: companies,
            pageSize: 20,
            schema: {
                model: {
                    id: "id"
                }
            }
        });
        grid.setDataSource(dataSource);
        this.toggleBusy(false);
    }
    sendUserInvite() {
        $(".invalid-email").addClass("hide");
        $(".user-exists").addClass("hide");
        $(".something-went-wrong").addClass("hide");
        const email = $("#txtEmail").val();
        const emailRegex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/;
        if (!emailRegex.test(email)) {
            $(".invalid-email").removeClass("hide");
            return;
        }
        this.toggleBusy(true);
        const role = this.getRole();
        const inviteData = {
            email: email,
            companyIds: this.selectedCompanyIds,
            accessLevel: role
        };
        this.post(this.inviteUrl, inviteData)
            .then((resp) => {
            this.toggleBusy(false);
            if (!resp.success) {
                this.handleInviteFailure(resp);
                return;
            }
            this.showSuccess();
            this.resetPanel();
        });
    }
    getRole() {
        const customer = $("#rbCustomer").prop("checked");
        const viewer = $("#rbViewer").prop("checked");
        const rbFacilityTech = $("#rbFacilityTech").prop("checked");
        const rbFacilityAdmin = $("#rbFacilityAdmin").prop("checked");
        const rbMmsAdmin = $("#rbMmsAdmin").prop("checked");
        if (customer) {
            return -1;
        }
        if (viewer) {
            return 0;
        }
        if (rbFacilityTech) {
            return 1;
        }
        if (rbFacilityAdmin) {
            return 2;
        }
        if (rbMmsAdmin) {
            return 3;
        }
        return 0;
    }
    handleInviteFailure(resp) {
        if (resp.userExists) {
            $(".user-exists").removeClass("hide");
            return;
        }
        $(".something-went-wrong").removeClass("hide");
    }
    showSuccess() {
        const email = $("#txtEmail").val();
        $("#invitedUser").text(email);
        $(".invite-success").removeClass("hide");
        setTimeout(() => {
            $(".invite-success").addClass("hide");
        }, 3500);
    }
    toggleCompanyList() {
        this.toggleInviteButton();
        const adminSwitchToggled = $("#isSuperAdminSwitch").prop("checked");
        if (!adminSwitchToggled) {
            $(".company-assignment").removeClass("hide");
            $(".company-admin").removeClass("hide");
            return;
        }
        $(".company-assignment").addClass("hide");
        $(".company-admin").addClass("hide");
    }
    toggleInviteButton() {
        const email = $("#txtEmail").val();
        const isSuperAdmin = $("#isSuperAdminSwitch").prop("checked");
        let selectedIds = this.selectedCompanyIds;
        const grid = $("#companyList").get(0);
        if (!grid || isSuperAdmin) {
            selectedIds = [-1];
        }
        if (email.length === 0 || selectedIds.length === 0) {
            $("#inviteButton").attr("disabled", "disabled");
            return;
        }
        $("#inviteButton").removeAttr("disabled");
    }
}

class UsersView extends OptiFleetPage {
    constructor() {
        super();
        this.usersUrl = "/Users";
        this.canEdit = $(`#${window.hfId}`).val() === "Yes";
        this.userLevel = $(`#${window.hfAId}`).val();
        this.editUser = new EditUser(this.userLevel);
        this.initGrid();
        this.loadUsers();
        this.editUser.onUserEdited = this.loadUsers.bind(this);
    }
    loadUsers() {
        this.toggleBusy(true);
        this.get(this.usersUrl)
            .then((users) => {
            this.populateMinersGrid(users.users);
        });
    }
    initGrid() {
        this.toggleBusy(true);
        $("#usersList").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20
            },
            pageable: true,
            scrollable: true,
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            columns: this.getColumns(),
            noRecords: {
                template: "<div class=\"no-records\">There aren't any other users yet. Use the invite user link above to add another user.</div>"
            }
        });
    }
    getColumns() {
        if (!this.canEdit) {
            return [
                { field: "username", title: "Username", width: "250px", filterable: { extra: false, search: true } },
                { field: "role", width: "160px", filterable: { multi: true }, title: "Role" },
                { field: "lastLogin", title: "Last Login", width: "180px" },
                { field: "company", title: "Company", filterable: { multi: true } },
                { field: "teamId", hidden: true },
                { field: "teamName", title: "Team", filterable: { multi: true } },
            ];
        }
        return [
            { command: { text: "Edit", click: this.showDetails.bind(this) }, title: " ", width: "105px" },
            { field: "username", title: "Username", width: "250px", filterable: { extra: false, search: true } },
            { field: "role", width: "160px", filterable: { multi: true }, title: "Role" },
            { field: "lastLogin", title: "Last Login", width: "180px" },
            { field: "company", title: "Company", filterable: { multi: true } },
            { field: "teamId", hidden: true },
            { field: "teamName", title: "Team", filterable: { multi: true } },
        ];
    }
    showDetails(e) {
        e.preventDefault();
        const grid = $("#usersList").data("kendoGrid");
        const row = $(e.currentTarget).closest("tr");
        const dataItem = grid.dataItem(row);
        this.editUser.open(dataItem);
    }
    populateMinersGrid(users) {
        const grid = $("#usersList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: users,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
        this.toggleBusy(false);
    }
    inviteUser() {
        this.invite = new UserInvite();
        this.invite.open();
    }
    cancelInvite() {
        $(".invite-user-wrapper").removeClass("slide-up");
    }
}

class AlertCategories {
}
AlertCategories.AlertList = [
    {
        id: 1,
        name: "Overall Hash Rate Performance",
        description: "Get alerted on a drop in your overall hash rate"
    },
    {
        id: 2,
        name: "Offline Miners",
        description: "Get alerted when your miners stop hashing"
    },
    {
        id: 3,
        name: "Low Hashing Miners",
        description: "Get alerted when your miners are low hasing"
    },
    {
        id: 4,
        name: "Offline Sensors",
        description: "Get alerted when your sensors are offline"
    },
    {
        id: 5,
        name: "Offline Agents",
        description: "Get alerted when your agents are offline"
    },
];
AlertCategories.DestinationList = [
    {
        id: 1,
        name: "Email",
        label: "Email",
    },
    {
        id: 2,
        name: "Text Message (SMS)",
        label: "Phone Number",
    },
    {
        id: 3,
        name: "Telegram",
        label: "Telegram Username",
    }
];

var Alert;
(function (Alert) {
    Alert[Alert["OverallHashratePerformance"] = 1] = "OverallHashratePerformance";
    Alert[Alert["OfflineMiners"] = 2] = "OfflineMiners";
    Alert[Alert["LowHashingMiners"] = 3] = "LowHashingMiners";
    Alert[Alert["OfflineSensors"] = 4] = "OfflineSensors";
})(Alert || (Alert = {}));
class AlertManager {
    constructor(alertsPage) {
        this.alertsPage = alertsPage;
        this.alertsURL = "/Alerts";
        this.notificationUsersURL = "/NotificationUsers";
        this.createAlertURL = "/CreateAlert";
        this.deleteAlertURL = "/DeleteAlert";
        this.updateAlertURL = "/UpdateAlert";
        this.toggleAlertURL = "/ToggleAlert";
        this.alertsPage.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        [this.ddlSiteId, this.ddlAlertId, this.ddlDestinationId, this.ddlTargetUserId, this.numPercentageThreshold, this.numCountThreshold, this.ddlInputType] = this.initNewAlertForm();
    }
    handleCompanyFilterChanged() {
        this.alertsPage.siteCache.loadSites();
        this.initSiteDdl();
    }
    initNewAlertForm() {
        const ddlSiteId = this.initSiteDdl();
        const ddlAlertId = $("#ddlAlertId").kendoDropDownList({
            optionLabel: "Choose...",
            dataTextField: "name",
            dataValueField: "id",
            dataSource: AlertCategories.AlertList,
            height: 200,
            change: this.ddlAlertIdChanged.bind(this),
        }).data("kendoDropDownList");
        const ddlDestinationId = $("#ddlDestinationId").kendoDropDownList({
            dataTextField: "name",
            dataValueField: "id",
            dataSource: AlertCategories.DestinationList,
            height: 200,
            change: this.ddlDestinationIdChanged.bind(this),
        }).data("kendoDropDownList");
        const ddlTargetUserId = $("#ddlTargetUserId").kendoDropDownList({
            dataTextField: "username",
            dataValueField: "id",
            filter: "contains",
            dataSource: [],
            height: 200,
            change: this.ddlTargetUserIdChanged.bind(this),
        }).data("kendoDropDownList");
        const numPercentageThreshold = $("#percentageThreshold").kendoNumericTextBox({
            format: "p",
            factor: 100,
            min: 0.0,
            max: 0.95,
            step: 0.01,
            value: 0.10,
            decimals: 4,
            restrictDecimals: true,
            change: this.rebuildSummary.bind(this),
        }).data("kendoNumericTextBox");
        const numCountThreshold = $("#countThreshold").kendoNumericTextBox({
            format: "0",
            min: 0,
            step: 1,
            value: 0,
            change: this.rebuildSummary.bind(this),
        }).data("kendoNumericTextBox");
        const ddlInputType = $("#ddlInputType").kendoDropDownList({
            dataTextField: "name",
            dataValueField: "id",
            dataSource: {
                type: "odata",
                data: [
                    { "id": 0, "name": "# of total" },
                    { "id": 1, "name": "% of total" },
                ]
            },
            height: 220,
            change: this.changedInputType.bind(this),
            enable: false,
        }).data("kendoDropDownList");
        $("#alertOnRecovery").change(this.rebuildSummary.bind(this));
        return [ddlSiteId, ddlAlertId, ddlDestinationId, ddlTargetUserId, numPercentageThreshold, numCountThreshold, ddlInputType];
    }
    initSiteDdl() {
        this.alertsPage.siteCache.getSites().then((sites) => {
            this.ddlSiteId = $("#ddlSiteId").kendoDropDownList({
                optionLabel: "Choose...",
                dataTextField: "siteName",
                dataValueField: "siteId",
                dataSource: sites,
                height: 200,
            }).data("kendoDropDownList");
        });
    }
    ddlDestinationIdChanged() {
        this.rebuildSummary();
        this.refreshDestinationPreview();
        $("#alert-save-errors").addClass("hide");
    }
    ddlTargetUserIdChanged() {
        this.refreshDestinationPreview();
        $("#alert-save-errors").addClass("hide");
    }
    refreshDestinationPreview() {
        const destinationPreview = $("#destinationPreview");
        const userId = parseInt(this.ddlTargetUserId.value()) || 0;
        const destinationId = parseInt(this.ddlDestinationId.value());
        const destinationLabel = this.getDestinationLabel(destinationId);
        const destinationValue = this.getDestinationValue(userId, destinationId);
        if (destinationValue === null) {
            destinationPreview.html(`<span class="invalid-value" >${destinationLabel}: ${destinationValue}</span>`);
        }
        else {
            destinationPreview.text(`${destinationLabel}: ${destinationValue}`);
        }
        // Enable/disable the Set Alert button based on whether a valid destination is selected.
        // Note: Oddly enough .prop did not work here to visibly disable the button
        $(".create-alert-wrapper .op-btn").attr("disabled", destinationValue ? null : "disabled");
    }
    rebuildSummary() {
        const createData = this.getCreateAlertData();
        const notificationMethod = this.ddlDestinationId.text();
        const triggerCategory = this.ddlAlertId.text();
        let threshold = createData.percentageThreshold;
        let summary = "";
        let alertOnRecoveryMessage = "";
        if (createData.alertId === Alert.OverallHashratePerformance) {
            summary = `Alert summary: Alert me via ${notificationMethod} when ${triggerCategory} is below ${threshold}%.`;
            alertOnRecoveryMessage = `Send another alert upon recovery when ${triggerCategory} is at or above ${threshold}%.`;
        }
        else {
            if (threshold === null) {
                threshold = createData.countThreshold;
            }
            else {
                threshold = threshold.toString() + "%";
            }
            summary = `Alert summary: Alert me via ${notificationMethod} when ${triggerCategory} is above ${threshold}.`;
            alertOnRecoveryMessage = `Send another alert upon recovery when ${triggerCategory} is at or below ${threshold} of total miners.`;
        }
        if (createData.alertOnRecovery) {
            summary += (" " + alertOnRecoveryMessage);
        }
        $("#alert-summary").text(summary);
        $(".story-notification-channel").text(notificationMethod);
    }
    changedInputType(event) {
        $(".alert-input-percentage-threshold").hide();
        $(".alert-input-count-threshold").hide();
        const selectedValue = event.sender.value();
        if (selectedValue === '0') {
            $(".alert-input-count-threshold").show();
        }
        else if (selectedValue === '1') {
            $(".alert-input-percentage-threshold").show();
        }
        this.rebuildSummary();
    }
    // Alter the options based on the Alert Category
    ddlAlertIdChanged(event) {
        // hide everything
        $(".alert-input-percentage-threshold").hide();
        $(".alert-input-count-threshold").hide();
        $(".alert-input-type-selector").hide();
        const inputTypeSelector = $("#ddlInputType").data('kendoDropDownList');
        const selectedValue = event.sender.value();
        if (selectedValue == Alert.OverallHashratePerformance) { // Overall Hashrate Performance
            // Show only the Percentage
            $("#percentageThreshold").data('kendoNumericTextBox').value(0.85);
            $(".alert-input-percentage-threshold").show();
            $(".alert-input-percentage-threshold .detail-label").text("Alert trigger threshold: (less than)");
        }
        else if (selectedValue != "") {
            // Show the input type dropdown and default the Count
            $("#percentageThreshold").data('kendoNumericTextBox').value(0.05);
            inputTypeSelector.enable(true);
            $(".alert-input-type-selector").show();
            inputTypeSelector.select(0);
            $(".alert-input-count-threshold").show();
            $(".alert-input-count-threshold .detail-label").text("Units");
            $(".alert-input-percentage-threshold .detail-label").text("Percent");
        }
        else {
            inputTypeSelector.enable(false);
            inputTypeSelector.select(0);
        }
        this.rebuildSummary();
    }
    resetNewAlertForm() {
        var _a;
        $("#userAlertId").val('');
        this.ddlAlertId.select(0);
        this.ddlAlertId.trigger('change');
        this.initSiteDdl();
        this.ddlSiteId.select(0);
        this.ddlSiteId.trigger('change');
        // Set the target user to the selected one
        const ddlViewUserId = $('#ddlViewUserId').data("kendoDropDownList");
        if (ddlViewUserId.element.is(":enabled")) {
            this.ddlTargetUserId.select((_a = ddlViewUserId.select()) !== null && _a !== void 0 ? _a : 0);
            this.ddlTargetUserId.enable(true);
        }
        else {
            this.ddlTargetUserId.select(0);
            this.ddlTargetUserId.enable(false);
        }
        this.numCountThreshold.value(0);
        this.numPercentageThreshold.value(85);
        this.ddlDestinationId.select(0);
        this.ddlDestinationId.trigger("change");
        $("#alertOnRecovery").prop("checked", "checked").trigger("change");
        $("#enabled").prop("checked", "checked").trigger("change");
    }
    showNewAlertForm() {
        this.resetNewAlertForm();
        $(".new-alert").addClass("active");
    }
    closeNewAlertWindow() {
        $(".new-alert").removeClass("active");
    }
    openEditAlertForm(alertToEdit) {
        this.resetNewAlertForm();
        // Load alert data
        // Set the ID
        $("#userAlertId").val(alertToEdit.id);
        // Set the Alert type and trigger a change as if it was manually changed
        this.ddlAlertId.select(alertToEdit.alertId);
        this.ddlAlertId.trigger('change');
        // Set the selected site to the alert's site
        this.ddlSiteId.select(function (dataItem) {
            var _a;
            // siteId -1 is 'All Sites'
            return dataItem.siteId === ((_a = alertToEdit.siteId) !== null && _a !== void 0 ? _a : -1);
        });
        this.ddlSiteId.trigger('change');
        // Set the target user in case it's visible
        this.ddlTargetUserId.value(alertToEdit.userId.toString());
        this.ddlTargetUserId.enable(false);
        // Populate the correct fields based on the category and percentage vs count
        if (alertToEdit.percentageThreshold) {
            if (alertToEdit.alertId === Alert.OfflineMiners) {
                this.ddlInputType.value("1");
                this.ddlInputType.trigger('change');
            }
            // Note: Since the KendoNumericTextBox represents the percentages as 0 through 1, we need to divide by 100 (or prepend "0.")
            const adjustedValue = alertToEdit.percentageThreshold / 100;
            this.numPercentageThreshold.value(adjustedValue);
        }
        else {
            this.numCountThreshold.value(alertToEdit.countThreshold);
        }
        this.ddlDestinationId.value(alertToEdit.destinationId.toString());
        const destinationPreview = $("#destinationPreview");
        const destinationPreviewText = this.getDestinationValue(alertToEdit.userId, alertToEdit.destinationId);
        destinationPreview.text(destinationPreviewText);
        $("#alertOnRecovery").prop("checked", alertToEdit.alertOnRecovery).trigger("change");
        $("#enabled").prop("checked", alertToEdit.enabled).trigger("change");
        this.rebuildSummary();
        // Display alert
        $(".new-alert").addClass("active"); // Move me down and delete this comment
    }
    getDestinationValue(userId, destinationId) {
        for (const user of this.notificationUserData) {
            if (userId === user.id) {
                if (destinationId === 1) { // email
                    return user.email;
                }
                else if (destinationId === 2) { // phone
                    return user.phone;
                }
                else if (destinationId === 3) { // telegram
                    return user.telegram;
                }
            }
        }
        return null;
    }
    getDestinationLabel(destinationId) {
        for (const destination of AlertCategories.DestinationList) {
            if (destination.id === destinationId) {
                return destination.label;
            }
        }
    }
    getCreateAlertData() {
        const userAlertId = parseInt($("#userAlertId").val()) || 0;
        const siteId = parseInt($("#ddlSiteId").val());
        const alertId = parseInt($("#ddlAlertId").val());
        const targetUserId = parseInt($("#ddlTargetUserId").val());
        const destinationId = parseInt($("#ddlDestinationId").val());
        let percentageThreshold = null;
        let countThreshold = null;
        // Take the selected threshold type, and leave the other null
        if (alertId === Alert.OverallHashratePerformance) {
            percentageThreshold = parseFloat($("#percentageThreshold").val());
        }
        else {
            const inputType = parseInt($("#ddlInputType").val());
            if (inputType === 0) {
                countThreshold = parseInt($("#countThreshold").val());
            }
            else if (inputType === 1) {
                percentageThreshold = parseFloat($("#percentageThreshold").val());
            }
        }
        const alertOnRecovery = $("#alertOnRecovery").prop('checked');
        const enabled = $("#enabled").prop('checked');
        return {
            id: userAlertId,
            siteId: siteId,
            alertId: alertId,
            targetUserId: targetUserId,
            destinationId: destinationId,
            percentageThreshold: percentageThreshold,
            countThreshold: countThreshold,
            alertOnRecovery: alertOnRecovery,
            enabled: enabled,
        };
    }
    isValid(sample) {
        $("#alert-save-errors").addClass("hide");
        $(".site-category-error").addClass("hide");
        $(".all-site-category-error").addClass("hide");
        $(".alert-category-error").addClass("hide");
        $(".alert-who-error").addClass("hide");
        $(".alert-how-error").addClass("hide");
        let valid = true;
        if (isNaN(sample.siteId)) {
            $(".site-category-error").removeClass("hide");
            valid = false;
        }
        if (sample.siteId === -1 && sample.alertId === Alert.OfflineSensors) {
            $(".all-site-category-error").removeClass("hide");
            valid = false;
        }
        if (isNaN(sample.alertId) || sample.alertId <= 0) {
            $(".alert-category-error").removeClass("hide");
            valid = false;
        }
        if (this.ddlTargetUserId.element.is(":enabled")) {
            if (isNaN(sample.targetUserId) || sample.targetUserId <= 0) {
                $(".alert-who-error").removeClass("hide");
                valid = false;
            }
        }
        if (isNaN(sample.destinationId) || sample.destinationId <= 0) {
            $(".alert-how-error").removeClass("hide");
            valid = false;
        }
        return valid;
    }
    deleteAlert(id) {
        const request = {
            'id': id
        };
        return this.alertsPage.post(this.deleteAlertURL, request);
    }
}

const VARIANTS$1 = [
    'is-indigo',
    'is-plum',
    'is-red',
    'is-amber',
    'is-accent',
];
class Avatar {
    /**
     *
     * generates an html div element that can be inserted anywhere.
     * styling other than background must be done in css
     * @param userId
     * @param name
     * @param className
     */
    static gen(userId, name, className) {
        const index = userId % VARIANTS$1.length;
        // TEMPORARY SOLUTION - WE NEED AN XS AVATAR SIZE IN METAL
        if (!name) {
            return `<div 
                class='m-avatar is-rounded ${className} ${VARIANTS$1[index]}'>
                    <div class='m-avatar-fallback'>
                    </div>
                </div>`;
        }
        return `<div class='m-avatar is-rounded is-size-s ${className} ${VARIANTS$1[index]}'>
            <div class='m-avatar-fallback'>${name && name.slice(0, 2).toUpperCase()}</div></div>`;
    }
    static genUnassigned(withInitial = false) {
        const initial = withInitial ? "UA" : "";
        if (!initial) {
            return `<div 
                class='m-avatar is-rounded is-neutral'>
                <div class='m-avatar-fallback is-neutral'></div>
                </div>`;
        }
        return `<div class='m-avatar is-rounded is-size-s is-neutral'>
            <div class='m-avatar-fallback is-neutral'>${initial}</div></div>`;
    }
}

const LEGEND_COLORS = [
    "#00E67E",
    "#2966FF",
    "#FFBA00",
    "#D232FF",
    "cyan",
    "orange",
];
const DEFAULT_OVERRIDE_PARAMS = {
    withLegend: false,
    height: "135px",
    maxY: null,
    useNoLegendColors: false,
    annotationLegendClickHandler: null,
};
const NO_LEGEND_COLORS = ["#00E67E", "#adb5b2"];
class StyledLineChart extends PrometheusRange {
    constructor(elementSelector, title, overrideParams, busySelector) {
        var _a;
        super([], busySelector);
        this.elementSelector = elementSelector;
        this.title = title;
        this.chartType = ChartType.Line;
        this.overrideParams = DEFAULT_OVERRIDE_PARAMS;
        this.hasData = false;
        this.isInitialized = false;
        this.graphBusySelector = "";
        this.STYLED_CHART_OPTIONS = {
            chart: {
                events: {
                    zoomed: (chartContext, { xaxis, yaxis }) => {
                        $(`#${this.elementSelector}Home`).show();
                        this.setXAxisLabels(xaxis.min, xaxis.max);
                    }
                },
                animations: {
                    enabled: false
                },
                type: "line",
                stacked: false,
                height: DEFAULT_OVERRIDE_PARAMS.height,
                zoom: {
                    enabled: true,
                    zoomedArea: {
                        fill: {
                            color: '#00E67E',
                            opacity: 0.2
                        },
                        stroke: {
                            color: '#00E67E',
                            opacity: 0.4,
                            width: 1
                        }
                    }
                },
                toolbar: {
                    show: false,
                    //tools: {
                    //    zoom: true
                    //}
                }
            },
            colors: ((_a = this.overrideParams) === null || _a === void 0 ? void 0 : _a.withLegend) ? LEGEND_COLORS : NO_LEGEND_COLORS,
            grid: {
                yaxis: {
                    lines: {
                        show: false
                    }
                }
            },
            dataLabels: {
                enabled: false
            },
            noData: {
                text: 'No data is available for this time range'
            },
            stroke: {
                // colors: this.overrideParams?.withLegend ? LEGEND_COLORS : NO_LEGEND_COLORS,
                dashArray: [0, 2],
                curve: 'smooth',
                width: 1.75
            },
            legend: {
                show: false,
                labels: {
                // colors: this.overrideParams?.withLegend ? LEGEND_COLORS : NO_LEGEND_COLORS
                }
            },
            markers: {
            // colors: this.overrideParams?.withLegend ? LEGEND_COLORS : NO_LEGEND_COLORS
            },
            xaxis: {
                show: false,
                type: 'numeric',
                labels: {
                    show: false,
                    maxHeight: 5,
                    minHeight: 5,
                    hideOverlappingLabels: true,
                    formatter: (value, timestamp, opts) => {
                        const m = window.moment(new Date(value));
                        return m.format("YYYY-MM-DD HH:mm");
                    },
                    style: {
                        colors: '#aab2af',
                        fontFamily: "var(--font-family)",
                        fontSize: "12px",
                        fontWeight: 400,
                        cssClass: "chart-text"
                    },
                    trim: false,
                },
                tooltip: {
                    enabled: false
                },
                tickAmount: 0,
                axisTicks: {
                    show: false
                },
                axisBorder: {
                    show: false,
                    color: "#3b403e",
                    borderType: "1px solid",
                    offsetX: 0
                }
            },
            yaxis: {
                showAlways: true,
                //forceNiceScale: true,
                labels: {
                    show: true,
                    minWidth: 0,
                    maxWidth: 65,
                    style: {
                        colors: '#aab2af',
                        fontFamily: "var(--font-family)",
                        fontSize: "12px",
                        fontWeight: 400,
                        cssClass: "chart-text"
                    },
                    formatter: (val) => val
                },
                //min: 0,
                tickAmount: 1,
            }
        };
        this.onGraphDataLoaded = (data) => null;
        this.graphBusySelector = busySelector;
        if (overrideParams) {
            this.overrideParams = Object.assign(Object.assign({}, this.overrideParams), overrideParams);
        }
        $(`#${this.elementSelector}Home`).on("click", () => {
            $(`#${this.elementSelector}Home`).hide();
            this.chartRef.resetSeries();
            this.setXAxisLabels(this.originalStart, this.originalEnd);
        });
        $(`#${this.elementSelector}Home`).hide();
        this.initChartOpts();
    }
    initChartOpts() {
        var _a, _b;
        this.chartOpts = this.STYLED_CHART_OPTIONS;
        if (this.overrideParams.maxY) {
            this.chartOpts.yaxis.max = this.overrideParams.maxY;
        }
        if (this.overrideParams) {
            this.chartOpts.chart.height = this.overrideParams.height;
        }
        this.chartOpts.colors = ((_a = this.overrideParams) === null || _a === void 0 ? void 0 : _a.withLegend) ? LEGEND_COLORS : NO_LEGEND_COLORS;
        this.chartOpts.colors = ((_b = this.overrideParams) === null || _b === void 0 ? void 0 : _b.useNoLegendColors) ? NO_LEGEND_COLORS : this.chartOpts.colors;
    }
    populateXAxis(series) {
        if (series.length === 0)
            return;
        if (series[0].data.length === 0)
            return;
        this.originalStart = new Date(series[0].data[0][0]);
        this.originalEnd = new Date(series[0].data[series[0].data.length - 1][0]);
        this.setXAxisLabels(this.originalStart, this.originalEnd);
    }
    setXAxisLabels(start, end) {
        $(`#${this.elementSelector}StartLabel`).text(window.moment(start).format("MM-DD-YYYY HH:mm"));
        $(`#${this.elementSelector}EndLabel`).text(window.moment(end).format("MM-DD-YYYY HH:mm"));
    }
    populateLegend(series, annotations) {
        const legendId = this.elementSelector + "Legend";
        const parentEl = $(`#${legendId}`);
        parentEl.empty();
        const templateId = this.elementSelector + "LegendItemTemplate";
        const templateHtml = $(`#${templateId}`).html();
        series.forEach((metric, index) => {
            if (metric.name) {
                const color_index = index % this.chartOpts.colors.length;
                const elId = this.elementSelector + index.toString();
                const data = {
                    elId,
                    name: metric.name,
                    color: this.chartOpts.colors[color_index]
                };
                const template = self.Mustache.to_html(templateHtml, data);
                parentEl.append(template);
                // handle chip toggle
                document.getElementById(elId).onclick = this.handleSeriesToggle.bind(this, elId, metric.name);
            }
        });
        if (!annotations) {
            return;
        }
        parentEl.append("<div class='m-stack is-horizontal m-text is-size-s is-tertiary'>|</div>");
        const annotationTemplateId = this.elementSelector + "LegendAnnotationTemplate";
        const annotationTemplateHtml = $(`#${annotationTemplateId}`).html();
        const annotationTypes = Array.from(new Set(annotations.xaxis.filter(x => x.label.text).map(x => x.label.text)));
        annotationTypes.forEach((value, index) => {
            const color_index = index % this.chartOpts.colors.length;
            const elId = this.elementSelector + "_anno_" + index.toString();
            const data = {
                elId,
                name: value,
                color: this.chartOpts.colors[color_index]
            };
            const template = self.Mustache.to_html(annotationTemplateHtml, data);
            parentEl.append(template);
            // handle chip toggle
            if (this.overrideParams.annotationLegendClickHandler != null) {
                document.getElementById(elId).onclick = this.overrideParams.annotationLegendClickHandler.bind(this, elId, value);
            }
        });
    }
    handleSeriesToggle(chipId, seriesName, e) {
        const el = $(`#${chipId}`);
        const isActive = el.hasClass("active");
        const otherSeriesNames = this.series.filter(s => s.name !== seriesName).map(s => s.name);
        if (isActive) {
            //show all series
            this.activeSeriesIndex = null;
            el.removeClass("active");
            otherSeriesNames.forEach(name => this.chartRef.showSeries(name));
        }
        else {
            this.chartRef.showSeries(seriesName);
            otherSeriesNames.forEach(name => this.chartRef.hideSeries(name));
            // only show this series
            el.addClass("active");
            el.siblings().removeClass("active");
        }
    }
    populateChartData(graphData, annotations) {
        var _a;
        const seriesData = [];
        try {
            graphData.forEach(series => {
                series.data.result.forEach((result, idx) => {
                    var _a;
                    seriesData.push({
                        name: ((_a = result.metric) === null || _a === void 0 ? void 0 : _a.name) || series.internalName || "",
                        data: result.values
                    });
                });
            });
        }
        catch (_b) {
            return;
        }
        this.populateXAxis(seriesData);
        ((_a = this.overrideParams) === null || _a === void 0 ? void 0 : _a.withLegend) && this.populateLegend(seriesData, annotations);
        this.series = seriesData;
        this.annotations = annotations !== null && annotations !== void 0 ? annotations : {};
        this.render();
    }
    getSeriesData() {
        this.hasData = false;
        if (!this.series) {
            return [{ data: [] }];
        }
        this.series.forEach((serie) => {
            if (serie.data.length > 0) {
                this.hasData = true;
            }
        });
        if (!this.series) {
            return [{ data: [] }];
        }
        this.series.forEach((serie) => {
            if (serie.data.length > 0) {
                this.hasData = true;
            }
        });
        if (!this.hasData) {
            return [{ data: [] }];
        }
        return this.series;
    }
    /**
     * Destroys the line chart
     * */
    destroy() {
        this.chartRef.destroy();
        this.isInitialized = false;
        const parent = $(`#${this.elementSelector}`);
        $(`#${this.elementSelector}`).remove();
        const chart = document.createElement("div");
        chart.id = this.elementSelector;
        $(parent).append(chart);
    }
    updateChart() {
        const data = this.getSeriesData();
        this.chartRef.updateOptions({
            annotations: this.annotations,
            xaxis: {
                labels: {
                    show: this.hasData
                }
            }
        });
        this.chartRef.clearAnnotations();
        this.chartRef.updateSeries(data);
    }
    exportExcel(title, withAverages = false) {
        let header_arr = ["Time"];
        let rows = [];
        this.series.forEach(series => {
            header_arr.push(series.name);
        });
        header_arr.push("\r\n");
        const header = header_arr.join(',');
        this.series[0].data.forEach((value, index) => {
            let row = [];
            const time = value[0];
            row.push(window.moment(new Date(time)).format("MM-DD-YYYY HH:mm:ss"));
            this.series.forEach(series => {
                row.push(series.data[index][1]);
            });
            row.push("\r\n");
            rows.push(row.join(","));
        });
        if (withAverages) {
            let row = ["Average"];
            this.series.forEach(s => {
                row.push((s.data.reduce((total, next) => total + (parseFloat(next[1]) || 0), 0) / s.data.length).toString());
            });
            row.push("\r\n");
            rows.push(row.join(","));
        }
        const csv = [header, ...rows].join("");
        ExcelUtility.exportFromCsvData(csv, title);
    }
    /**
     * Renders the line chart
     * */
    render() {
        var _a;
        if (this.isInitialized) {
            this.updateChart();
            return;
        }
        this.isInitialized = true;
        let seriesData = this.getSeriesData();
        let opts = this.chartOpts;
        if (this.formatter) {
            opts.yaxis.labels.formatter = this.formatter;
        }
        if (((_a = this.overrideParams) === null || _a === void 0 ? void 0 : _a.withLegend) && !this.overrideParams.useNoLegendColors) {
            opts.stroke.dashArray = undefined;
        }
        const options = Object.assign({ series: seriesData, annotations: this.annotations }, opts);
        const chart = new ApexCharts(document.getElementById(this.elementSelector), options);
        chart.render();
        this.chartRef = chart;
    }
    static newXaxisAnnotation(title, start, end, color) {
        return {
            x: start,
            x2: end,
            fillColor: color,
            opacity: .4,
            borderWidth: 0,
            strokeDashArray: 0,
            borderColor: color,
            label: {
                borderColor: color,
                style: {
                    fontSize: '12px',
                    color: '#adb5b2',
                    background: '#101211',
                },
                offsetY: -10,
                text: title,
            }
        };
    }
}

class ClearFilters {
    constructor(id, filters) {
        this.id = id;
        this.filters = filters;
        $(window).click((event) => {
            if ($(event.target).parents(`[c-id=${this.id}]`).length) {
                this.clearFilters();
            }
            if (this.filters.some((filter) => { return filter.isActive; })) {
                $(`[c-id=${this.id}]`).show();
            }
            else {
                $(`[c-id=${this.id}]`).hide();
            }
        });
        $(`[c-id=${this.id}]`).hide();
    }
    clearFilters() {
        this.filters.forEach(filter => {
            if (filter.isActive) {
                filter.clear();
            }
        });
    }
}

var CommentBoxType;
(function (CommentBoxType) {
    CommentBoxType["ReadOnly"] = "ReadOnly";
    CommentBoxType["Edit"] = "Editable";
    CommentBoxType["Write"] = "Write";
})(CommentBoxType || (CommentBoxType = {}));
//type CommentBoxReadData = {
//    index: number,
//    user?: User,
//    commentId?: number,
//    initiator?: string,
//    elapsedTime?: string,
//    contents?: string,
//}
//type CommentBoxWriteData = {
//    index: number,
//    user?: User,
//}
class OpCommentBox {
    constructor() {
        this.editLock = false;
    }
    appendTemplate(parentEl, type, data) {
        const templateId = "commentBoxTemplate" + type.toString();
        const templateHtml = document.getElementById(templateId).innerHTML;
        const template = self.Mustache.to_html(templateHtml, data);
        parentEl.append(template);
        // set avatar
        const avatarTemplateString = this.getAvatar(data.user);
        const avatarTemplate = self.Mustache.to_html(avatarTemplateString, {});
        $(`#commentBoxAvatar${data.index}`).append(avatarTemplate);
        // add handlers
        let inputId;
        let targetId;
        switch (type) {
            case CommentBoxType.Edit:
                targetId = "commentEditButton" + data.index;
                inputId = "editComment" + data.index;
                const editOptionId = "commentMenuEdit" + data.index;
                const deleteOptionId = "commentMenuDelete" + data.index;
                const commentMenuId = "commentMenuIcon" + data.index;
                document.getElementById(commentMenuId).onclick = this.toggleCommentMenu.bind(this, data.index);
                document.getElementById(targetId).onclick = this.editComment.bind(this, inputId, data.commentId, data.contents);
                document.getElementById(editOptionId).onclick = this.openEditComment.bind(this, data.index);
                document.getElementById(deleteOptionId).onclick = this.deleteHandler.bind(this, data.commentId);
                $(`#${inputId}`).off('focusout');
                $(`#${inputId}`).focusout(this.resetComment.bind(this, inputId, data.index, data.contents));
                break;
            case CommentBoxType.Write:
                targetId = "commentSaveButton" + data.index;
                inputId = "writeComment" + data.index;
                document.getElementById(targetId).onclick = this.postHandler.bind(this, inputId);
                break;
        }
    }
    toggleCommentMenu(eventIndex, e) {
        const menuId = `#commentMenu${eventIndex}`;
        const isActive = $(menuId).hasClass('active');
        const iconId = menuId.replace("commentMenu", "commentMenuIcon");
        if (isActive) {
            $(menuId).removeClass('active');
            $(iconId).removeClass('active');
        }
        else {
            $(menuId).addClass('active');
            $(iconId).addClass('active');
        }
    }
    openEditComment(eventIndex) {
        const input = $(`#editComment${eventIndex}`);
        input.prop("contenteditable", "plaintext-only");
        input.focus();
        $(`#commentEditButton${eventIndex}`).addClass('active');
        this.toggleCommentMenu(eventIndex);
    }
    closeEditComment(eventIndex) {
        $(`#editComment${eventIndex}`).prop("contenteditable", "false");
        $(`#commentEditButton${eventIndex}`).removeClass('active');
    }
    resetComment(inputId, eventIndex, prevValue, e) {
        // wait for lock to be set in case user is trying to submit
        setTimeout(() => {
            if (this.editLock) {
                this.editLock = false;
                return;
            }
            $(`#${inputId}`).text(prevValue);
            this.closeEditComment(eventIndex);
        }, 250);
    }
    editComment(elId, commentId, prevValue, e) {
        this.editLock = true;
        const text = $(`#${elId}`).text();
        if (!text || text == prevValue.trim())
            return;
        this.patchHandler(commentId, text, e);
    }
    getAvatar(user) {
        if (user) {
            return Avatar.gen(user.userId, user.username, "");
        }
        else {
            return Avatar.genUnassigned(true);
        }
    }
}

class CompanySwitcher {
    constructor(id, selectedCompany, companies, onChange) {
        this.id = id;
        this.selectedCompany = selectedCompany;
        this.companies = companies;
        this.onChange = onChange;
        $(window).click((event) => {
            if (!$(event.target).parents(`.m-uishell-left-panel`).length) {
                $(`${this.id}Dropdown`).attr("hidden", "false");
            }
        });
        this.init();
    }
    init() {
        const companySwitcherElem = $("#" + this.id);
        const labelElem = document.getElementById(`${this.id}Label`);
        const menuElem = document.getElementById(`${this.id}Menu`);
        const menuIcon = $(`#${this.id}Wrapper`).find("m-icon");
        const hideDropdown = this.companies.length <= 1;
        const dropdownMenu = $(`${this.id}Dropdown`);
        labelElem.textContent = this.selectedCompany.name;
        if (!hideDropdown) {
            companySwitcherElem.on("click", this.openDropdownMenu.bind(this));
            companySwitcherElem.addClass("active");
            document.getElementById(`${this.id}Menu`).addEventListener("on-click", (e) => {
                const { id, label } = e.detail;
                this.onMenuClick(id, label);
            });
            menuElem.selected = this.selectedCompany.id.toString();
            menuIcon.show();
            dropdownMenu.show();
            const menuItems = this.companies.map(company => {
                return { label: company.name, id: company.id };
            });
            menuElem.menuItems = menuItems;
        }
        else {
            companySwitcherElem.removeClass("active");
            menuIcon.hide();
            dropdownMenu.hide();
        }
    }
    openDropdownMenu() {
        const elem = document.getElementById(`${this.id}Dropdown`);
        const isHidden = elem.hasAttribute("hidden");
        if (isHidden) {
            elem.removeAttribute("hidden");
        }
        else {
            elem.setAttribute("hidden", "");
        }
    }
    onMenuClick(id, name) {
        const menuElem = document.getElementById(`${this.id}Menu`);
        menuElem.selected = id;
        this.onChange(id, name);
    }
}

class CdDropdown {
    constructor(id) {
        this.id = id;
        this.isReadOnly = false;
        this.elem = document.getElementById(`${id}cdDropdownButton`);
        if (!this.elem)
            return;
        this.elem.onclick = this.toggleMenu.bind(this);
        this.overlayId = `#${id}cdDropdownOverlay`;
        const overlay = document.getElementById(`${id}cdDropdownOverlay`);
        overlay.onclick = this.toggleMenu.bind(this);
        this.htmlPanelId = `#${id}cdDropdownPanel`;
        this.htmlListId = `#${id}cdDropdownList`;
        this.htmlSelectedValueId = `#${id}cdDropdownText`;
    }
    // just used for siteFilterCache compatibility
    setDataSource(sites, _siteName, _siteId) {
        this.setOptions(sites.map(s => {
            return { id: s.siteId, value: s.siteName };
        }));
    }
    setOptions(options) {
        this.listItems = options;
        $(this.htmlListId).html("");
        this.setDefaultValue(this.listItems[0].id);
        options.forEach((value, index) => {
            value['htmlId'] = `${this.id}ListItem${index}`;
            let template = self.Mustache.to_html(LIST_TIME_TEMPLATE, value);
            $(this.htmlListId).append(template);
            const el = document.getElementById(value['htmlId']);
            el.onclick = this.onOptionSelect.bind(this, value.id);
        });
        this.toggleReadOnly(options.length === 1);
    }
    onOptionSelect(id, e) {
        const selectedOption = this.listItems.find(item => item.id === id);
        this.setDefaultValue(id);
        if (this.onSelectionChanged) {
            this.onSelectionChanged(this, selectedOption.id);
            this.closeMenu();
        }
    }
    setDefaultValue(id) {
        this.selectedId = id;
        const item = this.listItems.find(i => i.id === parseInt(id));
        $(this.htmlSelectedValueId).text(item.value);
    }
    toggleReadOnly(isReadOnly) {
        this.isReadOnly = isReadOnly;
        if (isReadOnly) {
            !$(this.elem).hasClass("readonly") && $(this.elem).addClass("readonly");
        }
        else {
            $(this.elem).hasClass("readonly") && $(this.elem).removeClass("readonly");
        }
    }
    toggleMenu() {
        if (this.isReadOnly)
            return;
        const hasClass = $(this.htmlPanelId).hasClass('active');
        if (hasClass) {
            $(this.elem).removeClass('active');
            $(this.htmlPanelId).removeClass('active');
            $(this.overlayId).removeClass('active');
        }
        else {
            $(this.elem).addClass('active');
            $(this.htmlPanelId).addClass('active');
            $(this.overlayId).addClass('active');
        }
    }
    closeMenu() {
        $(this.htmlPanelId).removeClass('active');
        $(this.overlayId).removeClass('active');
    }
    getSelectedValue() {
        return this.listItems.find(i => i.id === this.selectedId);
    }
    text() {
        return this.getSelectedValue().value;
    }
}
const LIST_TIME_TEMPLATE = `
            <div id="{{ htmlId }}" class="cd-dropdown-list-item">{{ value }}</div>
        `;

class OpDropDown {
    constructor(elem, defaultText) {
        this.elem = elem;
        this.dropDown = $(this.elem).kendoDropDownList({
            dataSource: [],
            change: (e) => {
                this.handleDropDownChangedEvent(e);
            },
            optionLabel: defaultText
        }).data("kendoDropDownList");
    }
    setOptions(options) {
        this.dropDown.setOptions(options);
    }
    setDataSource(dataArray, dataTextField, dataValueField) {
        this.dropDown.setDataSource(dataArray);
        if (!dataTextField || !dataValueField) {
            return;
        }
        this.dropDown.setOptions({
            dataTextField: dataTextField,
            dataValueField: dataValueField,
        });
    }
    setDefaultValue(value, withEventTrigger = false) {
        this.dropDown.value(value);
        if (!withEventTrigger)
            return;
        this.handleDropDownChangedEvent(null);
    }
    toggleReadOnly(isReadOnly) {
        this.dropDown.readonly(isReadOnly);
    }
    handleDropDownChangedEvent(ev) {
        if (!this.onSelectionChanged) {
            return;
        }
        this.onSelectionChanged(this.dropDown, this.dropDown.value());
    }
    getSelectedValue() {
        return this.dropDown.value();
    }
}

class OpFilter {
    constructor(id, applyFunc, clearFunc, options, externalUrl, isRefresh) {
        this.id = id;
        this.applyFunc = applyFunc;
        this.clearFunc = clearFunc;
        this.options = options;
        this.isCheckbox = options.length > 0;
        this.externalUrl = externalUrl;
        $(window).click((event) => {
            if (!$(event.target).parents(`[c-id=${this.id}]`).length) {
                $(`[c-id=${this.id}]`).removeClass("open");
            }
        });
        if (!isRefresh) {
            $(`[c-id=${this.id}Filter]`).on("click", this.toggleFilterOptions.bind(this));
            $(`[c-id=${this.id}Clear]`).on("click", this.clear.bind(this));
            $(`[c-id=${this.id}ApplyBtn]`).on("click", this.applyFilter.bind(this));
            $(`[c-id=${this.id}Input]`).keypress((e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    $(`[c-id=${this.id}ApplyBtn]`).click();
                }
            });
            // Adds attribute to checkbox area div
            if (this.isCheckbox || this.externalUrl) {
                const checkboxArea = $(`[c-id=${this.id}FilterOptions]`).children()[1];
                $(checkboxArea).attr("c-id", `${this.id}CheckboxArea`);
                this.populateCheckboxes(`${this.id}CheckboxArea`);
            }
        }
    }
    toggleFilterOptions(e) {
        if ($(e.target).parents(`[c-id=${this.id}Clear]`).length) {
            return;
        }
        $(`[c-id=${this.id}]`).toggleClass("open");
        if (!this.isCheckbox) {
            $(`[c-id=${this.id}Input]`).focus();
        }
    }
    applyFilter() {
        let filterVal;
        // If filter is checkbox variant, then set filter val to array of values
        if (this.isCheckbox || this.externalUrl) {
            let checkboxValues = [];
            this.options.forEach(option => {
                if ($(`[c-id=Option${option.id}]`).is(":checked")) {
                    checkboxValues.push(option);
                }
            });
            $(`[c-id=${this.id}Value]`).text(`${checkboxValues.length} Selected`);
            filterVal = checkboxValues;
            // Error if no checkboxes are checked
            if (filterVal.length === 0) {
                $(`[c-id=${this.id}ErrMessage`).text("Please select from the options");
                return;
            }
        }
        // If filter is text input variant, then set filter val to string
        if (!this.isCheckbox && !this.externalUrl) {
            filterVal = $(`[c-id=${this.id}Input]`).val();
            $(`[c-id=${this.id}Value]`).text(filterVal);
            // Error if text input is empty
            if (filterVal === "") {
                $(`[c-id=${this.id}ErrMessage`).text("Please enter a search term");
                return;
            }
        }
        $(`[c-id=${this.id}ErrMessage]`).text("");
        $(`[c-id=${this.id}]`).removeClass("open");
        $(`[c-id=${this.id}]`).addClass("active");
        this.isActive = true;
        this.applyFunc(filterVal, this.id);
    }
    deactivateFilter() {
        $(`[c-id=${this.id}]`).removeClass("active");
        if ($(`[c-id=${this.id}]`).hasClass("open")) {
            $(`[c-id=${this.id}]`).removeClass("open");
        }
        $(`[c-id=${this.id}Value]`).text("");
    }
    clear() {
        if (!$(`[c-id=${this.id}]`).hasClass("active")) {
            $(`[c-id=${this.id}]`).removeClass("open");
            $(`[c-id=${this.id}Input]`).val("");
            return;
        }
        if (this.isCheckbox) {
            // If is checkbox variant, uncheck all checkboxes
            this.options.forEach(option => {
                $(`[c-id=${option.id}Option]`).prop("checked", false);
            });
        }
        else {
            // Clear text field
            $(`[c-id=${this.id}Input]`).val("");
        }
        this.deactivateFilter();
        this.isActive = false;
        this.clearFunc(this.id);
    }
    populateCheckboxes(id) {
        if (!this.externalUrl) {
            this.populateHardcodedOptions(id);
        }
    }
    populateStatusResult(statuses, id) {
        statuses.forEach(option => {
            $(`[c-id=${id}CheckboxArea]`).append(`<div class="option m-menu-item" c-id="StatusMenuItem${option.statusId}">
                    <span>${option.displayName}</span>
                    <input type="checkbox" class="k-checkbox" c-id="Option${option.statusId}" />
                </div>`);
            $(`[c-id="StatusMenuItem${option.statusId}"]`).on("click", this.clickCheckbox.bind(this, `Option${option.statusId}`));
            $(`[c-id="Option${option.statusId}"]`).on("click", this.clickCheckbox.bind(this, `Option${option.statusId}`));
            this.options.push({
                label: option.displayName,
                id: option.statusId
            });
        });
    }
    populateTagsResult(tags, id) {
        $(`[c-id=${id}CheckboxArea]`).empty();
        tags.forEach(option => {
            $(`[c-id=${id}CheckboxArea]`).append(`<div class="option m-menu-item" c-id="TagMenuItem${option.id}">
                    <span>${option.name}</span>
                    <input type="checkbox" class="k-checkbox" c-id="Option${option.id}" />
                </div>`);
            $(`[c-id="TagMenuItem${option.id}"]`).on("click", this.clickCheckbox.bind(this, `Option${option.id}`));
            $(`[c-id="Option${option.id}"]`).on("click", this.clickCheckbox.bind(this, `Option${option.id}`));
            this.options.push({
                label: option.name,
                id: option.id
            });
        });
    }
    populateHardcodedOptions(id) {
        this.options.forEach(option => {
            $(`[c-id=${id}]`).append(`<div class="option m-menu-item" c-id="${id}MenuItem">
                    <span>${option.label}</span>
                    <input type="checkbox" class="k-checkbox" c-id="Option${option.id}" />
                </div>`);
            $(`[c-id="${option.id}MenuItem"]`).on("click", this.clickCheckbox.bind(this, `Option${option.id}`));
            $(`[c-id="Option${option.id}"]`).on("click", this.clickCheckbox.bind(this, `Option${option.id}`));
        });
    }
    clickCheckbox(id) {
        const isChecked = $(`[c-id="${id}"]`).is(":checked");
        $(`[c-id="${id}"]`).prop("checked", !isChecked);
    }
    setFilter(val) {
        if (this.isCheckbox || this.externalUrl) {
            this.clickCheckbox(`Option${val}`);
            this.applyFilter();
        }
        else {
            $(`[c-id=${this.id}Input]`).val(val);
            $(`[c-id=${this.id}Value]`).text(val);
            this.applyFilter();
        }
    }
}

class FilterCheckbox {
    constructor(config) {
        var _a;
        this.id = config.id;
        this.onApply = config.onApply;
        this.options = config.options;
        this.defaultValue = config.defaultValue;
        this.elem = $(`[c-id=${this.id}]`);
        this.elemFilter = $(`[c-id=${this.id}Filter]`);
        this.elemApplyBtn = $(`[c-id=${this.id}ApplyBtn]`);
        this.elemInput = $(`[c-id=${this.id}Input]`);
        this.elemCheckboxArea = $($(`[c-id=${this.id}FilterOptions]`).children()[1]);
        this.elemInputValue = $(`[c-id=${this.id}Value]`);
        if (this.defaultValue) {
            this.elemInputValue.text(this.getPlaceholder(this.defaultValue.filter((v) => v.checked)));
        }
        $(window).click((event) => {
            if (!$(event.target).parents(`[c-id=${this.id}]`).length) {
                $(`[c-id=${this.id}]`).removeClass("open");
            }
        });
        this.elemFilter.on("click", (e) => {
            const elem = $(`[c-id=${this.id}]`);
            elem.hasClass("open")
                ? elem.removeClass("open")
                : elem.addClass("open");
        });
        this.elemApplyBtn.on("click", (e) => {
            e.preventDefault();
            const checkedOptions = this.options.filter((option) => {
                return $(`[c-id=${option.id}Option]`).prop("checked");
            });
            const inputValue = this.getPlaceholder(checkedOptions);
            this.elemInputValue.text(inputValue);
            this.elem.removeClass("open");
            this.elem.addClass("active");
            this.onApply(checkedOptions);
        });
        this.elemInput.keypress((e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                this.elemApplyBtn.click();
            }
        });
        for (let i = 0; i < this.options.length; i++) {
            const option = this.options[i];
            const defaultOptionValue = (_a = this.defaultValue) === null || _a === void 0 ? void 0 : _a.find(x => x.id === option.id);
            const checkedProp = (this.defaultValue && (defaultOptionValue === null || defaultOptionValue === void 0 ? void 0 : defaultOptionValue.checked))
                ? "checked='true'"
                : "";
            this.elemCheckboxArea.append(`<div class="option m-menu-item" c-id="${option.id}MenuItem">
                    <span>${option.label}</span>
                    <input type="checkbox" class="k-checkbox" ${checkedProp} c-id="${option.id}Option" />
                </div>`);
            $(`[c-id="${option.id}MenuItem"]`).on("click", (e) => {
                const elem = $(`[c-id=${option.id}Option]`);
                const isChecked = elem.prop("checked");
                elem.prop("checked", !isChecked);
            });
        }
    }
    getPlaceholder(checkedOptions) {
        if (checkedOptions.length === 0) {
            return "---";
        }
        if (checkedOptions.length === this.options.length) {
            return "All";
        }
        return `${checkedOptions.length} Selected`;
    }
}

const TICKET_OPEN_ICON = `
            <svg xmlns="http://www.w3.org/2000/svg" width="" height="" viewBox="0 0 16 16" fill="none">
                <g clip-path="url(#clip0_1694_67684)">
                    <path d="M8.00004 14.6667C11.682 14.6667 14.6667 11.682 14.6667 8C14.6667 4.318 11.682 1.33333 8.00004 1.33333C4.31804 1.33333 1.33337 4.318 1.33337 8C1.33337 11.682 4.31804 14.6667 8.00004 14.6667Z" stroke="#99A29E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </g>
                <defs>
                    <clipPath id="clip0_1694_67684">
                        <rect width="16" height="16" fill="white"/>
                    </clipPath>
                </defs>
            </svg>
        `;
const TICKET_CLOSED_ICON = `
        <svg xmlns="http://www.w3.org/2000/svg" width="" height="" viewBox="0 0 16 16" fill="none">
            <g clip-path="url(#clip0_1694_67698)">
                <path d="M8.00004 14.6667C11.682 14.6667 14.6667 11.682 14.6667 8C14.6667 4.318 11.682 1.33334 8.00004 1.33334C4.31804 1.33334 1.33337 4.318 1.33337 8C1.33337 11.682 4.31804 14.6667 8.00004 14.6667Z" fill="#00E67E" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M5.33337 8L7.33337 10L10.6667 6" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </g>
            <defs>
                <clipPath id="clip0_1694_67698">
                    <rect width="16" height="16" fill="white"/>
                </clipPath>
            </defs>
        </svg>
        `;
const TICKET_IN_PROGRESS_ICON = `
            <svg xmlns="http://www.w3.org/2000/svg" width="" height="" viewBox="0 0 16 16" fill="none">
                <g clip-path="url(#clip0_1694_67691)">
                    <path d="M8.00004 14.6667C11.682 14.6667 14.6667 11.682 14.6667 8C14.6667 4.318 11.682 1.33333 8.00004 1.33333C4.31804 1.33333 1.33337 4.318 1.33337 8C1.33337 11.682 4.31804 14.6667 8.00004 14.6667Z" stroke="#F5D90A" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M8.00001 12.6667C10.5774 12.6667 12.6667 10.5774 12.6667 8C12.6667 5.4226 10.5774 3.33333 8.00001 3.33333C7.99998 4.66666 8.00001 10 8.00001 12.6667Z" fill="#F5D90A"/>
                </g>
                <defs>
                    <clipPath id="clip0_1694_67691">
                        <rect width="16" height="16" fill="white"/>
                    </clipPath>
                </defs>
            </svg>
        `;
const TICKET_CANCELED_ICON = `
    <svg xmlns="http://www.w3.org/2000/svg" width="" height="" viewBox="0 0 16 16" fill="none">
        <g clip-path="url(#clip0_3616_3557)">
            <path d="M7.99992 14.6671C11.6819 14.6671 14.6666 11.6824 14.6666 8.00041C14.6666 4.31841 11.6819 1.33374 7.99992 1.33374C4.31792 1.33374 1.33325 4.31841 1.33325 8.00041C1.33325 11.6824 4.31792 14.6671 7.99992 14.6671Z" fill="#99A29E" stroke="#99A29E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M10 6.00049L6 10.0005M6 6.00049L10 10.0005" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </g>
        <defs>
            <clipPath id="clip0_3616_3557">
                <rect width="16" height="16" fill="white" transform="translate(0 0.000488281)"/>
            </clipPath>
        </defs>
    </svg>
    `;
const TICKET_DUP_ICON = `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
        <g clip-path="url(#clip0_3616_3564)">
            <path d="M7.99992 14.6671C11.6819 14.6671 14.6666 11.6824 14.6666 8.00041C14.6666 4.31841 11.6819 1.33374 7.99992 1.33374M7.99992 14.6671C4.31792 14.6671 1.33325 11.6824 1.33325 8.00041C1.33325 4.31841 4.31792 1.33374 7.99992 1.33374M7.99992 14.6671V1.33374" stroke="#99A29E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </g>
        <defs>
            <clipPath id="clip0_3616_3564">
                <rect width="16" height="16" fill="white" transform="translate(0 0.000488281)"/>
            </clipPath>
        </defs>
    </svg>
    `;
const TICKET_STATUS_ICON_MAP = {
    1: TICKET_OPEN_ICON,
    2: TICKET_CLOSED_ICON,
    3: TICKET_IN_PROGRESS_ICON,
    5: TICKET_CANCELED_ICON,
    6: TICKET_DUP_ICON
};
const LOW_PRIORITY = `
    <svg width="" height="" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="Group 1">
            <g id="Vector">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M0 11.0005L0 8.90049C-2.41411e-08 8.40343 0.447715 8.00049 1 8.00049C1.55228 8.00049 2 8.40343 2 8.90049V11.0005C2 11.4975 1.55228 11.9005 0.999999 11.9005C0.447715 11.9005 1.03614e-07 11.4975 0 11.0005Z" fill="#99A29E"/>
            </g>
            <path id="Vector_2" fill-rule="evenodd" clip-rule="evenodd" d="M11 12.0005C10.4477 12.0005 10 11.508 10 10.9005L10 1.10049C10 0.492976 10.4477 0.000488308 11 0.000488281C11.5523 0.000488255 12 0.492976 12 1.10049V10.9005C12 11.508 11.5523 12.0005 11 12.0005Z" fill="#303633"/>
            <path id="Vector_3" fill-rule="evenodd" clip-rule="evenodd" d="M6 12.0505C5.44772 12.0505 5 11.5804 5 11.0005L5 5.05049C5 4.47059 5.44772 4.00049 6 4.00049C6.55228 4.00049 7 4.47059 7 5.05049V11.0005C7 11.5804 6.55228 12.0505 6 12.0505Z" fill="#303633"/>
        </g>
    </svg>
    `;
const MEDIUM_PRIORITY = `
        <svg width="" height="" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M2 13.0005L2 10.9005C2 10.4034 2.44771 10.0005 3 10.0005C3.55228 10.0005 4 10.4034 4 10.9005V13.0005C4 13.4975 3.55228 13.9005 3 13.9005C2.44772 13.9005 2 13.4975 2 13.0005Z" fill="#99A29E"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M13 14.0005C12.4477 14.0005 12 13.508 12 12.9005L12 3.10049C12 2.49298 12.4477 2.00049 13 2.00049C13.5523 2.00049 14 2.49298 14 3.10049V12.9005C14 13.508 13.5523 14.0005 13 14.0005Z" fill="#303633"/>
            <path fill-rule="evenodd" clip-rule="evenodd" d="M8 14.0505C7.44772 14.0505 7 13.5804 7 13.0005L7 7.05049C7 6.47059 7.44772 6.00049 8 6.00049C8.55228 6.00049 9 6.47059 9 7.05049V13.0005C9 13.5804 8.55228 14.0505 8 14.0505Z" fill="#99A29E"/>
        </svg>
    `;
const HIGH_PRIORITY = `
    <svg width="" height="" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" clip-rule="evenodd" d="M2 13.0005L2 10.9005C2 10.4034 2.44771 10.0005 3 10.0005C3.55228 10.0005 4 10.4034 4 10.9005V13.0005C4 13.4975 3.55228 13.9005 3 13.9005C2.44772 13.9005 2 13.4975 2 13.0005Z" fill="#99A29E"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M13 14.0005C12.4477 14.0005 12 13.508 12 12.9005L12 3.10049C12 2.49298 12.4477 2.00049 13 2.00049C13.5523 2.00049 14 2.49298 14 3.10049V12.9005C14 13.508 13.5523 14.0005 13 14.0005Z" fill="#99A29E"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M8 14.0505C7.44772 14.0505 7 13.5804 7 13.0005L7 7.05049C7 6.47059 7.44772 6.00049 8 6.00049C8.55228 6.00049 9 6.47059 9 7.05049V13.0005C9 13.5804 8.55228 14.0505 8 14.0505Z" fill="#99A29E"/>
    </svg>

    `;
const CRITICAL_PRIORITY = `
    <svg width="" height="" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect y="0.000488281" width="16" height="16" rx="2" fill="#FF6369"/>
        <path d="M8 4.50049V9.00049M8 11.5005V11.0005" stroke="#141716" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    `;
const TICKET_PRIORITY_ICON_MAP = {
    1: LOW_PRIORITY,
    2: MEDIUM_PRIORITY,
    3: HIGH_PRIORITY,
    4: CRITICAL_PRIORITY,
};
const TICKET_LABEL_ICON = `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"  fill="none">
        <path d="M4.5 1.5H2C1.72386 1.5 1.5 1.72386 1.5 2V4.5C1.5 4.77614 1.72386 5 2 5H4.5C4.77614 5 5 4.77614 5 4.5V2C5 1.72386 4.77614 1.5 4.5 1.5Z" stroke="#99A29E" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M10 1.5H7.5C7.22386 1.5 7 1.72386 7 2V4.5C7 4.77614 7.22386 5 7.5 5H10C10.2761 5 10.5 4.77614 10.5 4.5V2C10.5 1.72386 10.2761 1.5 10 1.5Z" stroke="#99A29E" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M10 7H7.5C7.22386 7 7 7.22386 7 7.5V10C7 10.2761 7.22386 10.5 7.5 10.5H10C10.2761 10.5 10.5 10.2761 10.5 10V7.5C10.5 7.22386 10.2761 7 10 7Z" stroke="#99A29E" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M4.5 7H2C1.72386 7 1.5 7.22386 1.5 7.5V10C1.5 10.2761 1.72386 10.5 2 10.5H4.5C4.77614 10.5 5 10.2761 5 10V7.5C5 7.22386 4.77614 7 4.5 7Z" stroke="#99A29E" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    `;
const SITE_ICON = `
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
        <path d="M10 5C10 8 6 11 6 11C6 11 2 8 2 5C2 3.93913 2.42143 2.92172 3.17157 2.17157C3.92172 1.42143 4.93913 1 6 1C7.06087 1 8.07828 1.42143 8.82843 2.17157C9.57857 2.92172 10 3.93913 10 5Z" stroke="#99A29E" stroke-linecap="round" stroke-linejoin="round"/>
        <path d="M6 6.5C6.82843 6.5 7.5 5.82843 7.5 5C7.5 4.17157 6.82843 3.5 6 3.5C5.17157 3.5 4.5 4.17157 4.5 5C4.5 5.82843 5.17157 6.5 6 6.5Z" stroke="#99A29E" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    `;

class MenuGroup {
    constructor(id) {
        this.id = id;
        this.init();
    }
    init() {
        $(`[c-id=${this.id}Header]`).on("click", this.openMenuGroup.bind(this));
        const menuItems = $(`[c-id=${this.id}] .m-nav-item`).get();
        menuItems.forEach((menuItem, index) => {
            const isSelected = $(menuItem).attr("aria-current") === "true";
            if (isSelected) {
                this.openMenuGroup();
                $(`[c-id=${this.id}Header]`).addClass("is-active");
            }
            $(`[c-id=${this.id}Breadcrumbs]`).append(`
                    <svg xmlns="http://www.w3.org/2000/svg" width="6" height="6" viewBox="0 0 6 6" fill="none">
                        <circle cx="3" cy="3" r="2.5" fill="${isSelected ? 'var(--color-icon-accent)' : 'var(--color-icon-secondary)'}" />
                    </svg>
                `);
            if (index !== menuItems.length - 1) {
                $(`[c-id=${this.id}Breadcrumbs]`).append(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="6" height="30" viewBox="0 0 2 16" fill="none">
                            <path d="M1 0.5V15.5" stroke="var(--color-icon-secondary)" />
                        </svg>
                    `);
            }
        });
    }
    openMenuGroup() {
        $(`[c-id=${this.id}]`).toggleClass("is-open");
        $(`[c-id=${this.id}Chevron]`).toggleClass("flip");
    }
}

class MinerActivityList extends OptiFleetService {
    constructor(id) {
        super();
        this.target = $(`#miner-activity-list-${id}`);
    }
    init(minerId) {
        this.minerId = minerId;
        this.loadActivity();
    }
    loadActivity() {
        this.get(`/MinerActivity?minerId=${this.minerId}`).then((resp) => {
            if (!resp.success) {
                this.target.find("table.activity-list tbody").text("Error loading activity...");
                return;
            }
            if (resp.activities.length === 0) {
                this.target.find(".no-activity-section").addClass("active");
                return;
            }
            this.populateActivities(resp.activities);
        });
    }
    populateActivities(activities) {
        const activityListElem = this.target.find("table.activity-list tbody");
        activityListElem.empty();
        for (const activity of activities) {
            let activityTime = window.moment.utc(activity.time).local();
            activity.formattedTime = activityTime.format('h:mm:ss A');
            activity.formattedDate = activityTime.format('M/DD/YY');
            if (activity.subject == "IpAddress changed" && activity.after == "null") {
                activity.after = "Lease Expired";
            }
            switchMap(activity.type, {
                "TICKET": () => this.appendTicket(activityListElem, activity),
                "PROPERTY": () => this.appendProperty(activityListElem, activity),
                "COMMAND": () => this.appendCommand(activityListElem, activity),
                "BYPASS": () => this.appendBypass(activityListElem, activity)
            });
        }
    }
    appendTicket(activityList, activity) {
        const ticketElem = self.Mustache.to_html(MinerActivityTemplates.TICKET, activity);
        activityList.append(ticketElem);
    }
    appendProperty(activityList, activity) {
        const propertyElem = self.Mustache.to_html(MinerActivityTemplates.PROPERTY, activity);
        activityList.append(propertyElem);
    }
    appendCommand(activityList, activity) {
        const commandElem = self.Mustache.to_html(MinerActivityTemplates.COMMAND, activity);
        activityList.append(commandElem);
    }
    appendBypass(activityList, activity) {
        const bypassElem = self.Mustache.to_html(MinerActivityTemplates.BYPASS, activity);
        activityList.append(bypassElem);
    }
}
class MinerActivityTemplates {
}
MinerActivityTemplates.TICKET = `
            <tr class="m-table-row">
                <td class="m-table-cell activity-row">
                    <div>
                        <span class="m-heading is-size-m">{{subject}}</span>
                        <span class="inner-text is-size-xs">by</span>
                        <span class="m-heading is-size-m">{{username}}</span>
                        <span class="inner-text is-size-xs">  {{formattedTime}} &nbsp;&nbsp; {{formattedDate}}</span>
                    </div>
                    {{#resolutionTime}}
                    <div class="ticket-lifetime m-box">
                        <div class="ticket-header">
                            <span class="m-heading is-size-l">Ticket lifetime</span> <span class="ticket-lifetime-time">{{resolutionTime}}</span>
                        </div>
                        <div class="ticket-resolution">
                            {{resolutionNote}}
                        </div>
                    </div>
                    {{/resolutionTime}}
                </td>
            </tr>
        `;
MinerActivityTemplates.PROPERTY = `
            <tr class="m-table-row">
                <td class="m-table-cell">
                    <span class="m-heading is-size-m">{{subject}}</span>
                    <span class="inner-text is-size-xs">from</span>
                    <span class="m-heading is-size-m">{{before}}</span>
                    <span class="inner-text is-size-xs">to</span>
                    <span class="m-heading is-size-m">{{after}}</span>
                    <span class="inner-text is-size-xs">by</span>
                    <span class="m-heading is-size-m">{{username}}</span>
                    <span class="inner-text is-size-xs"> {{formattedTime}} &nbsp;&nbsp; {{formattedDate}}</span>
                </td>
            </tr>
        `;
MinerActivityTemplates.COMMAND = `
            <tr class="m-table-row">
                <td class="m-table-cell">
                    <span class="m-heading is-size-m">{{subject}}</span> by <span class="m-heading is-size-m">{{username}}</span> <span class="inner-text is-size-xs"> {{formattedTime}} &nbsp;&nbsp; {{formattedDate}}</span>
                </td>
            </tr>
        `;
MinerActivityTemplates.BYPASS = `
            <tr class="m-table-row">
                <td class="m-table-cell">
                    {{subject}} <span class="inner-text is-size-xs"> {{formattedTime}} &nbsp;&nbsp; {{formattedDate}}</span>
                </td>
            </tr>
        `;

class MinerTagsPanel extends OptiFleetPage {
    constructor(id) {
        super();
        this.target = $(`#${id}`);
    }
    init(miner) {
        this.miner = miner;
        this.target.find(".manage-tags-link").attr("href", `/Content/Administration/SiteDetails?siteId=${miner.siteId}&tab=Tags`);
        this.load();
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.loadTags().then(() => {
                this.populateAttachedTags(this.attachedTags);
            });
        });
    }
    openTagEdit() {
        this.populateSelectableTags(this.availableTags);
        this.toggleTagEdit();
    }
    closeTagEdit() {
        this.toggleTagEdit();
    }
    toggleTagEdit(state) {
        let desiredState = state !== null && state !== void 0 ? state : !$('.tags-edit').is(':visible');
        if (desiredState === true) {
            this.target.find(".tags-view").hide();
            this.target.find(".tags-edit").show();
        }
        else {
            this.target.find(".tags-view").show();
            this.target.find(".tags-edit").hide();
        }
    }
    toggleNoTagsDisplay(state) {
        let desiredState = state !== null && state !== void 0 ? state : !$('.no-miner-tags-display').is(':visible');
        if (desiredState === true) {
            this.target.find(".no-miner-tags-display").show();
            this.target.find(".miner-tags-display").hide();
        }
        else {
            this.target.find(".no-miner-tags-display").hide();
            this.target.find(".miner-tags-display").show();
        }
    }
    loadTags() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([
                this.get(`/Miner/Tags?minerId=${this.miner.id}`),
                this.get(`/Tags?siteId=${this.miner.siteId}`)
            ]).then((resp) => {
                let minerTagsResponse = resp[0];
                let availableTagsResponse = resp[1];
                if (!minerTagsResponse.success || !availableTagsResponse.success) {
                    this.showErrorMessage("Failed to load tags.");
                    return;
                }
                if (minerTagsResponse.tags.length == 0) {
                    this.toggleNoTagsDisplay();
                }
                else {
                    this.toggleNoTagsDisplay(false);
                }
                this.attachedTags = minerTagsResponse.tags;
                this.availableTags = availableTagsResponse.tags;
            });
        });
    }
    populateSelectableTags(tags) {
        const tagListElem = this.target.find(".tag-select");
        tagListElem.empty();
        for (const tag of tags) {
            let selectableTag = $(self.Mustache.to_html(MinerTagTemplates.SELECTABLE_TAG, tag));
            if (this.attachedTags.some(attachedTag => attachedTag.id === tag.id)) {
                selectableTag.find("input").prop("checked", true);
            }
            tagListElem.append(selectableTag);
        }
    }
    populateAttachedTags(tags) {
        const tagListElem = this.target.find(".tag-list");
        tagListElem.empty();
        for (const tag of tags) {
            tagListElem.append(self.Mustache.to_html(MinerTagTemplates.ATTACHED_TAG, tag));
        }
    }
    navToSiteSetup() {
        window.location.assign(`/Content/Administration/SiteDetails?siteId=${this.miner.siteId}&tab=Tags`);
    }
    saveSelectedTags() {
        let tagsToAttach = [];
        let tagsToUnattach = [];
        for (const tag of this.availableTags) {
            let selected = this.target.find(`#selectableTagId-${tag.id}`).is(':checked');
            if (selected && !this.attachedTags.some(attachedTag => attachedTag.id === tag.id)) {
                tagsToAttach.push(tag);
            }
            if (!selected && this.attachedTags.some(attachedTag => attachedTag.id === tag.id)) {
                tagsToUnattach.push(tag);
            }
        }
        var promises = [];
        if (tagsToUnattach.length > 0) {
            promises.push(this.delete(`/Tags/Miners`, { minerIds: [this.miner.id], tagIds: tagsToUnattach.map(tag => tag.id) }));
        }
        if (tagsToAttach.length > 0) {
            for (const tag of tagsToAttach) {
                promises.push(this.post(`Tags/${tag.id}/Miners`, { tagId: tag.id, minerIds: [this.miner.id] }));
            }
        }
        this.toggleBusy(true);
        Promise.all(promises).then((respList) => {
            this.load().then(() => {
                this.closeTagEdit();
                this.toggleBusy(false);
                if (respList.some(resp => !resp.success)) {
                    this.showErrorMessage("Failed to save miner tags changes!");
                }
            });
        });
    }
    removeAttachedTag(tagId) {
        this.confirm("Remove Tag", `Are you sure you want to remove this tag?`, () => {
            this.toggleBusy(true);
            this.delete(`/Tags/Miners`, { minerIds: [this.miner.id], tagIds: [tagId] })
                .then((resp) => {
                this.load().then(() => {
                    this.toggleBusy(false);
                    if (!resp.success) {
                        this.showErrorMessage("Failed to remove tag from miner.");
                        return;
                    }
                });
            });
        });
    }
}
class MinerTagTemplates {
}
MinerTagTemplates.ATTACHED_TAG = `
        <m-stack horizontal align-center>
            <m-icon name="trash-2" status="success" siz
            e="l" onclick="im.minerTagsPanel.removeAttachedTag({{id}})" style="cursor: pointer; color: var(--color-text-accent);"></m-icon>
            <m-text size="l">{{name}}</m-text>
        </m-stack>
    `;
MinerTagTemplates.SELECTABLE_TAG = `
        <div class="m-checkbox" style="position: relative;">
            <input type="checkbox" id="selectableTagId-{{id}}"/>
            <label class="m-label" for="selectableTagId-{{id}}">{{name}}</label>
        </div>
    `;

var MinerDetailsPanelViewVariant;
(function (MinerDetailsPanelViewVariant) {
    MinerDetailsPanelViewVariant[MinerDetailsPanelViewVariant["CreateTicket"] = 1] = "CreateTicket";
    MinerDetailsPanelViewVariant[MinerDetailsPanelViewVariant["DetailTicket"] = 2] = "DetailTicket";
    MinerDetailsPanelViewVariant[MinerDetailsPanelViewVariant["MinerDetails"] = 3] = "MinerDetails";
})(MinerDetailsPanelViewVariant || (MinerDetailsPanelViewVariant = {}));
/** This class should be inherited */
class OpMinerDetailsPanel extends OptiFleetService {
    constructor(canEdit = false) {
        super();
        this.canEdit = canEdit;
        this.minerInfoUrl = "/MinerInfo";
        this.minerSearchParams = undefined;
        try {
            if (canEdit) {
                document.getElementById("changeMinerButton").onclick = this.handleChangeMinerClick.bind(this);
            }
            document.getElementById("changeMinerSearch").onkeyup = this.handleChangeMinerSearch.bind(this);
            document.getElementById("gotoAllTickets").onclick = this.gotoAllTickets.bind(this);
            document.getElementById("gotoMiner").onclick = this.goToMiner.bind(this);
        }
        catch (_a) {
            console.debug("TicketDetails: Could not find elements to bind to.");
        }
    }
    gotoAllTickets() {
        OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${this.view.minerId}&active_tab=Tickets`);
    }
    goToMiner() {
        OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${this.view.minerId}`);
    }
    open() {
        this.reset();
        $(".ticket-details-panel").addClass("active");
    }
    close() {
        this.reset();
        $(".ticket-details-panel").removeClass("active");
        $(".ticket-details-column").removeClass("active");
        $("#createTicketMinersPanel").removeClass("active");
        $("#allMinerDetails").removeClass("active");
        $("#createTicketHeaderCorner").removeClass("active");
        $("#ticketDetailsHeaderCorner").removeClass("active");
        $("#createTicketMinersPanel").html("");
    }
    openCreateTicketView(initData) {
        this.open();
        this.view = new CreateTicketPanelView();
        this.view.open(initData);
    }
    openTicketDetailsView(initData, handleRefresh, updateTicketMiner) {
        this.open();
        const minerUpdateFn = (minerId) => {
            updateTicketMiner(minerId).then(() => {
                this.handleChangeMinerClick();
            });
        };
        this.view = new DetailTicketMinerPanelView(handleRefresh, minerUpdateFn.bind(this));
        this.view.open(initData);
    }
    openMinerDetailsView(initData) {
        this.open();
        this.view = new MinerDetailsPanelView();
        this.fetchMiner(initData.minerId).then((resp) => {
            this.view.open(initData);
            this.updateData(resp);
        });
    }
    fetchMiner(minerId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.get(`${this.minerInfoUrl}?minerId=${minerId}`);
        });
    }
    updateData(data) {
        if (!this.view)
            return;
        if (this.view.viewType === MinerDetailsPanelViewVariant.MinerDetails &&
            typeof data === "number") {
            this.fetchMiner(data).then((resp) => {
                this.view.updateData(resp);
            });
            return;
        }
        this.view.updateData(data);
    }
    closeMinerSearchPanel() {
        const panel = $("#changeMinerPanel");
        panel.hasClass("active") && panel.removeClass("active");
        $("#changeMinerSearch").text("");
    }
    reset() {
        if (!this.view)
            return;
        this.closeMinerSearchPanel();
        this.view.reset();
    }
    getReturnData() {
        if (!this.view)
            return;
        return this.view.getReturnData();
    }
    handleChangeMinerClick() {
        const panel = $("#changeMinerPanel");
        const column = $(".ticket-details-column");
        if (panel.hasClass('active')) {
            panel.removeClass('active');
            !this.view.minerId && column.removeClass('active');
        }
        else {
            panel.addClass('active');
            !this.view.minerId && column.addClass('active');
        }
    }
    handleChangeMinerSearch(e) {
        const ss = $("#changeMinerSearch").val();
        this.minerSearchParams = {
            timer: Date.now(),
            searchString: ss
        };
        setTimeout(this._handleMinerSearch.bind(this, ss), 250);
    }
    _handleMinerSearch(ss) {
        var _a;
        if (ss === ((_a = this.minerSearchParams) === null || _a === void 0 ? void 0 : _a.searchString)) {
            const list = this.view.miners
                .filter(val => { var _a; return val.ipAddress !== "" && ((_a = val.ipAddress) === null || _a === void 0 ? void 0 : _a.includes(ss.toLowerCase())); })
                .sort((a, b) => { return a.ipAddress.length < b.ipAddress.length ? -1 : 1; })
                .slice(0, 4);
            this.view.renderMinerDropdownList(list);
        }
    }
}
/** maps IMinerInfo key to corresponding HTML id*/
const TicketDetailsKeyMap = {
    // miner metrics
    "fans": "fanSpeed",
    "chipTemps": "temperature",
    "uptime": "uptime",
    // miner details
    "minerName": "minerName",
    "modelName": "model",
    "serialNumber": "serialNumber",
    "companyName": "company",
    "subcustomerName": "subcustomer",
    "ipAddress": "ipAddress",
    "statusName": "status",
    "zoneName": "zone",
    "powerModeName": "powerMode",
};

class RackRow {
    constructor(parentEl, initData) {
        this.parentEl = parentEl;
        this.initData = initData;
        this.mustache = window.Mustache;
        this.render();
    }
    getRow() {
        // get row name and num slots
        return {
            name: this.rowEl.find(".row-name").val() || this.rowEl.find(".row-name").text(),
            numSlots: this.rowEl.find(".slot-count").val()
        };
    }
    rowName() {
        return this.rowEl.find(".row-name").val() || this.rowEl.find(".row-name").text();
    }
    render() {
        const rowData = {
            rowName: this.initData.rowDetails.name,
            readOnly: this.initData.readOnly,
            calledFromRackCard: this.initData.calledFromRackCard
        };
        const rowTemplate = $(this.mustache.to_html(ROW_TEMPLATE, rowData));
        if (this.initData.calledFromRackCard && this.initData.invertedRows) {
            this.parentEl.prepend(rowTemplate);
        }
        else {
            this.parentEl.append(rowTemplate);
        }
        this.rowEl = rowTemplate;
        // cant add event handlers to readonly row
        try {
            //this.rowEl.find(".add-row").click(() => this.addRow());
            this.rowEl.find(".del-row").click(() => this.deleteRow());
            this.rowEl.find(".slot-count").change(this.updateSlots.bind(this));
            this.rowEl.find(".row-name").change(this.handleRename.bind(this)); // Add this line
        }
        catch (_a) { }
        this.updateSlots();
    }
    updateSlots(event) {
        var _a;
        const currentSlotCount = Number(this.rowEl.find(".slot-count").val());
        const slotListEl = this.rowEl.find(".slot-squares");
        slotListEl.empty();
        let num = event ? currentSlotCount : this.initData.rowDetails.numSlots;
        num = Math.min(num, RackRow.MAX_SLOTS_PER_ROW);
        if (event && num != this.initData.rowDetails.numSlots) {
            const rowName = this.rowEl.find(".row-name").val() || this.rowEl.find(".row-name").text();
            this.initData.onNumSlotChange(rowName, num);
        }
        for (let i = 0; i < num; i++) {
            const slotTemplate = $(this.mustache.to_html(SLOT_TEMPLATE));
            if ((_a = this.initData.rowDetails.filledSlotIndeces) === null || _a === void 0 ? void 0 : _a.includes(i)) {
                slotTemplate.addClass('highlighted');
            }
            slotListEl.append(slotTemplate);
        }
        this.updateSlotCount();
    }
    updateRowName(rowName) {
        this.rowEl.find(".row-name").text(rowName);
    }
    updateSlotCount() {
        const count = this.rowEl.find(".slot-squares").children().length;
        this.rowEl.find(".slot-count").val(count);
        this.initData.onUpdateSlotCount();
    }
    deleteRowHtml() {
        this.rowEl.remove();
    }
    getSlotCount() {
        try {
            return Number(this.rowEl.find(".slot-count").val());
        }
        catch (_a) {
            return this.initData.rowDetails.numSlots;
        }
    }
    invalidate() {
        const errorEl = this.rowEl.find(".row-name").first();
        errorEl.addClass("is-error");
        errorEl.focus();
    }
    validate() {
        this.rowEl.find(".row-name").first().removeClass("is-error");
    }
    handleRename() {
        const newName = this.rowName();
        if (this.initData.onRenameRow) {
            this.initData.onRenameRow(this.initData.rowDetails.name, newName, this.initData.rowDetails.numSlots);
        }
    }
}
RackRow.DEFAULT_SLOT_COUNT = 10;
RackRow.MAX_SLOTS_PER_ROW = 50;
RackRow.DEFAULT_ROW = {
    name: "1",
    numSlots: RackRow.DEFAULT_SLOT_COUNT
};
const ROW_TEMPLATE = `
        <div class="row m-stack is-horizontal is-align-center is-size-s">

        {{^readOnly}}
            <span class="del-row">
                <m-icon size="xl" name="minus-circle" class="back-icon"></m-icon>
            </span>
            <!--<span class="add-row">
                <m-icon size="xl" name="plus-circle" class="back-icon"></m-icon>
            </span> -->
            <span class="is-text is-size-s">ROW</span>
            <input type="text" class="m-input has-text-centered row-name" placeholder="1" data-form-type="other" value="{{rowName}}" />
            <span class="is-text is-size-s" style="text-wrap:nowrap;"># SLOTS</span>
            <input type="number" min="1" max="50" class="m-input has-text-centered slot-count" name="count" placeholder="10" value="0" data-form-type="other" />
        {{/readOnly}}

        {{#readOnly}}
            <p class="row-name">{{rowName}}</p>
        {{/readOnly}}

            <div class="slot-squares m-stack is-horizontal"></div>

        </div>
    `;
const SLOT_TEMPLATE = `
        <div class="square"></div>
    `;

/** This class should be inherited */
class CreateTicketPanelView {
    constructor() {
        this.viewType = MinerDetailsPanelViewVariant.CreateTicket;
        this.linkedMiners = [];
    }
    open(initData) {
        $("#minerName").text("Add a miner to the ticket");
        $("#minerButtonPanelHeader").text("Add miner");
        $("#createTicketMinersPanel").addClass("active");
        $(".go-to-miner-page").removeClass("active");
        this.miners = initData.allMiners;
        this.linkedMiners = initData.preselectedMiners;
        this.renderMinerDropdownList();
        this.linkedMiners.forEach(id => {
            this.onAddNewMiner(id);
        });
    }
    // ** MINER SEARCH FUNCTIONS **
    renderMinerDropdownList(miners) {
        $("#changeMinerList").html("");
        const minerList = miners || this.miners.slice(0, 4);
        minerList.forEach(miner => {
            const template = self.Mustache.to_html(TicketDetailTemplates.CHANGE_MINER_LIST_ITEM, miner);
            $("#changeMinerList").append(template);
            const el = document.getElementById(`changeMinerItem${miner.minerId}`);
            el.onclick = this.onAddNewMiner.bind(this, miner.minerId);
        });
    }
    onAddNewMiner(minerId, e) {
        const miner = this.miners.find(m => m.minerId === minerId);
        if (e && this.linkedMiners.includes(miner.minerId))
            return;
        const template = self.Mustache.to_html(TicketDetailTemplates.ADD_MINER_CHIP, miner);
        $("#createTicketMinersPanel").append(template);
        const chipEl = document.getElementById(`removeMiner${minerId}`);
        chipEl.onclick = this.removeNewMiner.bind(this, minerId);
        this.linkedMiners.push(minerId);
    }
    removeNewMiner(minerId) {
        $(`#addedMinerItem${minerId}`).remove();
        this.linkedMiners = this.linkedMiners.filter(m => m !== minerId);
    }
    reset() {
    }
    updateData(data) {
        return;
    }
    getReturnData() {
        return {
            selectedMiners: this.linkedMiners
        };
    }
}

/** This class should be inherited */
class DetailTicketMinerPanelView {
    constructor(handleRefresh, updateTicketMiner) {
        this.handleRefresh = handleRefresh;
        this.updateTicketMiner = updateTicketMiner;
        this.viewType = MinerDetailsPanelViewVariant.DetailTicket;
    }
    open(initData) {
        $("#minerButtonPanelHeader").text("Change miner");
        $("#allMinerDetails").addClass("active");
        $(".go-to-miner-page").addClass("active");
        this.miners = initData.allMiners;
        this.renderMinerDropdownList();
    }
    // ** MINER SEARCH FUNCTIONS **
    renderMinerDropdownList(miners) {
        $("#changeMinerList").html("");
        const minerList = miners || this.miners.slice(0, 4);
        minerList.forEach(miner => {
            const template = self.Mustache.to_html(TicketDetailTemplates.CHANGE_MINER_LIST_ITEM, miner);
            $("#changeMinerList").append(template);
            const el = document.getElementById(`changeMinerItem${miner.minerId}`);
            el.onclick = this.onSelectNewMiner.bind(this, miner.minerId);
        });
    }
    onSelectNewMiner(minerId) {
        // make call to mutate ticket
        this.updateTicketMiner && this.updateTicketMiner(minerId);
        //this.handleChangeMinerClick();
    }
    populateData(resp) {
        if (resp.miner.id) {
            this.minerId = resp.miner.id;
            this.populateMinerDetails(resp.miner);
            this.populateRecentTickets(resp.recentTickets);
            this.populateErrorCodes(resp.miner);
            this.populateActivePoolInfo(resp.miner);
        }
    }
    populateRecentTickets(recentTickets) {
        if (!recentTickets || recentTickets.length === 0) {
            $("#recentTicketsSection").css("display", "none");
            return;
        }
        recentTickets.forEach((ticket, index) => {
            const buff = btoa(unescape(encodeURIComponent(TICKET_STATUS_ICON_MAP[ticket.statusId])));
            ticket['icon'] = buff;
            const template = self.Mustache.to_html(TicketDetailTemplates.RECENT_TICKET, ticket);
            $(`#recentTickets`).append(template);
            const el = document.getElementById(`recentTicket${ticket.id}`);
            //$(el.querySelector(".recent-ticket-icon")).html(ticket['icon'])
            el.onclick = this.onRecentTicketSelect.bind(this, ticket.id);
        });
    }
    onRecentTicketSelect(ticketId) {
        this.ticketId = ticketId;
        this.reset();
        this.handleRefresh();
    }
    resetMinerDetails() {
        for (const id of Object.values(TicketDetailsKeyMap)) {
            if (id == "minerName") {
                $(`#${id}`).text("Link miner to ticket");
            }
            $(`#${id}`).text("--");
        }
    }
    populateMinerDetails(miner) {
        var _a;
        for (const [key, id] of Object.entries(TicketDetailsKeyMap)) {
            let value;
            switch (key) {
                case "chipTemps":
                    value = derive(() => {
                        if (miner.pcbTemps === null || miner.pcbTemps.length === 0) {
                            return "--";
                        }
                        return miner.chipTemps
                            .sort((a, b) => a.hashboard < b.hashboard ? a.hashboard : b.hashboard)
                            .map(x => x.temperature)
                            .join(" / ");
                    });
                    break;
                case "fans":
                    value = miner.fans;
                    break;
                case "ipAddress":
                    miner.ipAddress = (_a = miner.ipAddress) !== null && _a !== void 0 ? _a : "Lease Expired";
                    value = MinerGridColumnTemplates.getIpAddressColumnTemplate(miner);
                    $(`#ipAddressInfoRow`).html(value);
                    continue;
                default:
                    value = miner[key];
                    break;
            }
            $(`#${id}`).text(value || "--");
        }
        this.populateHashingPotentialBar(miner);
        this.populateMinerLocationInfo(miner);
    }
    populateMinerLocationInfo(miner) {
        if (miner.locationName === "Unassigned") {
            return;
        }
        const standardizedLocation = miner.locationName.split("-");
        let zone, rack, row, position;
        if (standardizedLocation.length !== 4) {
            [zone, row, position] = standardizedLocation;
            /*TODO: @jchauvin FIX*/
            if (!row) {
                return;
            }
            var nonAlphaIndex = row.substring(0).search(/[^A-Za-z]/);
            [rack, row] = [row.slice(0, nonAlphaIndex), row.slice(nonAlphaIndex)];
        }
        else {
            [zone, rack, row, position] = standardizedLocation;
        }
        $("#rackRowPosition").text(`${rack} / ${row} / ${position}`);
    }
    populateActivePoolInfo(miner) {
        if (miner.activePoolIndex === null)
            return;
        const index = miner.activePoolIndex + 1;
        const pool = miner[`pool${index}`];
        const account = miner[`account${index}`];
        const worker = miner[`worker${index}`];
        $("#activePool").text(pool);
        $("#activeAccount").text(account);
        $("#activeWorker").text(worker);
    }
    resetActivePoolInfo() {
        $("#activePool").text("--");
        $("#activeAccount").text("--");
        $("#activeWorker").text("--");
    }
    resetMinerLocationInfo() {
        $("#rackRowPosition").text("--");
    }
    populateErrorCodes(miner) {
        if (miner.errorList.length === 0) {
            $('#errorCodesPlaceholder').append("<div class='info-row-value'>None</div>");
            return;
        }
        miner.errorList.forEach(err => {
            const template = self.Mustache.to_html(TicketDetailTemplates.ERROR_ROW, err);
            $('#errorCodesPlaceholder').append(template);
        });
    }
    populateHashingPotentialBar(miner) {
        if (miner.hashRatePercent < 0.1) {
            miner.hashRatePercent = 0.1;
        }
        $('#minerHashrate').text(miner.formattedHashrate).css("width", `${miner.hashRatePercent * 100}%`);
        $('#minerExpectedHashrate').text(miner.formattedExpectedHashrate);
    }
    updateData(data) {
        this.populateData(data);
    }
    getReturnData() {
        return;
    }
    reset() {
        $("#recentTickets").html("");
        $("#errorCodesPlaceholder").html("");
        this.resetMinerLocationInfo();
        this.resetMinerDetails();
        this.resetActivePoolInfo();
        $("#changeMinerPanel").hasClass("active") && $("#changeMinerPanel").removeClass("active");
    }
}

/** This class should be inherited */
class MinerDetailsPanelView {
    constructor() {
        this.viewType = MinerDetailsPanelViewVariant.MinerDetails;
        this.miners = [];
        // hide elements
        $("#changeMinerSection").css("display", "none");
        $("#createTicketMinersPanel").css("display", "none");
        $("#recentTicketsSection").css("display", "none");
        $("#minerMetricsSection").css("display", "none");
        $("#allMinerDetails").addClass("active");
    }
    open(initData) {
    }
    populateData(miner) {
        if (miner.id) {
            this.minerId = miner.id;
            this.populateMinerDetails(miner);
            this.populateActivePoolInfo(miner);
            this.populateErrorCodes(miner);
        }
    }
    resetMinerDetails() {
        for (const id of Object.values(TicketDetailsKeyMap)) {
            if (id == "minerName") {
                $(`#${id}`).text("Link miner to ticket");
            }
            $(`#${id}`).text("--");
        }
        $("#autoPoolChip").removeClass("active");
    }
    populateMinerDetails(miner) {
        var _a;
        for (const [key, id] of Object.entries(TicketDetailsKeyMap)) {
            let value;
            switch (key) {
                case "temperature":
                    value = miner.temperature !== 0.0 ?
                        String(Math.ceil(miner.temperature)) + " " + String.fromCharCode(176) + "C"
                        :
                            "--";
                    break;
                case "fans":
                    value = miner.fans;
                    break;
                case "subcustomerName":
                    value = miner[key];
                    !value && $(`#${id}`).parent().hide();
                    break;
                case "ipAddress":
                    miner.ipAddress = (_a = miner.ipAddress) !== null && _a !== void 0 ? _a : "Lease Expired";
                    value = MinerGridColumnTemplates.getIpAddressColumnTemplate(miner);
                    $(`#ipAddressInfoRow`).html(value);
                    continue;
                default:
                    value = miner[key];
                    break;
            }
            $(`#${id}`).text(value || "--");
        }
        this.populateHashingPotentialBar(miner);
        this.populateMinerLocationInfo(miner);
    }
    populateMinerLocationInfo(miner) {
        if (miner.locationName === "Unassigned") {
            return;
        }
        const standardizedLocation = miner.locationName.split("-");
        let zone, rack, row, position;
        if (standardizedLocation.length !== 4) {
            [zone, row, position] = standardizedLocation;
            var nonAlphaIndex = row.substring(0).search(/[^A-Za-z]/);
            [rack, row] = [row.slice(0, nonAlphaIndex), row.slice(nonAlphaIndex)];
        }
        else {
            [zone, rack, row, position] = standardizedLocation;
        }
        $("#rackRowPosition").text(`${rack} / ${row} / ${position}`);
    }
    resetMinerLocationInfo() {
        $("#rackRowPosition").text("--");
    }
    populateErrorCodes(miner) {
        $('#errorCodesPlaceholder').children().remove();
        if (miner.errorList.length === 0) {
            $('#errorCodesPlaceholder').append("<div class='info-row-value'>None</div>");
            return;
        }
        miner.errorList.forEach(err => {
            const template = self.Mustache.to_html(TicketDetailTemplates.ERROR_ROW, err);
            $('#errorCodesPlaceholder').append(template);
        });
    }
    populateHashingPotentialBar(miner) {
        if (miner.hashRatePercent < 0.1) {
            miner.hashRatePercent = 0.1;
        }
        $('#minerHashrate').text(miner.formattedHashrate).css("width", `${miner.hashRatePercent * 100}%`);
        $('#minerExpectedHashrate').text(miner.formattedExpectedHashrate);
    }
    populateActivePoolInfo(miner) {
        if (miner.activePoolIndex === null)
            return;
        const index = miner.activePoolIndex + 1;
        const pool = miner[`pool${index}`];
        const account = miner[`account${index}`];
        const worker = miner[`worker${index}`];
        $("#activePool").text(pool);
        $("#activeAccount").text(account);
        $("#activeWorker").text(worker);
        if (miner.approvedPoolConfigId !== null) {
            $("#autoPoolChip").addClass("active");
        }
    }
    updateData(miner) {
        this.minerId = miner.individualMiner.id;
        this.minerInfo = miner.individualMiner;
        this.populateData(miner.individualMiner);
    }
    getReturnData() {
        return;
    }
    reset() {
        $("#recentTickets").html("");
        $("#errorCodesPlaceholder").html("");
        this.resetMinerLocationInfo();
        this.resetMinerDetails();
        $("#changeMinerPanel").hasClass("active") && $("#changeMinerPanel").removeClass("active");
    }
}

/** This class should be inherited */
class OpModalBase {
    /**
     * This method should be overriden in the inheriting component. It should gather relevant data (if any) and call the `postSubmitHandler(data?)` passed by
     * the instantiating module
     * @param data - data that needs to be passed to the instantiating module for submission
     */
    preSubmitHandler() {
        console.log("You must implement modal.preSubmitHandler");
        return;
    }
    ;
    /**
     * This method should be overriden in the inheriting component. It should initialize the modal content with dynamic data
     * @param initData
     */
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    /**
     * This method should be overriden in the inheriting component. It should clean up the modal before closing
     * @param initData
     */
    beforeClose() {
        return;
    }
    /**
     * this method should be called in the underlying page to apply needed logic after the modal closes
     */
    afterClose() {
        return;
    }
    /**
     *
     * @param Id must be referenced by the ID attribute in the Modal UserControl
     */
    constructor(Id) {
        this.Id = Id;
        this.elem = document.getElementById(Id);
        if (this.elem === null)
            return;
        //this.preSubmitHandler = postSubmitHandler;
        // init offclick, close, cancel, and submit buttons
        this.initModalButtons();
        // determine type of modal content and save
        this.initModalContent();
    }
    initModalButtons() {
        this.elem.onclick = this.close.bind(this);
        let submitButton = $(this.elem).find(".submit-button").get(0);
        submitButton.onclick = this.preSubmitHandler.bind(this);
    }
    /**
     * Do not pass initData if the modal is already initialized with data
     * @param initData
     */
    open(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isOpen = true;
            this.elem.style.display = "flex";
            this.toggleModalBusy(false);
            if (initData) {
                this.toggleModalBusy(true);
                yield this.beforeOpen(initData);
                this.toggleModalBusy(false);
            }
        });
    }
    close(e, forceClose = false) {
        var _a, _b;
        const shouldClose = ((_a = e === null || e === void 0 ? void 0 : e.target.closest(".close-icon")) === null || _a === void 0 ? void 0 : _a.id)
            || ((_b = e === null || e === void 0 ? void 0 : e.target.closest(".cancel-button")) === null || _b === void 0 ? void 0 : _b.id)
            || (e === null || e === void 0 ? void 0 : e.target.className) === "modal-wrapper";
        if (forceClose || shouldClose) {
            this._close();
        }
    }
    /**
     * Close without checks and close handlers
     * @param e
     * @param forceClose
     */
    _close() {
        this.beforeClose();
        this.isOpen = false;
        this.elem.style.display = "none";
        this.afterClose();
    }
    initModalContent() {
        const contentId = document.getElementById(`${this.elem.id}Content`);
        this.contentElem = contentId.firstElementChild;
    }
    toggleModalBusy(val) {
        val ?
            $(".modal-busy").removeClass("active")
            :
                $(".modal-busy").addClass("active");
    }
    toggleSubmitButton(val) {
        val ?
            $(".submit-button-wrapper").removeClass("disable-submit-button")
            :
                $(".submit-button-wrapper").addClass("disable-submit-button");
    }
    allowSubmitButton() {
        $(".submit-button-wrapper").removeClass("disable-submit-button");
    }
}

class OpApprovedPoolConfigModal extends OpModalBase {
    constructor(page, Id) {
        super(Id);
        this.poolConfigUrl = "/ApprovedPoolConfigs";
        this.page = page;
    }
    preSubmitHandler() {
        this.save();
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.siteId = initData.siteId;
            return this.populateModal(initData);
        });
    }
    beforeClose() {
        this.reset();
    }
    populateModal(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const poolsDataSource = initData.whitelistedPoolsData.whitelistedPools.map((pool, i) => {
                    return {
                        id: pool.poolUrl,
                        value: pool.poolUrl
                    };
                });
                let dataSource = new self.kendo.data.DataSource({
                    data: poolsDataSource
                });
                this.setDropdown($("#pool1Url"), dataSource);
                this.setDropdown($("#pool2Url"), dataSource);
                this.setDropdown($("#pool3Url"), dataSource);
                const accountsDataSource = initData.whitelistedPoolsData.whitelistedSubaccounts.map((subaccount, i) => {
                    return {
                        id: subaccount.subaccount,
                        value: subaccount.subaccount
                    };
                });
                dataSource = new self.kendo.data.DataSource({
                    data: accountsDataSource
                });
                this.setDropdown($("#pool1Account"), dataSource);
                this.setDropdown($("#pool2Account"), dataSource);
                this.setDropdown($("#pool3Account"), dataSource);
                if (!initData.poolConfig) {
                    this.approvedPoolConfigId = null;
                    this.reset();
                    resolve();
                    return;
                }
                this.approvedPoolConfigId = initData.poolConfig.approvedPoolConfigId;
                this.siteId = initData.siteId;
                initData.poolConfig.enforcePoolConfig ? $("#EnforceConfig").attr("checked", "checked") : "";
                const pool1 = initData.poolConfig.poolSettings.find(p => p.index === 0);
                const pool2 = initData.poolConfig.poolSettings.find(p => p.index === 1);
                const pool3 = initData.poolConfig.poolSettings.find(p => p.index === 2);
                $("#configName").val(initData.poolConfig.poolConfigName);
                if (pool1) {
                    $("#pool1Url").data("kendoDropDownList").value(pool1.url);
                    $("#pool1Url").data("kendoDropDownList").refresh();
                    $("#pool1Account").data("kendoDropDownList").value(pool1.account);
                    $("#pool1Account").data("kendoDropDownList").refresh();
                }
                if (pool2) {
                    $("#pool2Url").data("kendoDropDownList").value(pool2.url);
                    $("#pool2Url").data("kendoDropDownList").refresh();
                    $("#pool2Account").data("kendoDropDownList").value(pool2.account);
                    $("#pool2Account").data("kendoDropDownList").refresh();
                }
                if (pool3) {
                    $("#pool3Url").data("kendoDropDownList").value(pool3.url);
                    $("#pool3Url").data("kendoDropDownList").refresh();
                    $("#pool3Account").data("kendoDropDownList").value(pool3.account);
                    $("#pool3Account").data("kendoDropDownList").refresh();
                }
                resolve();
            });
        });
    }
    setDropdown(ele, dataSource) {
        ele.kendoDropDownList({
            dataTextField: "id",
            dataValueField: "value",
            dataSource: dataSource,
            height: 200,
            autoWidth: true,
            change: (e) => {
            }
        });
    }
    reset() {
        $(".error-label").removeClass("active");
        $("#configName").val("");
        $("#pool1Url").val("");
        $("#pool2Url").val("");
        $("#pool3Url").val("");
        $("#pool1Account").val("");
        $("#pool2Account").val("");
        $("#pool3Account").val("");
        this.toggleModalBusy(false);
    }
    save() {
        $(".error-label").removeClass("active");
        const isValid = this.validatePools();
        if (!isValid) {
            return;
        }
        const saveData = this.getSaveData();
        if (!saveData) {
            return;
        }
        this.toggleModalBusy(true);
        this.page.post(this.poolConfigUrl, saveData)
            .then((resp) => {
            this.toggleModalBusy(false);
            if (!resp.success) {
                if (resp.message === "There is already an Approved Pool Configuration using this name.") {
                    $("#duplicateConfigNameError").addClass("active");
                    return;
                }
                this.page.showErrorMessage("Something went wrong while saving.  Please try again.");
                return;
            }
            this.page.showSuccessMessage("Pool configurations saved!");
            this.onSave();
            this._close();
        });
    }
    validatePools() {
        let isValid = true;
        const config = $("#configName").val().trim();
        if (config.length === 0) {
            $("#configNameError").addClass("active");
            isValid = false;
        }
        if (!this.isValidPool(1)) {
            isValid = false;
        }
        if (!this.isValidPool(2)) {
            isValid = false;
        }
        if (!this.isValidPool(3)) {
            isValid = false;
        }
        return isValid;
    }
    isValidPool(poolIndex) {
        let isValid = true;
        const poolUrl = $(`#pool${poolIndex}Url`).data("kendoDropDownList").value().trim();
        const poolAccount = $(`#pool${poolIndex}Account`).data("kendoDropDownList").value().trim();
        if (poolUrl.length === 0) {
            $(`#pool${poolIndex}UrlError`).addClass("active");
            isValid = false;
        }
        if (poolAccount.length === 0) {
            $(`#pool${poolIndex}AccountError`).addClass("active");
            isValid = false;
        }
        return isValid;
    }
    getSaveData() {
        const pools = [];
        const pool1 = this.getPoolSaveData(1);
        const pool2 = this.getPoolSaveData(2);
        const pool3 = this.getPoolSaveData(3);
        if (pool1) {
            pools.push(pool1);
        }
        if (pool2) {
            pools.push(pool2);
        }
        if (pool3) {
            pools.push(pool3);
        }
        if (pools.length === 0) {
            return null;
        }
        return {
            approvedPoolConfig: {
                poolConfigName: $("#configName").val().trim(),
                enforcePoolConfig: $("#EnforceConfig").prop('checked'),
                poolSettings: pools,
                approvedPoolConfigId: this.approvedPoolConfigId,
                siteId: this.siteId
            }
        };
    }
    getPoolSaveData(poolNum) {
        var _a;
        const poolUrl = (_a = $(`#pool${poolNum}Url`).data("kendoDropDownList").value()) === null || _a === void 0 ? void 0 : _a.toString().trim();
        const poolAccount = $(`#pool${poolNum}Account`).data("kendoDropDownList").value().trim();
        return {
            index: poolNum - 1,
            url: poolUrl,
            account: poolAccount
        };
    }
}

class OpWhitelistedPoolsModal extends OpModalBase {
    constructor(page, Id, parentEl) {
        super(Id);
        this.parentEl = parentEl;
        this.whitelistedPoolsUrl = "/WhitelistedPools";
        this.whitelistedPoolsData = null;
        this.addPoolData = [];
        this.mustache = window.Mustache;
        this.page = page;
        this.deleteModal = new OpConfirmationModal("DeleteModal", this.deleteData.bind(this));
        this.parentEl.find("#add-pool-link").on("click", this.HandleAddPoolClick.bind(this));
        this.parentEl.find("#add-subaccount-link").on("click", this.HandleAddSubaccountClick.bind(this));
    }
    preSubmitHandler() {
        this.save();
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.siteId = initData.siteId;
            this.reset();
            return this.populateModal(initData);
        });
    }
    beforeClose() {
        this.refresh();
    }
    HandleAddPoolClick(e) {
        this.parentEl.find('.wp-add-pool-row').addClass('active');
    }
    HandleDeletePoolClick(whitelistedPoolId) {
        this.deleteDataObj = {
            Id: whitelistedPoolId,
            requestType: "PoolUrl"
        };
        const initData = {
            primaryText: `Are you sure you want to delete this Pool Url?`,
            warningText: ""
        };
        this.deleteModal.open(initData);
    }
    HandleDeleteSubaccountClick(whitelistedSubaccountId) {
        this.deleteDataObj = {
            Id: whitelistedSubaccountId,
            requestType: "PoolAccount"
        };
        const initData = {
            primaryText: `Are you sure you want to delete this Subaccount?`,
            warningText: ""
        };
        this.deleteModal.open(initData);
    }
    AddPoolData(button) {
        const poolUrl = this.getData("poolUrlInput");
        if (!this.isValidPool(poolUrl, "Url"))
            return;
        const saveData = {
            WhitelistedPool: {
                siteId: this.siteId,
                poolUrl: poolUrl
            }
        };
        this.saveData(saveData, "poolUrl");
    }
    AddSubaccountData(button) {
        const subaccount = this.getData("subaccountInput");
        if (!this.isValidPool(subaccount, "Account"))
            return;
        const saveData = {
            WhitelistedSubaccount: {
                siteId: this.siteId,
                subaccount: subaccount
            }
        };
        this.saveData(saveData, "poolAccount");
    }
    refresh() {
        this.page.get(`${this.whitelistedPoolsUrl}?siteId=${this.siteId}`)
            .then((resp) => {
            this.whitelistedPoolsData = {
                whitelistedPools: resp.whitelistedPools,
                whitelistedSubaccounts: resp.whitelistedSubaccounts,
                siteId: this.siteId
            };
            this.reset();
            this.populateModal(this.whitelistedPoolsData);
        });
    }
    isValidPool(input, inputType) {
        let isValid = true;
        if (input.length === 0 && inputType == "Url") {
            $(`#validPoolUrlError`).addClass("active");
            isValid = false;
        }
        if (input.length === 0 && inputType == "Account") {
            $(`#validPoolAccountError`).addClass("active");
            isValid = false;
        }
        return isValid;
    }
    getData(input) {
        var _a;
        const data = (_a = $(`#${input}`).val()) === null || _a === void 0 ? void 0 : _a.toString().trim();
        $(`#${input}`).val("");
        return data;
    }
    saveData(saveData, requestType) {
        this.toggleModalBusy(true);
        this.page.post(this.whitelistedPoolsUrl, saveData)
            .then((resp) => {
            if (!resp.success) {
                if (resp.message)
                    $(`#${requestType}Error`).text(resp.message);
                $(`#${requestType}Error`).addClass("active");
                this.toggleModalBusy(false);
                return;
            }
            this.refresh();
        });
    }
    deleteData() {
        this.toggleModalBusy(true);
        let Id;
        if (this.deleteDataObj.requestType == "PoolUrl")
            Id = { whitelistedPoolId: this.deleteDataObj.Id };
        else
            Id = { whitelistedSubaccountId: this.deleteDataObj.Id };
        this.page.delete(this.whitelistedPoolsUrl, Id)
            .then((resp) => {
            if (!resp.success) {
                $(`#delete${this.deleteDataObj.requestType}Error`).text(resp.message);
                $(`#delete${this.deleteDataObj.requestType}Error`).addClass("active");
                this.toggleModalBusy(false);
                return;
            }
            this.refresh();
        });
    }
    HandleAddSubaccountClick(e) {
        this.parentEl.find('.wp-add-subaccount-row').addClass('active');
    }
    populateModal(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let poolUrlListElement = this.parentEl.find("#pool-url-list");
                initData.whitelistedPools.forEach((poolConfig) => {
                    const data = {
                        elementId: poolConfig.whitelistedPoolId,
                        poolUrl: poolConfig.poolUrl
                    };
                    let poolItem = this.mustache.to_html(POOL_ITEM_TEMPLATE, data);
                    poolUrlListElement.append(poolItem);
                    poolUrlListElement.find("#deleteButton-" + poolConfig.whitelistedPoolId).on("click", (e) => this.HandleDeletePoolClick(poolConfig.whitelistedPoolId));
                });
                let subaccountListElement = this.parentEl.find("#subaccount-list");
                initData.whitelistedSubaccounts.forEach((wSubaccount) => {
                    const data = {
                        elementId: wSubaccount.whitelistedSubaccountId,
                        subaccount: wSubaccount.subaccount
                    };
                    let subaccountItem = this.mustache.to_html(SUBACCOUNT_ITEM_TEMPLATE, data);
                    subaccountListElement.append(subaccountItem);
                    subaccountListElement.find("#deleteButton-" + wSubaccount.whitelistedSubaccountId).on("click", (e) => this.HandleDeleteSubaccountClick(wSubaccount.whitelistedSubaccountId));
                });
                resolve(this.toggleModalBusy(false));
            });
        });
    }
    reset() {
        this.parentEl.find("#pool-url-list li").remove();
        this.parentEl.find("#subaccount-list li").remove();
        this.parentEl.find('.wp-add-pool-row').removeClass('active');
        this.parentEl.find('.wp-add-subaccount-row').removeClass('active');
        $(`#poolUrlError`).removeClass("active");
        $(`#poolAccountError`).removeClass("active");
        $(`#validPoolUrlError`).removeClass("active");
        $(`#validPoolAccountError`).removeClass("active");
        $(`#deletePoolUrlError`).removeClass("active");
        $(`#deletePoolAccountError`).removeClass("active");
        $(`#subaccountInput`).val("");
        $(`#poolUrlInput`).val("");
        this.toggleModalBusy(false);
    }
    save() {
    }
}
const POOL_ITEM_TEMPLATE = `
         <li id="PoolUrl-{{elementId}}">
            <m-icon id="deleteButton-{{elementId}}" name="trash-2" size="m" class="m-button-icon delete-pool-button"></m-icon>
            <span class="m-text">{{poolUrl}}</span>
        </li>
    `;
const SUBACCOUNT_ITEM_TEMPLATE = `
         <li id="SubAccount-{{elementId}}">
            <m-icon id="deleteButton-{{elementId}}" name="trash-2" size="m" class="m-button-icon delete-subaccount-button"></m-icon>
            <span class="m-text">{{subaccount}}</span>
        </li>
    `;

class BulkMinerMapModal extends OpModalBase {
    constructor(page, Id, submitHandler) {
        super(Id);
        this.bulkMinerMapUrl = "/BulkMinerMap";
        this.downloadableClass = "downloadable";
        this.page = page;
        this.downloadBtn = $(`#${Id}DownloadBtn`);
        this.fileInput = $(`#${this.Id}FileInput`);
        this.errTextarea = $(`#${this.Id}ErrorTextArea`);
        this.submitBtn = $(`#BulkMinerMapModal`).find(`#modalSubmitButton`);
        this.validateErrLabel = $(`#${this.Id}ErrorValidatingLabel`);
        this.validateBtn = $(`<button class="m-button" type="button">Validate</button>`);
        this.validateBtn.on("click", this.validateFile.bind(this));
        this.submitBtn.parent().append(this.validateBtn);
        this.submitBtn.hide();
        this.downloadBtn.on("click", this.download.bind(this));
        this.fileInput.change(this.handleFileInputChange.bind(this));
        this.toggleSubmitButton(false);
        this.validateErrLabel.hide();
    }
    preSubmitHandler() {
        this.toggleModalBusy(true);
        this.uploadFile().then((resp) => {
            this.toggleModalBusy(false);
            if (resp.success === false) {
                this.page.showErrorMessage("An error occured while uploading CSV");
                return;
            }
            this.page.showSuccessMessage(resp.message);
            this.close(null, true);
        });
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            this.siteId = initData;
            let downloadText = "Download";
            if (this.zoneName && this.zoneName != "")
                downloadText += ` for Zone ${this.zoneName}`;
            this.downloadBtn.text(downloadText);
        });
    }
    beforeClose() {
        this.reset();
    }
    handleFileInputChange() {
        this.toggleSubmitButton(true);
        this.validateBtn.show();
        this.submitBtn.hide();
        this.errTextarea.empty();
        this.validateErrLabel.hide();
    }
    uploadFile() {
        const file = $(`#${this.Id}FileInput`).prop('files')[0];
        const formData = new FormData();
        formData.append("File", file, file.name);
        const userId = localStorage.getItem("OptiFleetID");
        const companyFilter = JSON.parse(localStorage.getItem("selectedCompany"));
        var zone = this.zoneName ? `&Zone=${this.zoneName}` : "";
        return this.page.post(`${this.bulkMinerMapUrl}/Upload?SiteId=${this.siteId}&userId=${userId}&companyFilter=${companyFilter}${zone}`, formData);
    }
    validateFile() {
        this.toggleModalBusy(true);
        const file = $(`#${this.Id}FileInput`).prop('files')[0];
        const formData = new FormData();
        formData.append("File", file, file.name);
        const userId = localStorage.getItem("OptiFleetID");
        const companyFilter = JSON.parse(localStorage.getItem("selectedCompany"));
        this.page.post(`${this.bulkMinerMapUrl}/Validate?SiteId=${this.siteId}&Zone=${this.zoneName}&userId=${userId}&companyFilter=${companyFilter}`, formData)
            .then((resp) => {
            this.toggleModalBusy(false);
            if (resp.success === false) {
                this.errTextarea.text(resp.message);
                this.validateErrLabel.show();
            }
            if (resp.errors.length !== 0) {
                // errors in csv
                var content = [];
                resp.errors.forEach(err => {
                    if (!err.row) {
                        content.push(`${err.message}\n\n`);
                    }
                    else {
                        content.push(`(Line ${err.row}): ${err.message}\n\n`);
                    }
                });
                this.errTextarea.text(content.join(""));
                return;
            }
            // no errors in csv
            let text = "";
            var totalUpdates = resp.serialNumbers + resp.unassignments + resp.locationUpdates;
            if (totalUpdates == 0) {
                text += "No changes detected";
                this.validateBtn.hide();
            }
            else {
                if (resp.serialNumbers > 0)
                    text += `\nSerial numbers changed: ${resp.serialNumbers}`;
                if (resp.unassignments > 0)
                    text += `\nUnassignments: ${resp.unassignments}`;
                if (resp.locationUpdates > 0)
                    text += `\nLocations changed: ${resp.locationUpdates}`;
                text = "No errors found. Click Submit to continue.\n" + text;
                this.validateBtn.hide();
                if (this.zoneName && this.zoneName !== "")
                    this.submitBtn.text(`Submit for Zone ${this.zoneName}`);
                this.submitBtn.show();
            }
            this.errTextarea.text(text);
        });
    }
    download() {
        let url = `${this.bulkMinerMapUrl}/Download?SiteId=${this.siteId}`;
        url += this.zoneName ? `&Zone=${this.zoneName}` : "";
        this.page.get(url, undefined, true)
            .then((resp) => {
            var file = new Blob([resp.data], { type: 'text/csv;charset=utf-8' });
            var url = window.URL || window.webkitURL;
            var fileURL = url.createObjectURL(file);
            var a = document.createElement("a");
            a.href = fileURL;
            a.download = resp.headers['content-disposition'].match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/)[1].replaceAll('"', '');
            a.target = "_self";
            a.click();
            url.revokeObjectURL(fileURL);
        })
            .catch((err) => { console.log(err); });
    }
    reset() {
        this.fileInput.val(null);
        this.validateBtn.show();
        this.submitBtn.hide();
        this.errTextarea.empty();
        this.validateErrLabel.hide();
    }
}

class BulkMinerRenameModal extends OpModalBase {
    constructor(page, Id) {
        super(Id);
        this.renameUrl = "/BulkMinerRename/Rename";
        this.customersUrl = "/Customers";
        this.modalId = "BulkMinerRenameModal";
        this.minerIds = [];
        this.page = page;
        this.nameInputField = $("#nameFormat");
        this.errorMessage = $(`#${this.modalId}`).find("#errorMessage");
        this.alert = $(`#${this.modalId}`).find("#errorAlert");
        this.customerButton = $(`#${this.modalId}`).find("#customerButton");
        this.submitButton = $(`#${this.modalId}`).find("#modalSubmitButton");
        this.alert.hide();
        this.submitButton.prop("disabled", true);
    }
    addToInput(button) {
        event.preventDefault();
        this.nameInputField.val(this.nameInputField.val() + `{${button.innerHTML}}`);
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.siteId = initData.siteId;
            this.numMiners = initData.numMiners;
            this.minerIds = initData.minerIds ? initData.minerIds : [];
            this.checkCustomers(this.siteId);
            this.reset();
            if (this.siteId < 0) {
                this.submitButton.prop("disabled", true);
                this.alert.show();
                this.errorMessage.text("Must select a site");
                return;
            }
            this.alert.hide();
            this.submitButton.prop("disabled", false);
        });
    }
    ;
    preSubmitHandler() {
        return __awaiter(this, void 0, void 0, function* () {
            const format = this.nameInputField.val().toLowerCase();
            if (format.length === 0) {
                this.errorMessage.text("Miner name format cannot be empty");
                this.alert.show();
                return;
            }
            this.page.confirm("Rename Miners", `Are you sure you want to rename ${this.numMiners} miners?`, () => {
                this.toggleModalBusy(true);
                this.renameMiners(format).then(resp => {
                    if (!resp.success) {
                        this.toggleModalBusy(false);
                        this.errorMessage.text(resp.message);
                        this.alert.show();
                        return;
                    }
                    this.toggleModalBusy(false);
                    this.close(null, true);
                    this.page.showSuccessMessage(`Successfully renamed ${this.numMiners} miners`);
                });
            });
        });
    }
    beforeClose() {
        this.reset();
    }
    reset() {
        this.nameInputField.val("");
        this.errorMessage.text("");
        this.alert.hide();
    }
    renameMiners(format) {
        const userId = localStorage.getItem("OptiFleetID");
        const companyFilter = JSON.parse(localStorage.getItem("selectedCompany"));
        const req = {
            siteId: this.siteId,
            userId,
            companyFilter,
            minerIds: this.minerIds,
            nameFormat: format,
        };
        return this.page.post(`${this.renameUrl}`, req);
    }
    // Checks if the current company selection has sub customers, and if so, shows the button
    checkCustomers(siteId) {
        this.page.get(`${this.customersUrl}?siteId=${siteId}`).then((res) => {
            if (res.customers.length > 0) {
                this.customerButton.removeClass("hidden").addClass("active");
                return;
            }
            this.customerButton.addClass("hidden").removeClass("active");
        });
    }
}

class OpConfirmationModal extends OpModalBase {
    constructor(Id, submitHandler) {
        super(Id);
        if (submitHandler) {
            this.postSubmitHandler = submitHandler.bind(this);
        }
    }
    preSubmitHandler() {
        var _a;
        (_a = this.postSubmitHandler) === null || _a === void 0 ? void 0 : _a.call(this);
        this._close();
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryTextId = `#${this.elem.id}PrimaryText`;
            const warningTextId = `#${this.elem.id}WarningText`;
            const headingId = `#${this.elem.id}_HEADING`;
            $(primaryTextId).text(initData.primaryText);
            $(warningTextId).html(initData.warningText);
            if (initData.headingText) {
                $(headingId).text(initData.headingText);
            }
        });
    }
    setOnSubmit(submitHandler) {
        this.postSubmitHandler = submitHandler.bind(this);
    }
    /**  INIT DATA HELPER FUNCS for ConfirmationModal Variants **/
    static getRebootModalInitData(numMinersToReboot) {
        const isOverMax = numMinersToReboot > 9;
        const secondaryText = `Rebooting more than <span class="bold-warning">10 miners</span> could cause facility issues.Are you sure you want to reboot <span class="bold-warning">${MinerAdmin.SELECTED_MINER_IDS.length} miner(s)?</span>`;
        return {
            primaryText: `Are you sure you want to reboot ${numMinersToReboot} miner(s)?`,
            warningText: isOverMax ? secondaryText : ""
        };
    }
    static getDeleteModalInitData(numMinersToDelete) {
        return {
            primaryText: `Are you sure you want to delete ${numMinersToDelete} miner(s)?`,
            warningText: ""
        };
    }
    static getRestrictedRebootModalInitData(numMinersWithRestrictions) {
        return {
            primaryText: `Are you sure you want to reboot ${numMinersWithRestrictions} miner(s) with a restricted reboot in progress?`,
            warningText: "",
        };
    }
}

class LogFetchModal extends OpModalBase {
    constructor(page, Id, submitHandler) {
        super(Id);
        this.minerLogsUrl = "/MinerLogs";
        this.commandStatusUrl = "/CommandStatus";
        this.downloadableLogClass = "downloadable-log";
        this.page = page;
        this.fractionText = $(`#${Id}-frac`);
        this.progressText = $(`#${Id}-prog`);
        this.errorMsgLabel = $(`#${Id}-err-msg`);
        this.downloadBtn = $(`#LogFetchModal`).find(".submit-button");
        $(`#${this.Id}-complete-icon`).hide();
        $(`#${this.Id}-failed-icon`).hide();
        this.errorMsgLabel.hide();
    }
    preSubmitHandler() {
        return;
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            this.minerId = initData;
            this.page.post(`${this.minerLogsUrl}/Fetch`, { minerId: initData })
                .then((resp) => {
                if (!resp.success) {
                    this.handleLogFetchFail("There was an issue initiating log fetch command.");
                    return;
                }
                this.commandStatusInterval = this.createCommandStatusInterval(resp.commandId, 2000, 120000);
            });
        });
    }
    beforeClose() {
        this.reset();
    }
    createCommandStatusInterval(commandId, delay, timeout) {
        var startTime = new Date().getTime();
        return setInterval(() => {
            if (new Date().getTime() - startTime > timeout) {
                clearInterval(this.commandStatusInterval);
                this.handleLogFetchFail("Deadline exceeded. Verify miner is online and responsive.");
                return;
            }
            this.page.get(`${this.commandStatusUrl}?CommandId=${commandId}`)
                .then((resp) => {
                if (!resp.success) {
                    clearInterval(this.commandStatusInterval);
                    this.handleLogFetchFail(`${resp.message}. Verify miner is online and responsive.`);
                    return;
                }
                this.fractionText.text(`(${resp.currentStep}/${resp.stepCount})`);
                this.progressText.text(resp.progressMessage);
                if (resp.currentStep == resp.stepCount) {
                    clearInterval(this.commandStatusInterval);
                    $(`#${this.Id}-spinner-icon`).hide();
                    $(`#${this.Id}-complete-icon`).show();
                    this.setDownloadable();
                }
            });
        }, delay);
    }
    handleLogFetchFail(errMsg) {
        $(`#${this.Id}-spinner-icon`).hide();
        $(`#${this.Id}-failed-icon`).show();
        this.progressText.text("Oops. Somethsing went wrong.");
        this.errorMsgLabel.text(errMsg);
        this.errorMsgLabel.show();
    }
    setDownloadable() {
        var userId = localStorage.getItem("OptiFleetID");
        var companyFilter = JSON.parse(localStorage.getItem("selectedCompany"));
        var filePath = `${this.page.baseUrl}${this.minerLogsUrl}/Download?Minerid=${this.minerId}&userId=${userId}&companyFilter=${companyFilter}`;
        this.downloadBtn.wrap(`<a href="${filePath}" class="${this.downloadableLogClass}" download></a>`);
        this.downloadBtn.removeClass("dis-btn");
    }
    reset() {
        clearInterval(this.commandStatusInterval);
        $(`#${this.Id}-spinner-icon`).show();
        $(`#${this.Id}-complete-icon`).hide();
        $(`#${this.Id}-failed-icon`).hide();
        this.errorMsgLabel.text("Failed to fetch logs.");
        this.fractionText.text("(0/3)");
        this.progressText.text("Initializing request");
        this.errorMsgLabel.hide();
        this.downloadBtn.addClass("dis-btn");
        if (this.downloadBtn.parent().is(`.${this.downloadableLogClass}`)) {
            this.downloadBtn.unwrap();
        }
    }
}

class OpMinerEditorModal extends OpModalBase {
    constructor(page, id, postSubmitHandler) {
        super(id);
        this.page = page;
        this.postSubmitHandler = postSubmitHandler;
        this.upsertMinerUrl = "/UpsertMiner";
        this.saveNoteUrl = "/MinerNote";
        this.id = id;
        this.initInputs();
    }
    preSubmitHandler() {
        this.toggleModalBusy(true);
        this.saveMiner().then(success => {
            this.toggleModalBusy(false);
            if (!success)
                return;
            if (this.postSubmitHandler) {
                this.postSubmitHandler(this.miner);
            }
            this._close();
        });
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const isMinerId = typeof initData === "string";
            if (isMinerId && String((_a = this.miner) === null || _a === void 0 ? void 0 : _a.id) === initData)
                return;
            if (isMinerId) {
                // fetch data (initData is MinerId)
                this.minerId = parseInt(initData);
                yield this.getMinerInfo(this.minerId).then((miner) => { this.miner = miner; });
            }
            else {
                // init data is IMinerInfo
                this.minerId = initData.id;
                this.miner = initData;
            }
            let promises = [];
            promises.push(this.getStatuses());
            promises.push(this.getAvailableLocations());
            yield Promise.all(promises);
            if (this.miner) {
                this.setInputValues(this.miner);
            }
        });
    }
    beforeClose() {
        //this.reset()
    }
    preloadMiner(minerId) {
        if (!minerId)
            return;
        this.minerId = minerId;
        this.toggleModalBusy(true);
        this.beforeOpen(minerId.toString()).then(() => {
            this.toggleModalBusy(false);
        });
    }
    saveMiner() {
        if (!this.minerId) {
            return new Promise(() => false);
        }
        let miner = this.getNewMiner();
        if (!this.validateNewMiner(miner)) {
            return new Promise(() => false);
        }
        return this.page.post(this.upsertMinerUrl, { miner: miner }).then((resp) => {
            if (!resp.successful) {
                this.page.showErrorMessage(resp.errorMessage);
                return false;
            }
            this.checkForComment();
            this.page.showSuccessMessage("Saved!");
            this.miner = Object.assign(Object.assign({}, this.miner), miner);
            return true;
        });
    }
    checkForComment() {
        const comment = this.commentInput.val().trim();
        if (comment.length === 0) {
            return;
        }
        this.enterComment(comment);
    }
    enterComment(comment) {
        const savedata = {
            minerId: this.minerId,
            note: comment,
        };
        this.page.post(this.saveNoteUrl, savedata).then(() => {
            if (this.reloadComments) {
                this.reloadComments();
            }
        });
    }
    validateNewMiner(miner) {
        $(`#${this.id}-lblMinerNameError`)
            .toggle(miner.minerName.length == 0 || miner.minerName.length > 100);
        $(`#${this.id}-lblSerialNumberError`)
            .toggle(miner.serialNumber.length > 100);
        $(`#${this.id}-lblStatusError`)
            .toggle(isNaN(miner.statusId) || miner.statusId < 1);
        $(`#${this.id}-lblLocationError`)
            .toggle(isNaN(miner.locationId) || miner.locationId === 0);
        return $(".error-label:visible").length === 0;
    }
    getNewMiner() {
        return {
            id: this.minerId,
            minerName: this.minerNameInput.val(),
            serialNumber: this.serialNumberInput.val(),
            locationId: parseInt(this.locationInput.value()),
            statusId: this.getStatus()
        };
    }
    setInputValues(miner) {
        this.statusInput.setDataSource(new kendo.data.DataSource({ data: this.statuses }));
        this.locationInput.setDataSource(new kendo.data.DataSource({ data: this.availableLocations }));
        this.minerNameInput.val(miner.minerName);
        this.serialNumberInput.val(miner.serialNumber);
        this.statusInput.value(miner.statusId.toString());
        this.locationInput.value(miner.locationId.toString());
        this.locationInput.text(miner.locationName);
        this.locationInput.refresh();
        $(".comment-field").removeClass("active");
        this.handleStatus(miner);
    }
    handleStatus(miner) {
        if (miner.statusName === "Online") {
            this.statusInput.enable(false);
            this.statusInput.text("Online");
            return;
        }
        this.statusInput.enable(true);
    }
    getStatus() {
        if (this.miner.statusName === "Online") {
            return this.miner.statusId;
        }
        return parseInt(this.statusInput.value());
    }
    reset() {
        if (this.miner) {
            this.setInputValues(this.miner);
        }
        $(`#${this.id}-lblMinerNameError`).hide();
        $(`#${this.id}-lblSerialNumberError`).hide();
        $(`#${this.id}-lblStatusError`).hide();
        $(`#${this.id}-lblLocationError`).hide();
        $(".comment-field").removeClass("active");
    }
    initInputs() {
        this.minerNameInput = $(`#${this.id}-minerNameInput`);
        this.commentInput = $(`#${this.id}-commentInput`);
        this.serialNumberInput = $(`#${this.id}-serialNumberInput`);
        this.statusInput = $(`#${this.id}-statusInput`)
            .kendoDropDownList({
            dataTextField: "displayName",
            dataValueField: "statusId",
            change: (e) => this.handleStatusChange(e)
        })
            .data("kendoDropDownList");
        this.locationInput = $(`#${this.id}-locationInput`)
            .kendoDropDownList({
            dataTextField: "text",
            dataValueField: "value",
            filter: "contains",
            value: "Unassigned",
            text: "Unassigned",
            virtual: {
                itemHeight: 26,
                valueMapper: (value) => {
                    var data = {};
                    value = $.isArray(value) ? value : [value];
                    for (var idx = 0; idx < value.length; idx++) {
                        data["values[" + idx + "]"] = value[idx];
                    }
                    return data;
                },
            },
        })
            .data("kendoDropDownList");
    }
    handleStatusChange(e) {
        const status = this.statusInput.text();
        if (status.toLowerCase() === "online" || status.toLowerCase() === "offline") {
            return;
        }
        $(".comment-field").addClass("active");
    }
    /** DATA FETCHING **/
    getMinerInfo(minerId) {
        return new Promise((resolve, reject) => {
            if (!minerId) {
                reject("No Miner Id Given");
            }
            // update to get only specific miner and not list
            this.page.get(`/MinerInfo?MinerId=${minerId}`).then((res) => {
                if (!res.individualMiner) {
                    reject("No miner found");
                }
                resolve(res.individualMiner);
            });
        });
    }
    getStatuses() {
        return new Promise((resolve, reject) => {
            this.page.get("/Statuses").then((resp) => {
                this.statuses = resp.statuses.filter(status => status.displayName !== "Online");
                resolve();
            });
        });
    }
    getAvailableLocations() {
        return new Promise((resolve, reject) => {
            this.page.get(`/MinerPropertyList?type=AvailableCompanyLocation&siteId=${this.miner.siteId}`).then((resp) => {
                this.availableLocations = resp.list;
                if (this.miner && this.miner.locationId != -1) {
                    this.availableLocations.splice(1, 0, {
                        text: this.miner.locationName,
                        value: this.miner.locationId.toString(),
                    });
                }
                resolve();
            });
        });
    }
}

class OpMinerOwnerAssignmentModal extends OpModalBase {
    constructor(page, Id, submitHandler) {
        super(Id);
        this.page = page;
        this.mustache = window.Mustache;
        this.minerIds = [];
        if (submitHandler) {
            this.postSubmitHandler = submitHandler.bind(this);
        }
        this.initModal();
    }
    preSubmitHandler() {
        if ($(".submit-button-wrapper").hasClass("disable-submit-button")) {
            return;
        }
        this.save().then(() => {
            var _a;
            (_a = this.postSubmitHandler) === null || _a === void 0 ? void 0 : _a.call(this);
        });
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            // load all customers
            const res = yield this.page.get("/CustomersNew");
            this.customerSelection = [{
                    "id": null,
                    "name": "No Customer"
                }];
            this.customerSelection = this.customerSelection.concat(res.customers);
            this.minerIds = initData.selectedMinerIds;
            this.populateDropdown();
            this.resetNewCustomer();
        });
    }
    initModal() {
        const data = { inputId: `${this.contentElem.id}Input` };
        const template = self.Mustache.to_html(MAO_TEMPLATE, data);
        $(this.contentElem).append(template);
    }
    populateDropdown() {
        $(`#${this.contentElem.id}Input`);
        $(`#${this.contentElem.id}Input`).kendoDropDownList({
            dataTextField: "name",
            dataValueField: "id",
            dataSource: this.customerSelection,
            height: 200,
        });
    }
    setOnSubmit(submitHandler) {
        this.postSubmitHandler = submitHandler.bind(this);
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            const ClientId = $(`#${this.contentElem.id}Input`).data("kendoDropDownList").value();
            const data = { ClientId, minerIds: this.minerIds };
            yield this.page.post("/AssignMinerClients", data).then((res) => {
                if (!res.success) {
                    this.page.showErrorMessage("Unable to assign miners");
                    return;
                }
                this.page.showSuccessMessage("Miner assignments saved!");
                this._close();
            });
        });
    }
    resetNewCustomer() {
        $(`#${this.contentElem.id}Input-addCustomer`).show();
        $(`#${this.contentElem.id}Input-newCustomer`).css('visibility', 'hidden');
        $(`#${this.contentElem.id}Input`).data('kendoDropDownList').enable(true);
        $(`#${this.contentElem.id}Input-newCustomerName`).val('');
        $(`#${this.contentElem.id}Input-newCustomerError`).text('').hide();
    }
    getNewCustomerName() {
        let newCustomerName = $(`#${this.contentElem.id}Input-newCustomerName`).val();
        if (newCustomerName.length < 2 || newCustomerName.length > 100) {
            return {
                isValid: false,
                Name: newCustomerName
            };
        }
        return {
            isValid: true,
            Name: newCustomerName
        };
    }
    addCustomer() {
        this.toggleSubmitButton(false);
        $(`#${this.contentElem.id}Input-addCustomer`).hide();
        $(`#${this.contentElem.id}Input-newCustomer`).css('visibility', 'visible');
        $(`#${this.contentElem.id}Input`).data('kendoDropDownList').enable(false);
    }
    saveCustomer() {
        return __awaiter(this, void 0, void 0, function* () {
            let customerNameData = this.getNewCustomerName();
            if (this.customerSelection.filter(x => x.name == customerNameData.Name).length > 0) {
                this.resetNewCustomer();
                $(`#${this.contentElem.id}Input`).data('kendoDropDownList').select(li => li.name == customerNameData.Name);
                return;
            }
            if (!customerNameData.isValid) {
                return;
            }
            this.toggleModalBusy(true);
            const resp = yield this.page.post("/CustomersNew", customerNameData);
            if (resp.success) {
                this.customerSelection = this.customerSelection.concat(resp.customers);
                let ddl = $(`#${this.contentElem.id}Input`).data('kendoDropDownList');
                ddl.dataSource.pushCreate(resp.customers[0]);
                ddl.refresh();
                ddl.select(li => li.name == resp.customers[0].name);
                this.resetNewCustomer();
            }
            else if (resp.message) {
                $(`#${this.contentElem.id}Input-newCustomerError`).text(resp.message).show();
            }
            this.toggleModalBusy(false);
        });
    }
    closeNewCustomer() {
        $(`#${this.contentElem.id}Input-newCustomer`).css('visibility', 'hidden');
        $(`#${this.contentElem.id}Input`).data('kendoDropDownList').enable(true);
        $(`#${this.contentElem.id}Input-addCustomer`).show();
        this.toggleSubmitButton(true);
    }
}
const MAO_TEMPLATE = `
    <div class="m-stack">
        <div class="m-form-control" style="padding-bottom: 54px;">
            <label class="m-label">Who should these miners be assigned to?</label>
            <div style="display: flex; align-items: flex-end;">
                <input id="{{inputId}}" class="m-input" style="min-width: 225px;padding: 0px" ></input>
                <button id="{{inputId}}-addCustomer" class="m-button" style="margin-left: 10px;" onclick="ma.assignMinersModal.addCustomer(); return false;" >Add customer</button>
            </div>
            <div id="{{inputId}}-newCustomer" style="visibility: hidden;">
               <input id="{{inputId}}-newCustomerName" class="m-input" style="min-width: 225px;padding: 0px; display:block; text-indent: 5px;" placeholder="Customer Name"></input>
               <p id="{{inputId}}-newCustomerError" class="m-help-text is-danger error-msg active"></p>
               <button id="" onclick="ma.assignMinersModal.saveCustomer(); return false;" style="margin-top: 10px;" class="m-button">Save customer</button>
           </div>
       </div>
        </div>
    </div>
    `;

class OpPoolConfigModal extends OpModalBase {
    constructor(page, Id) {
        super(Id);
        this.page = page;
        this.poolConfigUrl = "/minerPoolConfigs";
        this.approvedPoolConfigsUrl = "/ApprovedPoolConfigs";
        this.whitelistedPoolsUrl = "/WhitelistedPools";
        this.minerInfoUrl = "/MinerInfo";
        this.minerIds = [];
        this.approvedConfigs = [];
        this.reportedConfigs = [];
        this.whitelistedPoolsData = null;
        this.selectedApprovedPoolConfigId = undefined;
        this.workerTemplates = [
            "Miner ID",
            "Serial Number",
            "Model Name",
            "IP Address",
            "Custom"
        ];
        this.init();
        this.settingsDropdown = new OpDropDown(document.getElementById("ddlApprovedConfigs"), "Select Configs");
        this.settingsDropdown.onSelectionChanged = this.handleApprovedConfigSelect.bind(this);
        this.allowSubmitButton();
    }
    preSubmitHandler() {
        this.save();
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            const isMinerIds = initData instanceof Array;
            if (isMinerIds) {
                this.minerIds = initData;
                yield this.populateApprovedConfigs();
            }
            else {
                this.minerIds = [String(initData.id)];
                this.populatePoolConfigDropdown(initData.siteId);
                return yield this.initFields(initData);
            }
        });
    }
    beforeClose() {
        this.reset();
    }
    init() {
        this.fetchApprovedConfigs();
        this.fetchWhitelistedPools();
        $("#ddlPool1Template").kendoDropDownList({
            height: 200,
            dataSource: this.workerTemplates,
            change: () => {
                this.checkToToggleCustomWorker(1);
            },
            value: "Miner ID",
        });
        $("#ddlPool1Template").data("kendoDropDownList");
        $("#ddlPool2Template").kendoDropDownList({
            height: 200,
            dataSource: this.workerTemplates,
            change: () => {
                this.checkToToggleCustomWorker(2);
            },
            value: "Miner ID"
        });
        $("#ddlPool3Template").kendoDropDownList({
            height: 200,
            dataSource: this.workerTemplates,
            change: () => {
                this.checkToToggleCustomWorker(3);
            },
            value: "Miner ID"
        });
    }
    fetchApprovedConfigs() {
        return __awaiter(this, void 0, void 0, function* () {
            // just fetch all sites and we will filter the dropdown based on the miner's site
            const siteId = -1;
            const res = yield this.page.get(`${this.approvedPoolConfigsUrl}?siteId=${siteId}`);
            this.approvedConfigs = res.approvedPoolConfigs;
        });
    }
    fetchWhitelistedPools() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteId = -1;
            this.page.get(`${this.whitelistedPoolsUrl}?siteId=${siteId}`)
                .then((resp) => {
                this.whitelistedPoolsData = {
                    whitelistedPools: resp.whitelistedPools,
                    whitelistedSubaccounts: resp.whitelistedSubaccounts,
                    siteId: siteId
                };
            });
        });
    }
    populatePoolConfigDropdown(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const poolsDataSource = this.whitelistedPoolsData.whitelistedPools.filter(conf => conf.siteId == siteId).map((pool, i) => {
                return {
                    id: pool.poolUrl,
                    value: pool.poolUrl
                };
            });
            let dataSource = new self.kendo.data.DataSource({
                data: poolsDataSource
            });
            this.setDropdown($("#pool1Url"), dataSource);
            this.setDropdown($("#pool2Url"), dataSource);
            this.setDropdown($("#pool3Url"), dataSource);
            const accountsDataSource = this.whitelistedPoolsData.whitelistedSubaccounts.filter(conf => conf.siteId == siteId).map((subaccount, i) => {
                return {
                    id: subaccount.subaccount,
                    value: subaccount.subaccount
                };
            });
            dataSource = new self.kendo.data.DataSource({
                data: accountsDataSource
            });
            this.setDropdown($("#pool1Account"), dataSource);
            this.setDropdown($("#pool2Account"), dataSource);
            this.setDropdown($("#pool3Account"), dataSource);
        });
    }
    checkToToggleCustomWorker(poolIndex) {
        const workerTemplate = $(`#ddlPool${poolIndex}Template`).data("kendoDropDownList").value();
        if (workerTemplate === "Custom") {
            $(`#pool${poolIndex}CustomWrapper`).addClass("active");
            return;
        }
        $(`#pool${poolIndex}CustomWrapper`).removeClass("active");
    }
    handleApprovedConfigSelect(ev, value) {
        if (!value) {
            this.selectedApprovedPoolConfigId = null;
            this.enableInputs();
            $(".pool-config-details .m-alert").removeClass("active");
            this.reset(false);
            this.populateFields(this.reportedConfigs);
            return;
        }
        this.disableInputs();
        this.selectedApprovedPoolConfigId = parseInt(value);
        const selectedConfigs = this.approvedConfigs.find(conf => conf.approvedPoolConfigId === parseInt(value));
        selectedConfigs.enforcePoolConfig == true ? $(".pool-config-details .m-alert").addClass("active") : $(".pool-config-details .m-alert").removeClass("active");
        const normalizedConfigs = selectedConfigs.poolSettings.map(conf => {
            const approvedPoolIndex = conf.index;
            const { workerTemplate, customWorker } = this.reportedConfigs.find(r => r.poolIndex === approvedPoolIndex) ||
                {
                    workerTemplate: null,
                    customWorker: ""
                };
            return {
                poolIndex: approvedPoolIndex,
                workerTemplate: workerTemplate,
                url: conf.url,
                account: conf.account,
                password: "",
                customWorker: customWorker
            };
        });
        this.populateFields(normalizedConfigs);
    }
    populateApprovedConfigs() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.page.get(`${this.minerInfoUrl}?minerId=${this.minerIds[0]}`);
            this.miner = res.individualMiner;
            this.selectedApprovedPoolConfigId = res.individualMiner.approvedPoolConfigId;
            let siteId = res.individualMiner.siteId;
            this.populatePoolConfigDropdown(siteId);
            let targetApprovedConfigs = this.approvedConfigs.filter(conf => conf.siteId === siteId);
            this.settingsDropdown.setDataSource(targetApprovedConfigs, "poolConfigName", "approvedPoolConfigId");
            res.individualMiner.autoPool == "On" ? $(".pool-config-details .m-alert").addClass("active") : $(".pool-config-details .m-alert").removeClass("active");
            if (this.selectedApprovedPoolConfigId === null) {
                this.enableInputs();
            }
            else {
                this.disableInputs();
            }
            this.settingsDropdown.setDefaultValue(this.selectedApprovedPoolConfigId);
        });
    }
    populateFields(configs) {
        $(".error-label").removeClass("active");
        configs.forEach(config => {
            const poolIndex = config.poolIndex;
            if (config) {
                $(`#pool${poolIndex + 1}Url`).data("kendoDropDownList").value(config.url);
                $(`#pool${poolIndex + 1}Account`).data("kendoDropDownList").value(config.account);
            }
            $(`#pool${poolIndex + 1}Password`).val(config.password || "");
            $(`#pool${poolIndex + 1}CustomWorker`).val("");
            $(`#pool${poolIndex + 1}CustomWrapper`).removeClass("active");
            if (this.minerIds.length > 1) {
                $(`#ddlPool${poolIndex + 1}Template`).data("kendoDropDownList").value("Miner ID");
            }
            else {
                try {
                    // helper for IP matching
                    let ipSplit = this.miner.ipAddress.split(".");
                    const ipWorkerId = `${ipSplit[2]}x${ipSplit[3]}`;
                    switch (config.customWorker) {
                        case String(this.miner.id):
                            $(`#ddlPool${poolIndex + 1}Template`).data("kendoDropDownList").value("Miner ID");
                            break;
                        case this.miner.serialNumber:
                            $(`#ddlPool${poolIndex + 1}Template`).data("kendoDropDownList").value("Serial Nubmer");
                            break;
                        case `${this.miner.modelName.replace(" ", "")}x${String(this.miner.id)}`:
                            $(`#ddlPool${poolIndex + 1}Template`).data("kendoDropDownList").value("Model Name");
                            break;
                        case ipWorkerId:
                            $(`#ddlPool${poolIndex + 1}Template`).data("kendoDropDownList").value("IP Address");
                            break;
                        default:
                            $(`#ddlPool${poolIndex + 1}Template`).data("kendoDropDownList").value("Custom");
                            let workerName = config.customWorker.split("x");
                            workerName.pop();
                            $(`#pool${poolIndex + 1}CustomWorker`).val(workerName.join("x") || "");
                            $(`#pool${poolIndex + 1}CustomWrapper`).addClass("active");
                            break;
                    }
                    // no ip found
                }
                catch (_a) {
                    $(`#ddlPool${poolIndex + 1}Template`).data("kendoDropDownList").value("Miner ID");
                }
            }
        });
        if (!this.isOpen)
            this.reset();
    }
    initFields(miner) {
        this.miner = miner;
        this.selectedApprovedPoolConfigId = miner.approvedPoolConfigId;
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const apcPromise = this.populateApprovedConfigs();
            const poolConfPromise = this.page.get(`${this.poolConfigUrl}?miners=${[miner.id]}`).then((res) => {
                const configs = res.configs;
                this.reportedConfigs = configs;
                if (!configs)
                    return this.reset();
                this.populateFields(configs);
            });
            yield Promise.all([apcPromise, poolConfPromise]);
            if (this.selectedApprovedPoolConfigId) {
                this.handleApprovedConfigSelect(null, this.selectedApprovedPoolConfigId.toString());
            }
            resolve();
        }));
    }
    reset(resetMiner = true) {
        $(".error-label").removeClass("active");
        $(".custom-worker").removeClass("active");
        $("#pool1Url").val("");
        $("#pool2Url").val("");
        $("#pool3Url").val("");
        $("#pool1Account").val("");
        $("#pool2Account").val("");
        $("#pool3Account").val("");
        $("#pool1Password").val("");
        $("#pool2Password").val("");
        $("#pool3Password").val("");
        $("#pool1CustomWorker").val("");
        $("#pool2CustomWorker").val("");
        $("#pool3CustomWorker").val("");
        $(`#ddlPool1Template`).data("kendoDropDownList").value("Miner ID");
        $(`#ddlPool2Template`).data("kendoDropDownList").value("Miner ID");
        $(`#ddlPool3Template`).data("kendoDropDownList").value("Miner ID");
        this.resetPoolToggles();
        if (resetMiner) {
            this.miner = undefined;
        }
        this.settingsDropdown.setDefaultValue(null);
        this.toggleModalBusy(false);
    }
    save() {
        $(".error-label").removeClass("active");
        const isValid = this.validatePools();
        if (!isValid) {
            return;
        }
        const saveData = this.getSaveData();
        if (!saveData) {
            return;
        }
        this.page.toggleBusy(true);
        this.page.post(this.poolConfigUrl, saveData)
            .then((resp) => {
            this.page.toggleBusy(false);
            if (!resp.success) {
                this.page.showErrorMessage("Something went wrong while saving.  Please try again.", 5);
                return;
            }
            this.page.showSuccessMessage("Pool configurations saved!");
            this._close();
        });
    }
    validatePools() {
        let isValid = true;
        if (!this.isValidPool(1)) {
            isValid = false;
        }
        if (!this.isValidPool(2)) {
            isValid = false;
        }
        if (!this.isValidPool(3)) {
            isValid = false;
        }
        return isValid;
    }
    isValidPool(poolIndex) {
        let isValid = true;
        //const chkPool = <HTMLInputElement>$(`#chkPool${poolIndex}`).get(0);
        //if (!chkPool.checked) {
        //    return isValid;
        //}
        const poolUrl = $(`#pool${poolIndex}Url`).data("kendoDropDownList").value().trim();
        const poolAccount = $(`#pool${poolIndex}Account`).data("kendoDropDownList").value().trim();
        const poolPass = $(`#pool${poolIndex}Password`).val().trim();
        const poolWorker = $(`#pool${poolIndex}CustomWorker`).val().trim();
        const workerTemplate = $(`#ddlPool${poolIndex}Template`).data("kendoDropDownList").value();
        if (poolUrl.length === 0) {
            $(`#pool${poolIndex}UrlError`).addClass("active");
            isValid = false;
        }
        if (poolAccount.length === 0) {
            $(`#pool${poolIndex}AccountError`).addClass("active");
            isValid = false;
        }
        if (poolPass.length === 0) {
            $(`#pool${poolIndex}PassError`).addClass("active");
            isValid = false;
        }
        if (workerTemplate === "Custom" && poolWorker.length === 0) {
            $(`#pool${poolIndex}WorkerError`).addClass("active");
            isValid = false;
        }
        return isValid;
    }
    getSaveData() {
        const pools = [];
        const pool1 = this.getPoolSaveData(1);
        const pool2 = this.getPoolSaveData(2);
        const pool3 = this.getPoolSaveData(3);
        if (pool1) {
            pools.push(pool1);
        }
        if (pool2) {
            pools.push(pool2);
        }
        if (pool3) {
            pools.push(pool3);
        }
        if (pools.length === 0) {
            return null;
        }
        return {
            miners: this.minerIds,
            approvedPoolConfigId: this.selectedApprovedPoolConfigId,
            poolConfigs: pools
        };
    }
    getPoolSaveData(poolNum) {
        //const chkPool = <HTMLInputElement>$(`#chkPool${poolIndex}`).get(0);
        //if (!chkPool.checked) {
        //    return null;
        //}
        var _a;
        const workerTemplate = $(`#ddlPool${poolNum}Template`).data("kendoDropDownList").value();
        const poolUrl = (_a = $(`#pool${poolNum}Url`).data("kendoDropDownList").value()) === null || _a === void 0 ? void 0 : _a.toString().trim();
        const poolAccount = $(`#pool${poolNum}Account`).data("kendoDropDownList").value().trim();
        const poolPass = $(`#pool${poolNum}Password`).val().trim();
        const customWorker = $(`#pool${poolNum}CustomWorker`).val().trim();
        return {
            poolIndex: poolNum - 1,
            workerTemplate: workerTemplate,
            url: poolUrl,
            account: poolAccount,
            password: poolPass,
            customWorker: customWorker
        };
    }
    setDropdown(ele, dataSource) {
        ele.kendoDropDownList({
            dataTextField: "id",
            dataValueField: "value",
            dataSource: dataSource,
            height: 200,
            autoWidth: true,
            change: (e) => {
            }
        });
    }
    togglePool(sender, poolIndex) {
        if (!sender.checked) {
            $(`#poolDetailsBlocker${poolIndex}`).addClass("disabled");
            return;
        }
        $(`#poolDetailsBlocker${poolIndex}`).removeClass("disabled");
    }
    disableInputs() {
        $(".pool-details-wrapper").addClass("disabled");
    }
    enableInputs() {
        $(".pool-details-wrapper").hasClass("disabled") && $(".pool-details-wrapper").removeClass("disabled");
    }
    resetPoolToggles() {
        // // pool 1
        // const chkPool1 = <HTMLInputElement>$(`#chkPool1`).get(0);
        // chkPool1.checked && chkPool1.click();
        // $(`#pool1CustomWrapper`).removeClass("active");
        //// pool 2
        // const chkPool2 = <HTMLInputElement>$(`#chkPool2`).get(0);
        // chkPool2.checked && chkPool2.click();
        // $(`#pool2CustomWrapper`).removeClass("active");
        // // pool3
        // const chkPool3 = <HTMLInputElement>$(`#chkPool3`).get(0);
        // chkPool3.checked && chkPool3.click();
        // $(`#pool3CustomWrapper`).removeClass("active");
    }
}

class OpProfileModal extends OpModalBase {
    constructor(page, Id, submitHandler) {
        super(Id);
        this.page = page;
        this.getProfileUrl = "/Profile";
        this.securityQuestionsUrl = "/SecurityQuestions";
        this.updateProfileUrl = "/UpdateProfile";
        this.postSubmitHandler = () => { };
        if (submitHandler) {
            this.postSubmitHandler = submitHandler.bind(this);
        }
        this.init();
    }
    preSubmitHandler() {
        this.save();
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.hideServerError();
        });
    }
    init() {
        this.page.toggleBusy(true);
        this.initButtons();
        const profilePromise = this.page.get(this.getProfileUrl);
        const sqPromise = this.page.get(this.securityQuestionsUrl);
        Promise.all([profilePromise, sqPromise]).then(([profileRes, sqRes]) => {
            if (profileRes.success === false) {
                this.showServerlError("Failed to fetch profile.");
            }
            this.initFields(sqRes);
            this.populateTextFields(profileRes);
        });
    }
    initButtons() {
        $("#updatePasswordCancel").off("click").click(this.forgotPassword.bind(this));
        $("#updatePasswordSubmit").off("click").click(this.submitForgotPassword.bind(this));
    }
    populateTextFields(res) {
        const user = res.user;
        $("#emailInput").val(user === null || user === void 0 ? void 0 : user.email);
        $("#firstNameInput").val(user === null || user === void 0 ? void 0 : user.firstName);
        $("#lastNameInput").val(user === null || user === void 0 ? void 0 : user.lastName);
        $("#phoneNumberInput").val(user === null || user === void 0 ? void 0 : user.phone);
        // if security question id is valid, populate security question dropdown and fill answer
        if (user.securityQuestionId > 0) {
            $("#securityQuestionInput").data("kendoDropDownList").value(user.securityQuestionId.toString());
            $("#securityAnswerInput").val(user.securityQuestionAnswer);
        }
        if (user.passwdChangeDate) {
            $("#passwordLastChangeDate").text("Last changed on " + window.moment(user.passwdChangeDate).format("MM/DD/YYYY hh:mm A"));
        }
    }
    initFields(sqRes) {
        $("#securityQuestionInput").kendoDropDownList({
            dataTextField: "question",
            dataValueField: "id",
            dataSource: sqRes.questions,
            height: 200,
            autoWidth: true
        }).data("kendoDropDownList");
        $("#forgotPassword").off("click")
            .click(this.forgotPassword.bind(this));
        try {
            $("#securityQuestionInput").data("kendoDropDownList").value(sqRes.questions[0].id.toString());
        }
        catch (_a) { }
        // new password input
        $("#newPasswordIconShow").off("click").click(this.showSecurityInput.bind(this, "#newPasswordInput", "#newPasswordIconShow", "#newPasswordIconNoShow"));
        $("#newPasswordIconNoShow").off("click").click(this.hideSecurityInput.bind(this, "#newPasswordInput", "#newPasswordIconNoShow", "#newPasswordIconShow"));
        // confirm password input
        $("#confirmPasswordIconShow").off("click").click(this.showSecurityInput.bind(this, "#confirmPasswordInput", "#confirmPasswordIconShow", "#confirmPasswordIconNoShow"));
        $("#confirmPasswordIconNoShow").off("click").click(this.hideSecurityInput.bind(this, "#confirmPasswordInput", "#confirmPasswordIconNoShow", "#confirmPasswordIconShow"));
        // securty answer input
        $("#secretIconShow").off("click").click(this.showSecurityInput.bind(this, "#securityAnswerInput", "#secretIconShow", "#secretIconNoShow"));
        $("#secretIconNoShow").off("click").click(this.hideSecurityInput.bind(this, "#securityAnswerInput", "#secretIconNoShow", "#secretIconShow"));
    }
    hideSecurityInput(inputId, oldId, newId) {
        $(inputId).prop("type", "password");
        $(newId).show();
        $(oldId).hide();
    }
    showSecurityInput(inputId, oldId, newId) {
        $(inputId).prop("type", "text");
        $(oldId).hide();
        $(newId).show();
    }
    validateTextField(inputEl, value) {
        if (value.length == 0) {
            inputEl.hasClass("invalid") || inputEl.addClass("invalid");
            return false;
        }
        else {
            inputEl.removeClass("invalid");
            return true;
        }
    }
    validateInputs() {
        let success = true;
        // email validation
        const emailInput = $("#emailInput");
        const emailErrorEl = $("#emailInvalid");
        const email = emailInput.val();
        const isEmail = email.toLowerCase().match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|.(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
        if (!isEmail) {
            emailErrorEl.hasClass("invalid") || emailInput.addClass("invalid");
            success = false;
        }
        else {
            emailErrorEl.removeClass("invalid");
        }
        // validate first name
        const firstNameInput = $("#firstNameInput");
        const firstNameInvalidEl = $("#firstNameInvalid");
        let firstName = firstNameInput.val();
        if (!this.validateTextField(firstNameInvalidEl, firstName)) {
            success = false;
        }
        // validate last name
        const lastNameInput = $("#lastNameInput");
        const lastNameInvalidEl = $("#lastNameInvalid");
        const lastName = lastNameInput.val();
        if (!this.validateTextField(lastNameInvalidEl, lastName)) {
            success = false;
        }
        // validate phone number
        const phoneNumberInput = $("#phoneNumberInput");
        const phoneNumberInvalidEl = $("#phoneNumberInvalid");
        const phoneNumber = phoneNumberInput.val();
        const isPhoneNumber = phoneNumber.match(/^(\+\d{1,2}\s)?\(?\d{3}\)?[\s.-]\d{3}[\s.-]\d{4}$/);
        if (!isPhoneNumber) {
            // handle phoone number field
            phoneNumberInvalidEl.hasClass("invalid") || phoneNumberInvalidEl.addClass("invalid");
            success = false;
        }
        else {
            phoneNumberInvalidEl.removeClass("invalid");
        }
        // dont need to validate dropdown input
        const securityQuestionId = Number($("#securityQuestionInput").data("kendoDropDownList").value());
        // validate security answer
        const securityAnswerInput = $("#securityAnswerInput");
        const securityAnswerInvalidEl = $("#securityAnswerInvalid");
        const securityAnswer = securityAnswerInput.val();
        if (!this.validateTextField(securityAnswerInvalidEl, securityAnswer)) {
            success = false;
        }
        if (!success) {
            return null;
        }
        return {
            email,
            firstName,
            lastName,
            phone: phoneNumber,
            questionId: securityQuestionId,
            answer: securityAnswer,
        };
    }
    save() {
        const newProfile = this.validateInputs();
        if (!newProfile)
            return;
        // make post request
        this.page.post(this.updateProfileUrl, newProfile).then((res) => {
            if (!res.success) {
                this.showServerlError("Failed to update profile.");
                return;
            }
            this.postSubmitHandler();
            this._close();
        });
    }
    showServerlError(msg) {
        const el = $("#profileServerError");
        el.text(msg);
        el.show();
    }
    hideServerError() {
        $("#profileServerError").hide();
    }
    forgotPassword() {
        $("#newPasswordInput").val("");
        $("#confirmPasswordInput").val("");
        const isHidden = $("#changePasswordForm").hasClass("hidden");
        isHidden ? $("#changePasswordForm").removeClass("hidden") :
            $("#changePasswordForm").addClass("hidden");
    }
    submitForgotPassword() {
        // validate
        const newPassword = this.validatePasswords();
        if (!newPassword)
            return;
        // submit
        this.toggleModalBusy(true);
        this.page.post("/ChangePassword", {
            password: btoa(newPassword)
        }).then((resp) => {
            this.toggleModalBusy(false);
            if (!resp.success) {
                this.showServerlError("Failed to successfully update password.");
            }
            $(`#passwordLastChangeDate`).text(window.moment().format("MM/DD/YYYY hh:mm A"));
            this.forgotPassword();
        });
    }
    validatePasswords() {
        let success = true;
        // new password validation
        const newPaswordInput = $("#newPasswordInput");
        const newPasswordErrorEl = $("#newPasswordInvalid");
        const newPassword = newPaswordInput.val();
        const isValidPassword = newPassword.match(/^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$/);
        if (!isValidPassword) {
            newPasswordErrorEl.hasClass("invalid") || newPasswordErrorEl.addClass("invalid");
            success = false;
        }
        else {
            newPasswordErrorEl.removeClass("invalid");
        }
        // coinfirm password validation
        const confirmPaswordInput = $("#confirmPasswordInput");
        const confirmPasswordErrorEl = $("#confirmPasswordInvalid");
        const confirmPassword = confirmPaswordInput.val();
        const matchesNewPassword = confirmPassword === newPassword;
        if (!matchesNewPassword) {
            confirmPasswordErrorEl.hasClass("invalid") || confirmPasswordErrorEl.addClass("invalid");
            success = false;
        }
        else {
            confirmPasswordErrorEl.removeClass("invalid");
        }
        if (!success)
            return;
        return newPassword;
    }
}

class OpRebootMinersModal extends OpModalBase {
    constructor(page, Id, responseHandler) {
        super(Id);
        this.rebootUrl = "/RebootMiners";
        this.activeRebootRestrictionsUrl = "/ActiveRebootRestrictions";
        this.checkedRestrictions = false;
        this.bypassed = false;
        this.page = page;
        this.init();
        this.handleResponse = responseHandler;
    }
    preSubmitHandler() {
        this.save();
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            this.checkedRestrictions = false;
            this.minerIds = initData;
            return yield this.loadMinerNames(initData);
        });
    }
    beforeClose() {
        this.reset();
        this.checkedRestrictions = false;
    }
    init() {
        this.rebootRestrictionsConfirmationTB = $(`#${this.Id}-rr-confirmation`).kendoTextBox({
            placeholder: "REBOOT",
        }).data("kendoTextBox");
        this.rebootRestrictionsConfirmationTB.wrapper.on("keyup", this.rebootConfirmationTextChanged.bind(this));
    }
    loadMinerNames(minerIds) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                if (minerIds.length === 0) {
                    this.handleNoMinerSelected();
                    return resolve();
                }
                const urlString = `/MinersBy?${minerIds.map(id => "minerIds=" + id).join("&")}`;
                this.page.get(urlString).then((resp) => {
                    this.populateMinerList(resp.miners);
                    resolve();
                });
            });
        });
    }
    handleNoMinerSelected() {
        $(this.elem).find(".default-reboot-text").hide();
        $(this.elem).find(".no-miners-selected-text").show();
        $(this.elem).find(".submit-button").attr("disabled", "disabled");
    }
    populateMinerList(minerList) {
        const thisElem = $(this.elem);
        thisElem.find(".miner-count").text(minerList.length);
        thisElem.find(".miner-plural").text(minerList.length > 1 ? "s" : "");
        let minerListElem = thisElem.find(".miner-list");
        minerListElem.empty();
        minerList.forEach((miner) => {
            const minerStuff = self.Mustache.to_html(OpRebootMinersModal.MinerListItemTemplate, miner);
            minerListElem.append(minerStuff);
        });
    }
    rebootConfirmationTextChanged(event) {
        const currentText = $(event.target).val();
        if (currentText === "REBOOT") {
            $(this.elem).find(".submit-button-wrapper").removeClass("disabled").removeAttr("disabled");
        }
        else {
            $(this.elem).find(".submit-button-wrapper").addClass("disabled").attr("disabled", "disabled");
        }
    }
    sendRebootRequest() {
        this.toggleModalBusy(true);
        this.page.post(this.rebootUrl, { miners: this.minerIds, bypassed: this.bypassed })
            .then(this.handleResponse)
            .then(() => {
            this.toggleModalBusy(false);
            this._close();
        });
    }
    reset() {
        $(this.elem).find(".default-reboot-text").show();
        $(this.elem).find(".no-miners-selected-text").hide();
        $(this.elem).find(".submit-button").removeAttr("disabled");
        $(this.elem).find(".reboot-restrictions").removeClass("active");
        $(this.elem).find(".submit-button-wrapper").removeClass("disabled").removeAttr("disabled");
    }
    save() {
        const thisElem = $(this.elem);
        if (thisElem.find(".submit-button-wrapper").attr("disabled") === "disabled") {
            return;
        }
        if (this.checkedRestrictions) {
            this.sendRebootRequest();
            return;
        }
        this.toggleModalBusy(true);
        const urlString = `${this.activeRebootRestrictionsUrl}?${this.minerIds.map(id => "minerIds=" + id).join("&")}`;
        this.page.get(urlString).then((resp) => {
            if (!resp.success) {
                return;
            }
            if (resp.minerIds.length > 0) {
                // Switch to the confirmation screen
                thisElem.find(".reboot-restrictions").addClass("active");
                thisElem.find(".submit-button-wrapper").addClass("disabled").attr("disabled", "disabled");
                this.checkedRestrictions = true;
                this.bypassed = true;
                this.toggleModalBusy(false);
                return;
            }
            this.sendRebootRequest();
        });
    }
}
OpRebootMinersModal.MinerListItemTemplate = `
            <li class="m-stack is-horizontal is-align-center has-space-between" >{{minerName}}</li>
        `;

class UnAssignMinerModal extends OpModalBase {
    constructor(httpService, Id, submitHandler) {
        super(Id);
        this.httpService = httpService;
        this.updateMinersUrl = "/BulkUpdateMiners";
        if (submitHandler) {
            this.postSubmitHandler = submitHandler.bind(this);
        }
    }
    preSubmitHandler() {
        this.updateMinerLocation(this.minerId).then(() => { var _a; return (_a = this.postSubmitHandler) === null || _a === void 0 ? void 0 : _a.call(this); });
        this._close();
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryTextId = `#${this.elem.id}PrimaryText`;
            const warningTextId = `#${this.elem.id}WarningText`;
            const headingId = `#${this.elem.id}_HEADING`;
            this.minerId = initData.minerId;
            $(primaryTextId).text(initData.primaryText);
            $(warningTextId).html(initData.warningText);
            if (initData.headingText) {
                $(headingId).text(initData.headingText);
            }
        });
    }
    setOnSubmit(submitHandler) {
        this.postSubmitHandler = submitHandler.bind(this);
    }
    updateMinerLocation(minerId) {
        return __awaiter(this, void 0, void 0, function* () {
            const saveData = {
                miners: [minerId],
                values: [["location", "unassigned"]],
            };
            yield this.httpService.post(this.updateMinersUrl, saveData).then(() => {
            });
        });
    }
    static getUnAssignMinerModalInitData(minerId) {
        return {
            primaryText: `Are you sure you want to unassign the miner?`,
            warningText: "",
            minerId: minerId
        };
    }
}

class OpScheduledShutdownModal extends OpModalBase {
    constructor(page, Id, submitHandler) {
        super(Id);
        this.page = page;
        this.ssTypesUrl = "/ScheduledShutdownTypes";
        this.scheduledShutdownsUrl = "/ScheduledShutdowns";
        this.sitesUrl = "/sites";
        this.mustache = window.Mustache;
        this.sites = [];
        this.zones = [];
        this.isEditing = false;
        this.postSubmitHandler = submitHandler.bind(this);
        this.init();
    }
    init() {
        this.toggleBusy(true);
        const sitesProm = this.initSites();
        const typesProm = this.initTypes();
        Promise.all([sitesProm, typesProm]).then(() => {
            this.toggleBusy(false);
            this.initFields();
        });
    }
    initSites() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.page.get(this.sitesUrl);
            this.sites = resp.sites;
            yield this.initZones();
        });
    }
    initZones() {
        return __awaiter(this, void 0, void 0, function* () {
            // Assuming there's a method in OptiFleetPage to fetch zones similar to initSites()
            const resp = yield this.page.get("/zones"); // Adjust the URL as needed
            this.zones = resp.zones;
        });
    }
    initTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.page.get(this.ssTypesUrl);
            this.eventTypeList = resp.eventTypes;
        });
    }
    initFields() {
        $("#eventTypeInput").kendoDropDownList({
            dataTextField: "type",
            dataValueField: "id",
            dataSource: this.eventTypeList,
            height: 200,
            autoWidth: true
        }).data("kendoDropDownList");
        $("#siteInput").kendoDropDownList({
            dataTextField: "siteName",
            dataValueField: "siteId",
            dataSource: this.sites,
            height: 200,
            autoWidth: true,
            change: this.updateZonesInput.bind(this)
        }).data("kendoDropDownList");
        if (!this.zonesInput) {
            this.zonesInput = $("#zonesInput").kendoMultiSelect().data("kendoMultiSelect");
        }
        this.updateZonesInput();
        const now = new Date();
        const twoHoursAgo = getXHoursAgo(2);
        $("#startTimeInput").kendoDateTimePicker({}).data("kendoDateTimePicker").value(twoHoursAgo);
        $("#endTimeInput").kendoDateTimePicker({}).data("kendoDateTimePicker").value(now);
    }
    updateZonesInput() {
        const siteId = parseInt($("#siteInput").data("kendoDropDownList").value());
        let zones = ["All zones"];
        const siteZones = this.zones.filter(z => Number(z.siteId) === Number(siteId));
        zones = [...zones, ...siteZones.map(z => z.zoneName)];
        this.zonesInput.setDataSource(new kendo.data.DataSource({ data: zones }));
    }
    preSubmitHandler() {
        this.save().then((success) => __awaiter(this, void 0, void 0, function* () {
            if (!success)
                return;
            yield this.postSubmitHandler();
            this._close();
        }));
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.clearValidationErrors();
            this.reset();
            yield this.init();
            $("#siteInput").data("kendoDropDownList").value(this.page.getSelectedSiteId().toString());
            this.updateZonesInput();
            if (!initData) {
                $("#ScheduledShutdownModal_HEADING").text("Add New Excused Event");
                return;
            }
            $("#ScheduledShutdownModal_HEADING").text("Edit Excused Event");
            this.populateModal(initData);
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isEditing) {
                return yield this.update();
            }
            return yield this.create();
        });
    }
    create() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.validateNewForm()) {
                return false;
            }
            const data = {
                NewScheduledShutdown: this.getScheduledShutdownFromInputs()
            };
            const resp = yield this.page.post(`${this.scheduledShutdownsUrl}`, data);
            if (!resp.success) {
                this.page.showErrorMessage("Unable to save item");
                return false;
            }
            this.page.showSuccessMessage("Saved scheduled shutdown");
            this._close();
            return true;
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.validateNewForm()) {
                return false;
            }
            let data = {
                scheduledShutdown: this.getScheduledShutdownFromInputs()
            };
            data.scheduledShutdown.scheduledShutdownId = this.existingScheduledShutdown.scheduledShutdownId;
            const resp = yield this.page.patch(`${this.scheduledShutdownsUrl}`, data);
            if (!resp.success) {
                this.page.showErrorMessage("Unable to save item");
                return false;
            }
            this.page.showSuccessMessage("Saved scheduled shutdown");
            this.close();
            return true;
        });
    }
    validateNewForm() {
        this.clearValidationErrors();
        let isValid = true;
        const eventType = $("#eventTypeInput").data("kendoDropDownList");
        const description = $("#descriptionInput").val().trim();
        const startTime = $("#startTimeInput").data("kendoDateTimePicker").value();
        const endTime = $("#endTimeInput").data("kendoDateTimePicker").value();
        const zones = this.zonesInput.value();
        if (eventType.text() === "Other" && description.length === 0) {
            $(".no-description-error").addClass("active");
            isValid = false;
        }
        if (zones.length > 1 && zones.includes("All zones")) {
            $(".invalid-zones-all-zones").addClass("active");
            isValid = false;
        }
        else if (zones.length === 0) {
            $(".invalid-zones-must-select-one").addClass("active");
            isValid = false;
        }
        if (!startTime) {
            $(".no-start-error").addClass("active");
            isValid = false;
        }
        if (!endTime) {
            $(".no-end-error").addClass("active");
            isValid = false;
        }
        if (startTime > endTime) {
            $(".invalid-range-error").addClass("active");
            isValid = false;
        }
        return isValid;
    }
    clearValidationErrors() {
        $(".excused-event-error").each((_, el) => {
            $(el).removeClass("active");
        });
    }
    reset() {
        const now = new Date();
        const twoHoursAgo = getXHoursAgo(2);
        this.isEditing = false;
        this.existingScheduledShutdown = null;
        $("#descriptionInput").val("");
        $("#startTimeInput").data("kendoDateTimePicker").value(twoHoursAgo);
        $("#endTimeInput").data("kendoDateTimePicker").value(now);
    }
    populateModal(data) {
        this.isEditing = true;
        this.existingScheduledShutdown = data;
        const targetZoneNames = this.zones.filter(z => data.zoneIds.includes(z.zoneId)).map(z => z.zoneName);
        if (targetZoneNames.length === 0)
            targetZoneNames.push("All zones");
        $("#eventTypeInput").data("kendoDropDownList").value(data.typeId.toString());
        $("#siteInput").data("kendoDropDownList").value(data.siteId.toString());
        this.zonesInput.value(targetZoneNames);
        $("#startTimeInput").data("kendoDateTimePicker").value(new Date(data.start));
        $("#endTimeInput").data("kendoDateTimePicker").value(new Date(data.end));
        $("#descriptionInput").val(data.description);
    }
    getScheduledShutdownFromInputs() {
        const eventType = $("#eventTypeInput").data("kendoDropDownList");
        const siteId = $("#siteInput").data("kendoDropDownList").value();
        const zoneNames = $("#zonesInput").data("kendoMultiSelect").value();
        const startTime = $("#startTimeInput").data("kendoDateTimePicker").value();
        const endTime = $("#endTimeInput").data("kendoDateTimePicker").value();
        const description = $("#descriptionInput").val().trim();
        const zoneIds = this.zones.filter(z => zoneNames.includes(z.zoneName)).map(z => z.zoneId);
        return {
            typeId: eventType.value(),
            title: eventType.text(),
            description: description,
            siteId: siteId,
            zoneIds,
            start: startTime,
            end: endTime
        };
    }
    toggleBusy(isBusy) {
        if (!isBusy) {
            $(".modal-busy").hide();
            return;
        }
        $(".modal-busy").show();
    }
}
function getXHoursAgo(hours) {
    let now = new Date();
    now.setHours(now.getHours() - hours);
    return now;
}

class OpTicketResolutionModal extends OpModalBase {
    constructor(page, Id, submitHandler) {
        super(Id);
        this.page = page;
        this.closeTicketUrl = "/TicketStatus";
        this.oldStatusId = `#oldStatus${Id}`;
        this.handleClose = submitHandler;
    }
    preSubmitHandler() {
        this.save();
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            $(this.oldStatusId).text(initData.oldValue.label);
            this.initData = initData;
        });
    }
    beforeClose() {
        this.handleClose({
            success: false,
            initData: this.initData
        });
    }
    save() {
        const reqData = {
            ticketId: this.initData.ticketId,
            statusId: this.initData.newValue.id,
            resolution: $('#ticketResolution').text().trim()
        };
        // send update patch
        this.page.patch(this.closeTicketUrl, reqData).then((resp) => {
            if (!resp.success) {
                this.page.showErrorMessage("An error occurred while saving.  Please try again.");
                return;
            }
            this.page.showSuccessMessage("Ticket saved!");
            this.handleClose({
                success: true,
                initData: this.initData
            });
            this._close();
        });
    }
}

var AgentVisibility;
(function (AgentVisibility) {
    AgentVisibility[AgentVisibility["View"] = 0] = "View";
    AgentVisibility[AgentVisibility["ViewWithAdmin"] = 1] = "ViewWithAdmin";
    AgentVisibility[AgentVisibility["Add"] = 2] = "Add";
    AgentVisibility[AgentVisibility["Edit"] = 3] = "Edit";
})(AgentVisibility || (AgentVisibility = {}));
const DEFAULT_PROPS = {
    initNullFields: true,
    addAgentHidden: false,
    allowDelete: false
};
class AgentDetailsFormView {
    // parentEl required when not using user control
    constructor(Id, parentEl, props = DEFAULT_PROPS) {
        this.Id = Id;
        this.parentEl = parentEl;
        this.props = props;
        this.mustache = window.Mustache;
        this.isIpRegex = /^(?!0)(?!.*\.$)((1?\d?\d|25[0-5]|2[0-4]\d)(\.|$)){4}$/;
        // only used for generating unique indexes in Create view
        this.numAgents = 0;
        this.numIpRanges = 0;
        this.numCredentials = 0;
        this.appendWrapper(props);
        this.addAgentBtn = this.getComponent("AddAgentBtn");
        this.addAgentBtn.on("click", this.handleAddAgentClick.bind(this));
        this.onEdit = props === null || props === void 0 ? void 0 : props.editHandler;
    }
    title() { return "Agent Details"; }
    // set display to true for view content
    show() { this.getComponent().show(); }
    // set display to none for view content
    hide() { this.getComponent().hide(); }
    // called on modal init. Should make http GET to initialize for fields
    load(initData) { return; }
    confirm(submitCallback) { submitCallback && submitCallback(); }
    // validate form fields
    validate() {
        this.resetAllErrors();
        let success = true;
        let agents = this.agentList.find(".agent");
        // helps us find duplicate agent names
        let agentNameList = [];
        agents.each((_, agent) => {
            let agentNameInput = $(agent).find("[name='agentNameInput']");
            let agentNameErrMsg = $(agent).find(".agent-name-err-msg");
            // check agent name duplicate
            if (agentNameList.includes(agentNameInput.val())) {
                agentNameInput.addClass("is-error");
                agentNameErrMsg.text("Duplicate agent name not allowed");
                agentNameErrMsg.addClass("active");
                success = false;
            }
            // check agent name empty
            if (agentNameInput.val() === "") {
                agentNameInput.addClass("is-error");
                agentNameErrMsg.text("Agent name required");
                agentNameErrMsg.addClass("active");
                success = false;
            }
            // add agent name to our agent names list
            agentNameList.push(agentNameInput.val());
            // validate each ip range row
            $(agent).find(".ip-range-row").each((_, row) => {
                success = success && this.handleIPRangeRowValidation($(row));
            });
            // validate each miner credentials row
            $(agent).find(".miner-cred-row").each((_, row) => {
                success = success && this.handleMinerCredentialsRowValidation($(row));
            });
        });
        if (!success) {
            // focus first error
            this.agentList.find(".m-input.is-error").first().focus();
        }
        return success;
    }
    // reset form values if not saved
    reset() {
        this.resetAllErrors();
        this.agentList.empty();
        this.addAgent();
    }
    // add key/value pairs to the object passed in
    updateSubmitData(dataObj, submitType) {
        dataObj['siteId'] = this.siteId;
        let agents = [];
        this.agentList.find(".agent").each((_, agent) => {
            let agentData = { "agentName": $(agent).find("[name='agentNameInput']").val(), "scanConfigs": [] };
            if (submitType === ProgressionModalSubmitType.PATCH) {
                let agentId = this.extractIdFromElement(agent);
                agentData['agentId'] = agentId;
            }
            $(agent).find(".ip-range-row").each((_, row) => {
                let ipStart = $(row).find("[name='ipStartInput']").val();
                let ipEnd = $(row).find("[name='ipEndInput']").val();
                let credentials = $(agent).find(".miner-cred-row").map((_, row) => {
                    let username = $(row).find("[name='minerUsernameInput']").val();
                    let password = $(row).find("[name='minerPasswordInput']").val();
                    return { Username: username, Password: password };
                }).toArray();
                agentData.scanConfigs.push({
                    IpRange: `${ipStart}-${ipEnd}`,
                    Credentials: credentials
                });
            });
            agents.push(agentData);
        });
        dataObj["agents"] = agents;
    }
    // agent id = "Agent-{AgentId}"
    // config id = "Agent-Ip-{ConfigId}"
    // credential id = "Agent-Cred-{CredentialId}"
    extractIdFromElement(element) {
        return parseInt(element.id.split("-").pop());
    }
    appendWrapper(props) {
        const data = {
            elementId: this.Id,
            addAgentHidden: props.addAgentHidden ? "hidden" : ""
        };
        const wrapper = this.mustache.to_html(WRAPPER_TEMPLATE, data);
        this.parentEl.append(wrapper);
        this.agentList = this.getComponent("AgentList");
        props.initNullFields && this.addAgent();
    }
    addAgentWithData(agentProps) {
        this.agentList.empty();
        this.agentProps = agentProps;
        agentProps.forEach((prop, index) => {
            prop.withDeleteButton = true;
            if (index === 0) {
                prop.withDeleteButton = false;
            }
            this.addAgent(prop);
        });
    }
    openEditModal(agentId) {
        const modalProps = this.agentProps.find(agent => agent.agentId === agentId);
        modalProps.visibility = AgentVisibility.Edit;
        modalProps && this.onEdit(modalProps);
    }
    // ** UTILS **
    // zone details view uses this to pupulate agent dropdown
    getCurrentAgentList() {
        return $("[name='agentNameInput']").toArray().map((input) => $(input).val());
    }
    getComponent(genericId = "") {
        return $(`#${this.Id}${genericId}`);
    }
    handleAddAgentClick(e) {
        this.addAgent();
    }
    addAgent(agentProps) {
        let data = agentProps;
        if (!data) {
            data = { elementId: `Agent-${this.numAgents}` };
            data.hideAgentStatus = "hidden";
            data.hideEditButtons = "";
            data.isAdmin = false;
            data.allowDelete = this.props.allowDelete;
            data.canEdit = true;
            data.inputsDisabled = data.canEdit ? "" : "disabled";
        }
        else {
            data.elementId = `Agent-${agentProps.agentId}`;
            data.hideAgentStatus = (agentProps.visibility !== AgentVisibility.View && agentProps.visibility !== AgentVisibility.ViewWithAdmin) ? "hidden" : "";
            data.hideEditButtons = (agentProps.visibility !== AgentVisibility.View && agentProps.visibility !== AgentVisibility.ViewWithAdmin) ? "" : "hidden";
            data.isAdmin = agentProps.visibility === AgentVisibility.ViewWithAdmin;
            data.allowDelete = this.props.allowDelete;
            data.canEdit = (agentProps.visibility !== AgentVisibility.View && agentProps.visibility !== AgentVisibility.ViewWithAdmin);
            data.inputsDisabled = data.canEdit ? "" : "disabled";
        }
        let agent = $(this.mustache.to_html(AGENT_TEMPLATE, data));
        agent.find(".del-agent-btn").on("click", (e) => {
            if (this.agentList.children().length <= 1) {
                return;
            }
            $(e.target).closest(".agent").remove();
        });
        // if we have data populate scan config fields
        if (agentProps) {
            let credSignatures = []; // used to prevent rendering duplicate credentials
            agentProps.scanConfigs.forEach(config => {
                config.inputsDisabled = data.canEdit ? "" : "disabled";
                config.hideEditButtons = data.hideEditButtons;
                this.addIpRangeRowToAgent(agent, config);
                config.credentials.forEach(cred => {
                    cred.inputsDisabled = data.canEdit ? "" : "disabled";
                    cred.hideEditButtons = data.hideEditButtons;
                    var credSignature = cred.username.toLowerCase() + cred.password.toLowerCase();
                    if (!credSignatures.includes(credSignature)) {
                        this.addMinerCredentialRowToAgent(agent, cred);
                        credSignatures.push(credSignature);
                    }
                });
            });
        }
        else {
            this.addIpRangeRowToAgent(agent);
            this.addMinerCredentialRowToAgent(agent, { agentScanConfigCredentialId: this.numCredentials, username: "root", password: "root" });
            this.addMinerCredentialRowToAgent(agent, { agentScanConfigCredentialId: this.numCredentials, username: "admin", password: "admin" });
        }
        agent.find(".add-ip-range-btn").on("click", (e) => {
            this.addIpRangeRowToAgent($(e.target).closest(".agent"));
        });
        agent.find(".add-miner-creds-btn").on("click", (e) => {
            this.addMinerCredentialRowToAgent($(e.target).closest(".agent"));
        });
        this.agentList.append(agent);
        // add edit handler to edit button
        try {
            this.onEdit && $(`#${data.elementId}AgentEditButton`).off("click").click(this.openEditModal.bind(this, agentProps.agentId));
        }
        catch (_a) { }
        this.numAgents++;
    }
    addIpRangeRowToAgent(agent, props) {
        let data = props;
        if (!data) {
            data = { elementId: `Agent-Ip-${this.numIpRanges}` };
        }
        else {
            data.elementId = `Agent-Ip-${props.agentScanConfigId}`;
        }
        let ipRangeRow = $(this.mustache.to_html(IP_RANGE_ROW_TEMPLATE, data));
        ipRangeRow.find(".del-ip-range-btn").on("click", (e) => {
            let ipRangeList = $(e.target).closest(".ip-range-list");
            if (ipRangeList.children().length <= 1) {
                return;
            }
            $(e.target).closest(".ip-range-row").remove();
        });
        agent.find(".ip-range-list").append(ipRangeRow);
        this.numIpRanges++;
    }
    addMinerCredentialRowToAgent(agent, props) {
        let data = props;
        if (!data) {
            data = { elementId: `Agent-Cred-${this.numCredentials}` };
        }
        else {
            data.elementId = `Agent-Cred-${props.agentScanConfigCredentialId}`;
        }
        let credRow = $(this.mustache.to_html(MINER_CREDENTIAL_ROW_TEMPLATE, data));
        credRow.find(".del-miner-cred-btn").on("click", (e) => {
            let credList = $(e.target).closest(".miner-creds-list");
            if (credList.children().length <= 1) {
                return;
            }
            $(e.target).closest(".miner-cred-row").remove();
        });
        agent.find(".miner-creds-list").append(credRow);
        this.numCredentials++;
    }
    handleIPRangeRowValidation(row) {
        let success = true;
        let ipStartInput = row.find("[name='ipStartInput']");
        let ipEndInput = row.find("[name='ipEndInput']");
        let validIpRequiredErrMsg = row.closest(".agent").find(".valid-ip-required-err-msg");
        let invalidIpRangeErrMsg = row.closest(".agent").find(".invalid-ip-range-err-msg");
        // check start ip empty
        if (ipStartInput.val() === "") {
            ipStartInput.addClass("is-error");
            validIpRequiredErrMsg.addClass("active");
            success = false;
        }
        // check end ip empty
        if (ipEndInput.val() === "") {
            ipEndInput.addClass("is-error");
            validIpRequiredErrMsg.addClass("active");
            success = false;
        }
        // check start ip valid
        if (!this.isIpRegex.test(ipStartInput.val())) {
            ipStartInput.addClass("is-error");
            validIpRequiredErrMsg.addClass("active");
            success = false;
        }
        // check end ip valid
        if (!this.isIpRegex.test(ipEndInput.val())) {
            ipEndInput.addClass("is-error");
            validIpRequiredErrMsg.addClass("active");
            success = false;
        }
        // return if we have invalid ip
        if (!success) {
            return false;
        }
        // check valid ip range
        if (this.ip2int(ipStartInput.val()) > this.ip2int(ipEndInput.val())) {
            ipStartInput.addClass("is-error");
            ipEndInput.addClass("is-error");
            invalidIpRangeErrMsg.addClass("active");
            success = false;
        }
        return success;
    }
    handleMinerCredentialsRowValidation(row) {
        let success = true;
        let usernameInput = row.find("[name='minerUsernameInput']");
        let passwordInput = row.find("[name='minerPasswordInput']");
        let credentialsErrMsg = row.closest(".agent").find(".miner-cred-err-msg");
        // check miner username empty
        if (usernameInput.val() === "") {
            usernameInput.addClass("is-error");
            credentialsErrMsg.addClass("active");
            success = false;
        }
        // check miner password empty
        if (passwordInput.val() === "") {
            passwordInput.addClass("is-error");
            credentialsErrMsg.addClass("active");
            success = false;
        }
        return success;
    }
    resetAllErrors() {
        this.agentList.find(".m-input").removeClass("is-error");
        this.agentList.find(".agent-name-err-msg").removeClass("active");
        this.agentList.find(".valid-ip-required-err-msg").removeClass("active");
        this.agentList.find(".invalid-ip-range-err-msg").removeClass("active");
        this.agentList.find(".miner-cred-err-msg").removeClass("active");
    }
    // source :: https://gist.github.com/jppommet/5708697
    ip2int(ip) {
        return ip.split('.').reduce(function (ipInt, octet) { return (ipInt << 8) + parseInt(octet, 10); }, 0) >>> 0;
    }
}
const WRAPPER_TEMPLATE = `
        <div id="{{elementId}}" class="agent-details-content" style="display: none;">
            <section class="m-section has-space-s">
                <div class="m-stack">
                    <div id="{{elementId}}AgentList" class="m-stack"></div>
                    <button id="{{elementId}}AddAgentBtn" class="m-button is-secondary expanded" type="button" {{addAgentHidden}} >
                        <m-icon class="m-button-icon" name="plus"></m-icon>
                        <span class="m-button-label">Add Another Agent</span>
                    </button>
                </div>
            </section>
        </div>
    `;
const AGENT_TEMPLATE = `
        <div id="{{elementId}}" class="m-box shadow agent">
            <div class="m-stack">

                    <div class="m-stack is-horizontal has-space-between agent-status" {{hideAgentStatus}}>
                    {{#isOnline}}
                        <div class="m-stack is-horizontal">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M3.33325 8.6667C4.57944 7.44519 6.2549 6.76099 7.99992 6.76099C9.74494 6.76099 11.4204 7.44519 12.6666 8.6667" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M5.66675 11C6.28984 10.3892 7.12757 10.0471 8.00008 10.0471C8.87259 10.0471 9.71032 10.3892 10.3334 11" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M1.33325 5.87994C3.16666 4.24009 5.54014 3.3335 7.99992 3.3335C10.4597 3.3335 12.8332 4.24009 14.6666 5.87994" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M8 13.3333H8.00667" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            <p class="m-text is-tertiary">ONLINE</p>
                        </div>
                    {{/isOnline}}
                    {{^isOnline}}
                         <div class="m-stack is-horizontal">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <g clip-path="url(#clip0_5600_12910)">
                                <path d="M1.3335 1.33325L14.6668 14.6666" stroke="#F0C000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M5.6665 11C6.2896 10.3892 7.12733 10.0471 7.99984 10.0471C8.87235 10.0471 9.71007 10.3892 10.3332 11" stroke="#F0C000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M1.3335 5.87995C2.15614 5.14144 3.09555 4.54446 4.1135 4.11328" stroke="#F0C000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M7.10645 3.33323C9.77978 3.09323 12.5331 3.93323 14.6664 5.8399" stroke="#F0C000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M11.2334 7.5C11.7765 7.8025 12.2747 8.17948 12.7134 8.62" stroke="#F0C000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M3.3335 8.66666C4.28544 7.71467 5.50331 7.0732 6.82683 6.82666" stroke="#F0C000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M8 13.3333H8.00667" stroke="#F0C000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                </g>
                                <defs>
                                <clipPath id="clip0_5600_12910">
                                <rect width="16" height="16" fill="white"/>
                                </clipPath>
                                </defs>
                                </svg>
                            <p class="m-text is-tertiary">OFFLINE</p>
                        </div>
                    {{/isOnline}}
                    {{#isAdmin}}
                        <p id="{{elementId}}AgentEditButton" class="m-text is-accent clickable">Edit</button>
                    {{/isAdmin}}
                    </div>

                <section class="m-section has-space-s">
                    <div class="m-form-control">
                        <label class="m-label is-required" for="agentName">Agent Name</label>
                        <input value="{{agentName}}" type="text" class="m-input" name="agentNameInput" placeholder="Agent Name..." autocomplete="off" data-lpignore="true" data-form-type="other" required  {{inputsDisabled}}/>
                        <p class="m-help-text is-error error-msg agent-name-err-msg">Error</p>
                    </div>
                </section>

                <div class="m-stack has-space-s">
                    <label class="m-label" for="minerDiscovery">Miner Discovery</label>
                    <div class="m-box">

                        <div class="m-stack">

                            <section class="m-section has-space-xs">

                                <fieldset>
                                    <legend>IP Range</legend>
                                    <div class="m-stack">
                                        <div class="m-stack has-space-s">
                                            <div class="m-stack is-horizontal has-space-between ip-label-group">
                                                <label class="m-label is-required" for="ipStartInput">Start</label>
                                                <label class="m-label is-required" for="ipEndInput">End</label>
                                            </div>
                                            <div class="m-stack has-space-s ip-range-list">
                                                <!-- Placeholder for ipRangeRowTemplate -->
                                            </div>
                                            <p class="m-help-text is-error error-msg valid-ip-required-err-msg">Valid IP Required</p>
                                            <p class="m-help-text is-error error-msg invalid-ip-range-err-msg">Invalid IP range</p>
                                        </div>
                                        <div class="m-form-group is-grouped-right" {{hideEditButtons}}>
                                            <button class="m-button is-secondary add-ip-range-btn" type="button">
                                                <m-icon class="m-button-icon" name="plus"></m-icon>
                                                <span class="m-button-label">Add IP Range</span>
                                            </button>
                                        </div>
                                    </div>
                                </fieldset>

                            </section>

                            <section class="m-section has-space-xs">
                                <fieldset>
                                    <legend>Credentials</legend>
                                    <div class="m-stack">
                                        <div class="m-stack has-space-s">
                                            <div class="m-stack is-horizontal has-space-between cred-label-group">
                                                <label class="m-label is-required" for="minerUsernameInput">Username</label>
                                                <label class="m-label is-required" for="minerPasswordInput">Password</label>
                                            </div>
                                            <div class="m-stack has-space-s miner-creds-list">
                                                <!-- Placeholder for minerCredentialRowTemplate -->
                                            </div>
                                            <p id="{{elementId}}minerCredRowError" class="m-help-text is-error error-msg miner-cred-err-msg">Miner credenitals required</p>
                                        </div>
                                        <div class="m-form-group is-grouped-right" {{hideEditButtons}}>
                                            <button class="m-button is-secondary add-miner-creds-btn" type="button">
                                                <m-icon class="m-button-icon" name="plus"></m-icon>
                                                <span class="m-button-label">Add Miner Credentials</span>
                                            </button>
                                        </div>
                                    </div>
                                </fieldset>

                            </section>

                        </div>
                    </div>
                </div>

                {{#allowDelete}}
                    <div class="m-form-group is-grouped-right">
                        <button class="m-button is-destructive del-agent-btn" type="button">Delete Agent</button>
                    </div>
                {{/allowDelete}}

            </div>
        </div>

    `;
const IP_RANGE_ROW_TEMPLATE = `
        <div id={{elementId}} class="m-stack is-horizontal is-align-center ip-range-row">
            <input value="{{ ipStart }}" type="text" class="m-input no-margin" name="ipStartInput" placeholder="10.1.1.1" autocomplete="off" data-lpignore="true" data-form-type="other" required {{inputsDisabled}} />
            <input value="{{ ipEnd }}" type="text" class="m-input no-margin" name="ipEndInput" placeholder="10.1.2.255" autocomplete="off" data-lpignore="true" data-form-type="other" required {{inputsDisabled}} />
            <button class="m-button is-tertiary del-ip-range-btn" type="button" {{hideEditButtons}}>
                <m-icon class="m-button-icon" name="trash-2"></m-icon>
            </button>
        </div>
    `;
const MINER_CREDENTIAL_ROW_TEMPLATE = `
        <div id={{elementId}} class="m-stack is-horizontal is-align-center miner-cred-row">
            <input value="{{ username }}" type="text" class="m-input no-margin" name="minerUsernameInput" placeholder="Miner Username..." autocomplete="off" data-lpignore="true" data-form-type="other" required {{inputsDisabled}} />
            <input value="{{ password }}" type="text" class="m-input no-margin" name="minerPasswordInput" placeholder="Miner Password..." autocomplete="off" data-lpignore="true" data-form-type="other" required {{inputsDisabled}} />
            <button class="m-button is-tertiary del-miner-cred-btn" type="button">
                <m-icon class="m-button-icon" {{hideEditButtons}} name="trash-2"></m-icon>
            </button>
        </div>
    `;

class AssetManufacturersFormView {
    constructor(Id, parentEl) {
        this.Id = Id;
        this.parentEl = parentEl;
        this.assetManufacturersUrl = "/AssetManufacturers";
        this.mustache = window.Mustache;
        this.httpService = new OptiFleetService();
        this.initForm();
    }
    title() { return null; }
    // set display to true for view content
    show() { this.form.css("display", "flex"); }
    // set display to none for view content
    hide() { this.form.css("display", "none"); }
    // called on modal init. Should make http GET to initialize for fields
    load(assetManufacturer) {
        if (!assetManufacturer)
            return;
        this.assetTypeId = assetManufacturer.id;
        this.populateFields(assetManufacturer);
    }
    confirm(submitCallback) { submitCallback && submitCallback(); }
    // validate form fields
    validate() {
        let success = true;
        // Name Validation
        const nameInput = this.form.find(".name-input").first();
        const nameError = this.form.find(".name-invalid").first();
        if (nameInput.val().length == 0) {
            nameError.show();
            success = false;
        }
        else {
            nameError.hide();
        }
        // Description Validation
        const descriptionInput = this.form.find(".description-input").first();
        const descriptionError = this.form.find(".description-error");
        if (descriptionInput.val().length == 0) {
            descriptionError.show();
            success = false;
        }
        else {
            descriptionError.hide();
        }
        return success;
    }
    // reset form values if not saved
    reset() {
        this.form.find(".name-input").first().val("");
        this.form.find(".description-input").first().val("");
    }
    // add key/value pairs to the object passed in
    updateSubmitData(dataObj) {
        const name = this.form.find(".name-input").first().val();
        const description = this.form.find(".description-input").first().val();
        let assetType = {};
        if (this.assetTypeId) {
            assetType['id'] = this.assetTypeId;
        }
        assetType['companyId'] = this.companyId;
        assetType['name'] = name;
        assetType['description'] = description;
        dataObj['assetManufacturer'] = assetType;
    }
    initForm() {
        const data = {
            elementId: this.Id,
        };
        this.form = $(this.mustache.to_html(FORM_TEMPLATE$4, data));
        this.parentEl.append(this.form);
    }
    // ** UTILS **
    populateFields(data) {
        this.form.find(".name-input").first().val(data.name);
        this.form.find(".description-input").first().val(data.description);
    }
}
const FORM_TEMPLATE$4 = `
        <div id="{{elementId}}" class="asset-manufacturers-form" style="display: none;">
            <div class="m-stack" style="width: 100%">
                <div class="m-form-control">
                    <p class="m-label">Name</p>
                    <input class="m-input name-input" type="text" placeholder="e.g Acme"/>
                    <p class="m-help-text is-error error-msg name-invalid" style="display: none;">Name required</p>
                </div>
                <div class="m-form-control">
                    <p class="m-label">Description</p>
                    <textarea class="m-textarea description-input" type="text" placeholder="e.g Widget Manufacturer"/>
                    <p class="m-help-text is-error error-msg description-invalid" style="display: none;">Description required</p>
                </div>
            </div>
        </div>
    `;

class AssetModelsFormView {
    constructor(Id, parentEl, assetTypes, manufacturers) {
        this.Id = Id;
        this.parentEl = parentEl;
        this.assetTypes = assetTypes;
        this.manufacturers = manufacturers;
        this.assetModelsUrl = "/AssetModels";
        this.mustache = window.Mustache;
        this.httpService = new OptiFleetService();
        this.initForm();
    }
    title() { return null; }
    // set display to true for view content
    show() { this.form.css("display", "flex"); }
    // set display to none for view content
    hide() { this.form.css("display", "none"); }
    // called on modal init. Should make http GET to initialize for fields
    load(assetModel) {
        this.manufacturerInput.setDataSource(new kendo.data.DataSource({ data: this.manufacturers.getManufacturersDropdownData() }));
        this.assetTypeInput.setDataSource(new kendo.data.DataSource({ data: this.assetTypes.getAssetTypesDropdownData() }));
        if (!assetModel)
            return;
        this.assetModelId = assetModel.id;
        this.populateFields(assetModel);
    }
    confirm(submitCallback) { submitCallback && submitCallback(); }
    // validate form fields
    validate() {
        let success = true;
        // Name Validation
        const nameInput = this.form.find(".name-input").first();
        const nameError = this.form.find(".name-invalid").first();
        if (nameInput.val().length == 0) {
            nameError.show();
            success = false;
        }
        else {
            nameError.hide();
        }
        // Manufacturer Validation
        const manufacturerError = this.form.find(".manufacturer-invalid");
        if (this.manufacturerInput.value().length == 0) {
            manufacturerError.show();
            success = false;
        }
        else {
            manufacturerError.hide();
        }
        // Manufacturer Validation
        const assetTypeError = this.form.find(".asset_type-invalid");
        if (this.assetTypeInput.value().length == 0) {
            assetTypeError.show();
            success = false;
        }
        else {
            assetTypeError.hide();
        }
        return success;
    }
    // reset form values if not saved
    reset() {
        this.form.find(".name-input").first().val("");
        this.form.find(".description-input").first().val("");
    }
    // add key/value pairs to the object passed in
    updateSubmitData(dataObj) {
        const name = this.form.find(".name-input").first().val();
        const sku = this.form.find(".sku-input").first().val();
        const imageUrl = this.form.find(".image_url-input").first().val();
        const description = this.form.find(".description-input").first().val();
        const manufacturerId = this.manufacturerInput.value();
        const assetTypeId = this.assetTypeInput.value();
        let assetModel = {};
        if (this.assetModelId) {
            assetModel['id'] = this.assetModelId;
        }
        assetModel['companyId'] = this.companyId;
        assetModel['modelName'] = name;
        assetModel['manufacturerId'] = manufacturerId;
        assetModel['assetTypeId'] = assetTypeId;
        assetModel['sku'] = sku;
        assetModel['imageUrl'] = imageUrl;
        assetModel['description'] = description;
        dataObj['assetModel'] = assetModel;
    }
    initForm() {
        const data = {
            elementId: this.Id,
        };
        this.form = $(this.mustache.to_html(FORM_TEMPLATE$3, data));
        this.parentEl.append(this.form);
        this.manufacturerInput = this.form.find(".manufacturer-input").first()
            .kendoDropDownList({
            dataTextField: "text",
            dataValueField: "value",
        })
            .data("kendoDropDownList");
        this.assetTypeInput = this.form.find(".asset_type-input").first()
            .kendoDropDownList({
            dataTextField: "text",
            dataValueField: "value",
        })
            .data("kendoDropDownList");
    }
    // ** UTILS **
    populateFields(data) {
        this.form.find(".name-input").first().val(data.modelName);
        this.form.find(".image_url-input").first().val(data.imageUrl);
        this.form.find(".sku-input").first().val(data.sku);
        this.form.find(".description-input").first().val(data.description);
        const manufacturerId = this.manufacturers.getManufacturersDropdownData().find(item => item.text == data.manufacturerName).value;
        this.manufacturerInput.value(manufacturerId);
        const assetTypeId = this.assetTypes.getAssetTypesDropdownData().find(item => item.text == data.assetTypeName).value;
        this.assetTypeInput.value(assetTypeId);
    }
}
const FORM_TEMPLATE$3 = `
        <div id="{{elementId}}" class="asset-models-form" style="display: none;">
            <div class="m-stack" style="width: 100%">
                <div class="m-form-control">
                    <p class="m-label">Name</p>
                    <input class="m-input name-input" type="text" placeholder="e.g HashMaster 5000"/>
                    <p class="m-help-text is-error error-msg name-invalid" style="display: none;">Name required</p>
                </div>
                <div class="m-form-control">
                    <p class="m-label">Manufacturer</p>
                    <input type="text" data-form-type="other" class="m-input manufacturer-input" style="padding-left:0px;padding-right:0px;" autocomplete="off" />
                    <p class="m-help-text is-error error-msg manufacturer-invalid" style="display: none;">Manufacturer required</p>
                </div>
                <div class="m-form-control">
                    <p class="m-label">Asset Type</p>
                    <input type="text" data-form-type="other" class="m-input asset_type-input" style="padding-left:0px;padding-right:0px;" autocomplete="off" />
                    <p class="m-help-text is-error error-msg asset_type-invalid" style="display: none;">Asset Type required</p>
                </div>
                <div class="m-form-control">
                    <p class="m-label">Image Url</p>
                    <input class="m-input image_url-input" type="text" placeholder=""/>
                </div>
                <div class="m-form-control">
                    <p class="m-label">SKU</p>
                    <input class="m-input sku-input" type="text" placeholder=""/>
                </div>
                <div class="m-form-control">
                    <p class="m-label">Description</p>
                    <textarea class="m-textarea description-input" type="text" placeholder=""/>
                </div>
            </div>
        </div>
    `;

class AssetTypesFormView {
    constructor(Id, parentEl) {
        this.Id = Id;
        this.parentEl = parentEl;
        this.assetTypesUrl = "/AssetTypes";
        this.mustache = window.Mustache;
        this.httpService = new OptiFleetService();
        this.initForm();
    }
    title() { return null; }
    // set display to true for view content
    show() { this.form.css("display", "flex"); }
    // set display to none for view content
    hide() { this.form.css("display", "none"); }
    // called on modal init. Should make http GET to initialize for fields
    load(assetType) {
        if (!assetType)
            return;
        this.assetTypeId = assetType.id;
        this.populateFields(assetType);
    }
    confirm(submitCallback) { submitCallback && submitCallback(); }
    // validate form fields
    validate() {
        let success = true;
        // Name Validation
        const nameInput = this.form.find(".name-input").first();
        const nameError = this.form.find(".name-invalid").first();
        if (nameInput.val().length == 0) {
            nameError.hasClass("active") || nameError.addClass("active");
            success = false;
        }
        else {
            nameError.removeClass("active");
        }
        // Description Validation
        const descriptionInput = this.form.find(".description-input").first();
        const descriptionError = this.form.find(".description-error");
        if (descriptionInput.val().length == 0) {
            descriptionError.hasClass("active") || descriptionError.addClass("active");
            success = false;
        }
        else {
            descriptionError.removeClass("active");
        }
        return success;
    }
    // reset form values if not saved
    reset() {
        this.form.find(".name-input").first().val("");
        this.form.find(".description-input").first().val("");
        this.form.find(".consumable-input").first().prop("checked", false);
    }
    // add key/value pairs to the object passed in
    updateSubmitData(dataObj) {
        const name = this.form.find(".name-input").first().val();
        const description = this.form.find(".description-input").first().val();
        const consumable = this.form.find(".consumable-input").first().prop("checked");
        let assetType = {};
        if (this.assetTypeId) {
            assetType['id'] = this.assetTypeId;
        }
        assetType['companyId'] = this.companyId;
        assetType['name'] = name;
        assetType['description'] = description;
        assetType['ConsumableInventory'] = consumable;
        dataObj['assetType'] = assetType;
    }
    initForm() {
        const data = {
            elementId: this.Id,
        };
        this.form = $(this.mustache.to_html(FORM_TEMPLATE$2, data));
        this.parentEl.append(this.form);
    }
    // ** UTILS **
    populateFields(data) {
        this.form.find(".name-input").first().val(data.name);
        this.form.find(".description-input").first().val(data.description);
        this.form.find(".consumable-input").first().prop("checked", data.type == "Consumable");
    }
}
const FORM_TEMPLATE$2 = `
        <div id="{{elementId}}" class="asset-types-form" style="display: none;">
            <div class="m-stack" style="width: 100%">
                <div class="m-form-control">
                    <p class="m-label">Name</p>
                    <input class="m-input name-input" type="text" placeholder="e.g Miner"/>
                </div>
                <div class="m-form-control">
                    <p class="m-label">Description</p>
                    <textarea class="m-textarea description-input" type="text" placeholder="e.g ASIC"/>
                </div>
                <div class="m-stack is-horizontal">
                    <p class="m-label">Consumable</p>
                    <input class="consumable-input" type="checkbox"/>
                </div>
            </div>
        </div>
    `;

var RackDetailsFormType;
(function (RackDetailsFormType) {
    RackDetailsFormType[RackDetailsFormType["AddRack"] = 0] = "AddRack";
    RackDetailsFormType[RackDetailsFormType["EditRack"] = 1] = "EditRack";
    RackDetailsFormType[RackDetailsFormType["AddZone"] = 2] = "AddZone";
    RackDetailsFormType[RackDetailsFormType["CreateSite"] = 3] = "CreateSite";
})(RackDetailsFormType || (RackDetailsFormType = {}));
const CONFIRMATION_TEXT = "You are about to remove slots linked to active miners.Are your sure you want to remove them from the site map?";
class RackDetailsFormView {
    constructor(parentEl, formType) {
        this.parentEl = parentEl;
        this.formType = formType;
        this.initialLinkedMinerCount = 0;
        this.zones = [];
        this.httpService = new OptiFleetService();
        this.deleteMinersModal = new OpConfirmationModal("DeleteConfirmationModal", this.deleteRack.bind(this));
        this.confirmUnlinkMinersModal = new OpConfirmationModal("UnlinkMinersConfirmationModal");
        this.init();
    }
    init() {
        const data = {
            allowAddZone: this.getAllowAddZone()
        };
        this.el = $(this.mustache(TEMPLATE, data));
        this.parentEl.append(this.el);
        this.el.find(".add-another-zone").on("click", this.addZone.bind(this));
        this.zoneListEl = this.el.find(".new-zone-list");
        this.addZone();
    }
    title() {
        switch (this.formType) {
            case RackDetailsFormType.EditRack:
                return "Rack Details";
            default:
                return "Zone Details";
        }
    }
    // set display to true for view content
    show() { this.el.addClass("active"); }
    // set display to none for view content
    hide() { this.el.removeClass("active"); }
    load(initData) {
        if (!initData)
            return;
        this.zoneListEl.empty();
        this.zones = [];
        initData.forEach(zoneDetails => {
            const zoneData = {
                zoneDetails,
                cardType: this.getZoneCardType(),
                onDelete: this.openDeleteRackConfirmation.bind(this, zoneDetails.zoneId)
            };
            const zoneClass = new ZoneCard(this.zoneListEl, zoneData);
            this.zones.push(zoneClass);
        });
        let linkedMinerCount = 0;
        this.zones.forEach(zone => linkedMinerCount += zone.linkedMinerCount());
        this.initialLinkedMinerCount = linkedMinerCount;
    }
    confirm(submitCallback) {
        let newLinkedMinerCount = 0;
        this.zones.forEach(zone => newLinkedMinerCount += zone.linkedMinerCount());
        if (this.initialLinkedMinerCount > newLinkedMinerCount) {
            this.confirmUnlinkMinersModal.postSubmitHandler = submitCallback;
            this.confirmUnlinkMinersModal.open({ primaryText: CONFIRMATION_TEXT });
        }
        else {
            submitCallback();
        }
    }
    validate() {
        let success = true;
        // validate zones
        let zoneNames = [];
        this.zones.forEach(zone => {
            const zoneData = zone.getZone();
            const zoneName = zoneData.zoneName;
            if (zoneName === "") {
                zone.invalidate("Zone name required");
                success = false;
            }
            else if (zoneNames.includes(zoneName)) {
                zone.invalidate("Duplicate zone name");
                success = false;
            }
            else {
                zone.validate();
            }
            zoneNames.push(zoneName);
            // validate racks
            let rackNames = [];
            zone.racks.forEach(rack => {
                const rackName = rack.rackName();
                if (rackName === "") {
                    rack.invalidate("Rack name required");
                    success = false;
                }
                else if (rackNames.includes(rackName)) {
                    rack.invalidate("Duplicate rack name");
                    success = false;
                }
                else {
                    rack.validate();
                }
                rackNames.push(rackName);
                // validate rows
                let rowNames = [];
                var regExp = / [^0-9]/g;
                rack.rows.forEach(row => {
                    const rowName = Number(row.rowName());
                    if (regExp.test(row.rowName()) || !rowName || rowNames.includes(rowName)) {
                        row.invalidate();
                        success = false;
                    }
                    else {
                        row.validate();
                    }
                    rowNames.push(rowName);
                });
            });
        });
        return success;
    }
    reset() {
        $(".zone-details-form-view").remove();
        this.zoneListEl.empty();
        this.zones = [];
        this.init();
    }
    updateSubmitData(dataObj) {
        if (this.siteId) {
            dataObj["siteId"] = this.siteId;
        }
        dataObj["Zones"] = this.zones.map(zone => zone.getZone());
    }
    addZone() {
        const zoneData = {
            zoneDetails: ZoneCard.DEFAULT_ZONE,
            cardType: this.getZoneCardType(),
            onDelete: this.deleteRack.bind(this),
        };
        let zoneClass = new ZoneCard(this.zoneListEl, zoneData);
        this.zones.push(zoneClass);
    }
    openDeleteRackConfirmation(zoneId) {
        const rackToDelete = this.zones.find(zone => zone.id == zoneId).racks[0];
        if (rackToDelete.hasLinkedMiners()) {
            this.deleteMinersModal.open({ primaryText: CONFIRMATION_TEXT });
        }
        else {
            this.deleteRack(zoneId);
        }
    }
    deleteRack(zoneId) {
        const zone = this.zones.find(zone => zone.id == zoneId);
        const rackName = zone.racks[0].rackName();
        const data = {
            siteId: this.siteId,
            zoneId,
            rackName
        };
        this.progressionModal.toggleModalBusy(true);
        this.httpService.delete("/Rack", data).then((res) => {
            this.progressionModal.toggleModalBusy(false);
            if (!res.success) {
                this.progressionModal.showErrorMessage("Failed to delete rack");
            }
            this.progressionModal.hideErrorMessage();
            this.progressionModal._close();
            return;
        });
    }
    getZoneCardType() {
        switch (this.formType) {
            case RackDetailsFormType.AddRack:
                return ZoneCardType.ViewWithRackEdit;
            case RackDetailsFormType.EditRack:
                return ZoneCardType.ViewWithRackDelete;
            case RackDetailsFormType.AddZone:
                return ZoneCardType.FullWrite;
            case RackDetailsFormType.CreateSite:
                return ZoneCardType.FullWrite;
        }
    }
    getAllowAddZone() {
        switch (this.formType) {
            case RackDetailsFormType.AddZone:
            case RackDetailsFormType.CreateSite:
                return true;
            default:
                return false;
        }
    }
    // ** UTILS **
    getComponent(genericId = "") {
        return $(`#${this.el.id}${genericId}`);
    }
    mustache(template, params) {
        // For some reason the mustache function was causing issues in my IDE -Andy
        return self.Mustache.to_html(template, params);
    }
}
const TEMPLATE = `
    <div id="<%# ViewId %>" class="zone-details-form-view m-stack">

        <div class="new-zone-list m-stack"></div>

        {{#allowAddZone}}
            <div class="m-stack m-section">
                <button class="m-button add-another-zone" type="button">+ Add Another Zone</button>
            </div>
        {{/allowAddZone}}
    </div>
    `;

class RebootRestrictionModal extends OpProgressionModalBase {
    constructor(Id) {
        const view = new RebootRestrictionModalView($(`#${Id}ViewWrapper`));
        super(Id, [view], {
            submitUrl: "/RebootRestrictions",
            submitType: ProgressionModalSubmitType.POST,
        });
        this.Id = Id;
        this.view = view;
    }
    setSiteId(siteId) {
        this.view.siteId = siteId;
    }
    setZones(zones) {
        this.view.setZones(zones);
    }
    setMiners(miners) {
        this.view.setMiners(miners);
    }
    loadData(initData) {
        this.view.load(initData);
    }
}
class RebootRestrictionModalView {
    constructor(parentEl) {
        this.parentEl = parentEl;
        this.rebootRestrictionsUrl = "/RebootRestrictions";
        this.mustache = window.Mustache;
        this.zones = [];
        this.miners = [];
        this.forms = [];
        this.httpService = new OptiFleetService();
        this.init();
    }
    setZones(zones) {
        this.zones = zones;
        this.updateForms();
    }
    setMiners(miners) {
        this.miners = miners;
        this.updateForms();
    }
    title() { return "Reboot Restrictions"; }
    // set display to true for view content
    show() { this.parentEl.addClass("active"); }
    // set display to none for view content
    hide() { this.parentEl.removeClass("active"); }
    // called on modal init. Should make http GET to initialize for fields
    load(initData) {
        this.reset();
        this.addNewForm();
        if (!initData)
            return;
        this.populateFormData(initData);
        this.rebootRestrictionsId = initData.rebootRestrictionsId;
    }
    confirm(submitCallback) { submitCallback && submitCallback(); }
    // validate form fields
    validate() {
        return true;
    }
    // reset form values if not saved
    reset() {
        this.forms.forEach(form => {
            form.remove();
        });
        this.forms = [];
    }
    // add key/value pairs to the object passed in
    updateSubmitData(dataObj) {
        dataObj['restrictions'] = this.forms.map(form => {
            form.find(".duration-units").last().data("kendoDropDownList").value();
            return {
                siteId: this.siteId,
                rebootRestrictionsId: this.rebootRestrictionsId,
                startTime: form.find(".start-time").last().data("kendoDateTimePicker").value(),
                repeat: form.find(".repeat").last().data("kendoDropDownList").value() === "1",
                duration: Number(form.find(".duration").last().data("kendoDropDownList").value()),
                ZoneIds: form.find(".zone-boundary").last().data("kendoMultiSelect").value(),
                MinerIds: form.find(".miner-boundary").last().data("kendoMultiSelect").value(),
            };
        });
    }
    init() {
        const parentTemplate = $(this.mustache.to_html(PARENT_TEMPLATE));
        parentTemplate.find(".add-new-form").first().click(this.addNewForm.bind(this));
        this.parentEl.empty().append(parentTemplate);
        this.addNewForm();
    }
    addNewForm() {
        const template = $(this.mustache.to_html(FORM_TEMPLATE$1));
        this.parentEl.find(".form-list").append(template);
        const formIndex = this.forms.length;
        this.forms.push(template);
        template.find(".remove-restriction").click(this.removeForm.bind(this, formIndex));
        template.find(".start-time").kendoDateTimePicker({}).data("kendoDateTimePicker").value(new Date());
        template.find(".repeat").kendoDropDownList({
            dataTextField: "name",
            dataValueField: "value",
            dataSource: REPEAT_LIST,
            height: 200,
            autoWidth: true
        }).data("kendoDropDownList");
        template.find(".duration").kendoDropDownList({
            dataSource: [...Array(12)].map((_, i) => { return { name: i + 1, value: i + 1 }; }),
            dataTextField: "name",
            dataValueField: "value",
        });
        template.find(".duration-units").kendoDropDownList({
            dataSource: ["Minute(s)", "Hour(s)"],
            value: "Hour(s)",
            change: (e) => {
                let values = [...Array(12)].map((_, i) => { return { name: i + 1, value: (i + 1) * 60 }; });
                if (e.sender.value() === "Minute(s)") {
                    values = [...Array(60)].map((_, i) => { return { name: i + 1, value: i + 1 }; });
                }
                const input = this.forms[formIndex].find("input.duration").first();
                input.data("kendoDropDownList").dataSource.data(values);
                input.data("kendoDropDownList").value(values[values.length - 1].value.toString());
                input.data("kendoDropDownList").trigger('change');
            }
        });
        template.find(".zone-boundary").kendoMultiSelect({
            dataSource: this.zones,
            dataTextField: "zoneName",
            dataValueField: "zoneId",
            autoClose: false,
            placeholder: "Choose zones...",
        });
        template.find(".miner-boundary").kendoMultiSelect({
            dataSource: this.miners,
            dataTextField: "minerName",
            dataValueField: "minerId",
            autoClose: false,
            placeholder: "Choose miners...",
        });
    }
    removeForm(formIndex, event) {
        const form = this.forms.splice(event, 1);
        form.pop().remove();
        this.forms.forEach((form, index) => {
            form.find(".remove-restriction")
                .off("click")
                .click(this.removeForm.bind(this, index));
        });
    }
    updateForms() {
        this.forms.forEach(form => {
            form.find(".zone-boundary").kendoMultiSelect({
                dataSource: this.zones,
                dataTextField: "zoneName",
                dataValueField: "zoneId",
                autoClose: false,
            });
            form.find(".miner-boundary").kendoMultiSelect({
                dataSource: this.miners,
                dataTextField: "minerName",
                dataValueField: "minerId",
                autoClose: false,
            });
        });
    }
    populateFormData(data) {
        if (this.forms.length !== 1)
            throw "can only edit one reboot restriction at a time";
        const durationUnits = data.duration % 60 === 0 ? "Hour(s)" : "Minute(s)";
        const form = this.forms[0];
        form.find(".start-time").last().data("kendoDateTimePicker").value(data.startTime);
        form.find(".repeat").last().data("kendoDropDownList").value(data.repeat ? "1" : "0");
        const durationUnitsInput = form.find(".duration-units").last().data("kendoDropDownList");
        durationUnitsInput.value(durationUnits);
        durationUnitsInput.trigger("change");
        form.find(".duration").last().data("kendoDropDownList").value(String(data.duration));
        form.find(".zone-boundary").last().data("kendoMultiSelect").value(data.zones);
        form.find(".miner-boundary").last().data("kendoMultiSelect").value(data.miners);
    }
}
const REPEAT_LIST = [
    { name: "None", value: 0 },
    { name: "Daily", value: 1 },
];
const PARENT_TEMPLATE = `
        <div class="m-box m-stack reboot-restriction-form">
            <div class="m-stack form-list"></div>

            <div style="display:flex;justify-content:end">
                <button class="m-button is-secondary add-new-form" type="button">Add Reboot Restriction</div>
            </div>
        </div>
    `;
const FORM_TEMPLATE$1 = `
    <div class="m-box reboot-restriction-form-card">
            <div class="clickable remove-restriction" style="display:flex; justify-content:end;">
                <span><m-icon name="x-circle"></m-icon></span>
            </div>
        <div class="m-stack ">
            <div class="m-form-group">
                <div class="m-form-control" style="width: 100%;">
                    <label class="m-label is-required">Start Time</label>
                    <input class="m-input start-time" />
                </div> 
                <div class="m-form-control" style="width: 100%;">
                    <label class="m-label is-required">Repeat</label>
                    <input class="m-input repeat" />
                </div> 
            </div>
            <div class="m-form-group">
                <div class="m-form-control" style="width: 100%;">
                    <label class="m-label is-required">Duration</label>
                    <input class="m-input duration" />
                </div> 
                <div class="m-form-control" style="width: 100%;">
                    <label class="m-label" style="color: rgba(0,0,0,0);">Duration Unit</label>
                    <input class="m-input duration-units" />
                </div> 
            </div>
            <div class="m-form-group">
                <div class="m-form-control" style="width: 100%;">
                    <label class="m-label is-required">Zone Boundary</label>
                    <input class="m-input zone-boundary" data-placeholder="Choose zones..."/>
                </div> 
                <div class="m-form-control" style="width: 100%;">
                    <label class="m-label">Miner Boundary</label>
                    <input class="m-input miner-boundary" data-placeholder="Choose miners..." />
                </div> 
            </div>
        </div>
    </div>
    `;

class SiteDetailsFormView {
    constructor(Id) {
        this.Id = Id;
        this.siteDetailsUrl = "/siteDetails";
        this.httpService = new OptiFleetService();
    }
    title() { return "Site Details"; }
    // set display to true for view content
    show() { this.getComponent().addClass("active"); }
    // set display to none for view content
    hide() { this.getComponent().removeClass("active"); }
    // called on modal init. Should make http GET to initialize for fields
    load(siteId) {
        if (!siteId)
            return;
        return new Promise(resolve => {
            this.httpService.get(`${this.siteDetailsUrl}?siteId=${siteId}`)
                .then((resp) => {
                this.populateFields(resp);
                resolve();
            });
        });
    }
    confirm(submitCallback) { submitCallback && submitCallback(); }
    // validate form fields
    validate() {
        let success = true;
        // Site Name Validation
        const siteNameInput = this.getComponent("siteNameInput");
        const siteNameError = this.getComponent("siteNameInvalid");
        if (siteNameInput.val().length == 0) {
            siteNameError.hasClass("active") || siteNameError.addClass("active");
            success = false;
        }
        else {
            siteNameError.removeClass("active");
        }
        // Current Capacity Validation
        const currentCapInput = this.getComponent("currentCapacityInput");
        const currentCapError = this.getComponent("currentCapacityInvalid");
        if (currentCapInput.val().length == 0 || !$.isNumeric(currentCapInput.val())) {
            currentCapError.hasClass("active") || currentCapError.addClass("active");
            success = false;
        }
        else {
            currentCapError.removeClass("active");
        }
        // Potential Capacity Validation
        const potentialCapInput = this.getComponent("potentialCapacityInput");
        const potentialCapError = this.getComponent("potentialCapacityInvalid");
        if (potentialCapInput.val().length == 0 || !$.isNumeric(potentialCapInput.val())) {
            potentialCapError.hasClass("active") || potentialCapError.addClass("active");
            success = false;
        }
        else {
            potentialCapError.removeClass("active");
        }
        return success;
    }
    // reset form values if not saved
    reset() {
        this.getComponent("siteNameInput").val("");
        this.getComponent("currentCapacityInput").val("");
        this.getComponent("potentialCapacityInput").val("");
    }
    // add key/value pairs to the object passed in
    updateSubmitData(dataObj) {
        const siteName = this.getComponent("siteNameInput").val();
        const currentCap = this.getComponent("currentCapacityInput").val();
        const potentialCap = this.getComponent("potentialCapacityInput").val();
        dataObj['siteName'] = siteName.trim();
        dataObj['powerCapacity'] = currentCap;
        dataObj['potentialPowerCapacity'] = potentialCap;
    }
    // ** UTILS **
    populateFields(resp) {
        this.getComponent("siteNameInput").val(resp.siteName);
        this.getComponent("currentCapacityInput").val(resp.powerCapacity);
        this.getComponent("potentialCapacityInvalid")
            .val(resp.zones.reduce((n, { capacity }) => n + capacity, 0));
    }
    getComponent(genericId = "") {
        return $(`#${this.Id}${genericId}`);
    }
}

class SelectFilters {
    constructor(id, filters, applyFunc) {
        this.id = id;
        this.filters = filters;
        this.applyFunc = applyFunc;
        $(window).click((event) => {
            if (!$(event.target).parents(`[c-id=${this.id}]`).length) {
                $(`[c-id=${this.id}]`).removeClass("open");
            }
        });
        $(`[c-id=${id}Select]`).on("click", this.toggleFilterOptions.bind(this));
        $(`[c-id=${id}ApplyBtn]`).on("click", this.applyFilter.bind(this));
        this.init();
    }
    init() {
        this.filters.forEach(filter => {
            $(`[c-id=${this.id}Options]`).append(`<div class="option m-menu-item" c-id="${filter.id}MenuItem"><span>${filter.label}</span><input type="checkbox" class="k-checkbox" c-id="${filter.id}Option" ${filter.show ? "checked" : ""} /></div>`);
            $(`[c-id=${filter.id}MenuItem]`).on("click", this.clickCheckbox.bind(this, `${filter.id}Option`));
            $(`[c-id=${filter.id}Option]`).on("click", this.clickCheckbox.bind(this, `${filter.id}Option`));
        });
    }
    clickCheckbox(id) {
        const isChecked = $(`[c-id=${id}]`).is(":checked");
        $(`[c-id=${id}]`).prop("checked", !isChecked);
    }
    toggleFilterOptions() {
        $(`[c-id=${this.id}]`).toggleClass("open");
    }
    applyFilter(e) {
        e.preventDefault();
        $(`[c-id=${this.id}]`).removeClass("open");
        let newFilters = [];
        this.filters.forEach(filter => {
            const isChecked = $(`[c-id=${filter.id}Option]`).is(":checked");
            newFilters.push({ label: filter.label, id: filter.id, show: isChecked });
        });
        this.applyFunc(newFilters);
    }
}

var DefaultTickeFieldDropdownList;
(function (DefaultTickeFieldDropdownList) {
    DefaultTickeFieldDropdownList[DefaultTickeFieldDropdownList["NULL"] = 0] = "NULL";
    DefaultTickeFieldDropdownList[DefaultTickeFieldDropdownList["Status"] = 1] = "Status";
    DefaultTickeFieldDropdownList[DefaultTickeFieldDropdownList["Priority"] = 2] = "Priority";
    DefaultTickeFieldDropdownList[DefaultTickeFieldDropdownList["Label"] = 3] = "Label";
})(DefaultTickeFieldDropdownList || (DefaultTickeFieldDropdownList = {}));
const VARIANTS = [
    'is-indigo',
    'is-plum',
    'is-red',
    'is-amber',
    'is-accent',
];
class OpTicketFieldDropdown {
    constructor(id, itemList, iconSvg) {
        this.id = id;
        this.canEdit = false;
        this.TICKET_STATUS_LIST = [
            { id: 1, icon: formatIconBuff(TICKET_STATUS_ICON_MAP[1]), label: "Open" },
            { id: 3, icon: formatIconBuff(TICKET_STATUS_ICON_MAP[3]), label: "In Progress" },
            { id: 2, icon: formatIconBuff(TICKET_STATUS_ICON_MAP[2]), label: "Closed" },
            { id: 5, icon: formatIconBuff(TICKET_STATUS_ICON_MAP[5]), label: "Canceled" },
            { id: 6, icon: formatIconBuff(TICKET_STATUS_ICON_MAP[6]), label: "Duplicate" },
        ];
        this.TICKET_PRIORITY_LIST = [
            { id: 1, icon: formatIconBuff(TICKET_PRIORITY_ICON_MAP[1]), label: "Low" },
            { id: 2, icon: formatIconBuff(TICKET_PRIORITY_ICON_MAP[2]), label: "Medium" },
            { id: 3, icon: formatIconBuff(TICKET_PRIORITY_ICON_MAP[3]), label: "High" },
            { id: 4, icon: formatIconBuff(TICKET_PRIORITY_ICON_MAP[4]), label: "Critical" },
        ];
        this.TICKET_LABEL_LIST = [
            { id: 4, icon: "", label: "General" },
            { id: 7, icon: "", label: "Reboot" },
            { id: 6, icon: "", label: "Fan replacement" },
            { id: 3, icon: "", label: "Installation" },
            { id: 2, icon: "", label: "Configuration" },
            { id: 5, icon: "", label: "Facility maintenance" },
            { id: 1, icon: "", label: "RMA" },
        ];
        this.DEFAULT_LISTS = [
            null,
            this.TICKET_STATUS_LIST,
            this.TICKET_PRIORITY_LIST,
            this.TICKET_LABEL_LIST,
        ];
        this.elem = document.getElementById(`${id}TicketFieldDropdown`);
        if (!this.elem)
            return;
        this.elem.onclick = this.toggleMenu.bind(this);
        this.overlayId = `#${id}TicketFieldOverlay`;
        const overlay = document.getElementById(`${id}TicketFieldOverlay`);
        overlay.onclick = this.toggleMenu.bind(this);
        this.htmlPanelId = `#${id}TicketFieldDropdownPanel`;
        this.htmlListId = `#${id}SelectionList`;
        this.htmlSelectedValueId = `#${id}SelectedValue`;
        this.htmlSelectedIconId = `#${id}Icon`;
        this.iconSvg = iconSvg && formatIconBuff(iconSvg);
        itemList && this.setOptions(this.DEFAULT_LISTS[itemList]);
    }
    setOptions(options, preselectedId) {
        this.listItems = options;
        $(this.htmlListId).html("");
        const isPreselectedIdValid = preselectedId !== "" && preselectedId !== "-1";
        (preselectedId && isPreselectedIdValid) ? this.setDefaultValue(preselectedId) : this.setDefaultValue(this.listItems[0].id);
        //this.setDefaultValue(this.listItems[0].id)
        options.forEach((value, index) => {
            value['htmlId'] = `${this.elem.id}ListItem${index}`;
            value['index'] = index;
            let template;
            if (value.icon) {
                template = self.Mustache.to_html(TicketDetailTemplates.TICKET_DROPDOWN_LIST_ITEM, value);
                $(this.htmlListId).append(template);
            }
            else if (value.el) {
                if (value.id === -1) {
                    value['initial'] = "UA";
                    value['variant'] = "is-neutral";
                }
                else {
                    value['initial'] = value.label.slice(0, 2).toUpperCase();
                    value['variant'] = VARIANTS[value.id % VARIANTS.length];
                }
                template = self.Mustache.to_html(TicketDetailTemplates.TICKET_DROPDOWN_LIST_ITEM_W_ELEMENT, value);
                $(this.htmlListId).append(template);
                $(`#ticketListItemEl${index}`).html(value.el);
            }
            else {
                template = self.Mustache.to_html(TicketDetailTemplates.TICKET_DROPDOWN_LIST_ITEM_WO_ICON, value);
                $(this.htmlListId).append(template);
            }
            const el = document.getElementById(value['htmlId']);
            if (!this.canEdit) {
                el.onclick = this.onOptionSelect.bind(this, value.id);
            }
        });
    }
    onOptionSelect(id, e) {
        const prevOption = this.listItems.find(item => item.id === this.selectedId);
        const selectedOption = this.listItems.find(item => item.id === id);
        this.setDefaultValue(id);
        if (this.onSelectionChanged) {
            this.onSelectionChanged(this.id, selectedOption, prevOption).then(() => {
                this.closeMenu();
            });
        }
    }
    setDefaultValue(id) {
        this.selectedId = id;
        const item = this.listItems.find(i => i.id === parseInt(id) || i.label === id);
        if (!item)
            return;
        $(this.htmlSelectedIconId).html("");
        if ((item === null || item === void 0 ? void 0 : item.icon) || this.iconSvg && !(item === null || item === void 0 ? void 0 : item.el)) {
            $(this.htmlSelectedIconId).append(formatIconSvgFromBuff((item === null || item === void 0 ? void 0 : item.icon) || this.iconSvg));
        }
        else if (item === null || item === void 0 ? void 0 : item.el) {
            $(this.htmlSelectedIconId).append(item.el);
        }
        $(this.htmlSelectedValueId).text(item.label);
    }
    toggleReadOnly(isReadOnly) {
    }
    toggleMenu() {
        let hasClass = $(this.htmlPanelId).hasClass('active');
        if (!this.canEdit) {
            hasClass = true;
        }
        if (hasClass) {
            $(this.htmlPanelId).removeClass('active');
            $(this.overlayId).removeClass('active');
        }
        else {
            $(this.htmlPanelId).addClass('active');
            $(this.overlayId).addClass('active');
        }
    }
    closeMenu() {
        $(this.htmlPanelId).removeClass('active');
        $(this.overlayId).removeClass('active');
    }
    getSelectedValue() {
        return this.listItems.find(i => i.id === Number(this.selectedId) || i.label === String(this.selectedId));
    }
    reset() {
        this.setDefaultValue(this.listItems[0].id);
    }
}
function formatIconSvgFromBuff(buff) {
    return `<img src='data:image/svg+xml;base64,${buff}' alt = "" />`;
}
function formatIconBuff(svg) {
    return btoa(unescape(encodeURIComponent(svg)));
}

const MIN = 60;
const HOUR = MIN * 60;
const DAY = HOUR * 24;
const RELATIVE_TIMES = {
    "30m": 30 * MIN,
    "1h": HOUR,
    "3h": 3 * HOUR,
    "6h": 6 * HOUR,
    "12h": 12 * HOUR,
    "24h": DAY,
    "2d": 2 * DAY,
    "7d": 7 * DAY,
    "2w": 14 * DAY
};
var STEPS;
(function (STEPS) {
    STEPS["MINUTE"] = "minute";
    STEPS["FIFTEEN_MINUTE"] = "fifteen_minute";
    STEPS["HOURLY"] = "hourly";
    STEPS["DAILY"] = "daily";
})(STEPS || (STEPS = {}));
function getStepsFromString(stepString) {
    switch (stepString) {
        case STEPS.MINUTE:
            return STEPS.MINUTE;
        case STEPS.FIFTEEN_MINUTE:
            return STEPS.FIFTEEN_MINUTE;
        case STEPS.HOURLY:
            return STEPS.HOURLY;
        case STEPS.DAILY:
            return STEPS.DAILY;
        default:
            throw "Step not implemented";
    }
}
const STEP_VALUES = {
    "minute": MIN,
    "fifteen_minute": 15 * MIN,
    "hourly": HOUR,
    "daily": DAY,
};
class TimePickerDropdown {
    constructor(overrideSteps = []) {
        this.availableSteps = Object.values(STEPS);
        // Styling State
        this.lastRangeTypeSelectionId = null;
        this.lastRelativeSelectionId = null;
        this.lastStepSelectionId = null;
        if (overrideSteps.length > 0) {
            this.availableSteps = overrideSteps.map(s => getStepsFromString(s));
        }
        this.rangeTypeComp = $(`[c-id=${TimePickerDropdown.eventId}RangeTypeWrapper]`);
        this.relativeRangeText = $(`[c-id=${TimePickerDropdown.eventId}RelativeRangeText]`);
        this.absoluteRangeText = $(`[c-id=${TimePickerDropdown.eventId}AbsoluteRangeText]`);
        this.rangeValueComp = $(`[c-id=${TimePickerDropdown.eventId}RangeValueWrapper]`);
        this.stepSelectorComp = $(`[c-id=${TimePickerDropdown.eventId}StepWrapper]`);
        this.rangeTypeComp.find(".selector").on("click", this.toggleRangeTypeDropdown.bind(this));
        this.rangeValueComp.find(".selector").on("click", this.toggleRangeValueDropdown.bind(this));
        this.stepSelectorComp.find(".selector").on("click", this.toggleStepDropdown.bind(this));
        $("#absoluteRangeSubmitButton").on("click", this.selectAbsoluteRange.bind(this));
        $(window).click((event) => {
            if (!$(event.target).parents(`[c-id=${TimePickerDropdown.eventId}RangeTypeWrapper]`).length) {
                this.rangeTypeComp.removeClass("open");
            }
        });
        $(window).click((event) => {
            if (!$(event.target).parents(`[c-id=${TimePickerDropdown.eventId}RangeValueWrapper]`).length) {
                this.rangeValueComp.removeClass("open");
            }
        });
        $(window).click((event) => {
            if (!$(event.target).parents(`[c-id=${TimePickerDropdown.eventId}StepWrapper]`).length) {
                this.stepSelectorComp.removeClass("open");
            }
        });
        //$("#timezone").text(Intl.DateTimeFormat().resolvedOptions().timeZone);
        this.initRangeType();
        this.initDatePicker();
        this.initRelativeTime();
        this.initStep();
        this.submit();
    }
    /**
     * MUST be called by the parent page TS file so the data can be retrieved
     * @param callback
     */
    static addEventListener(callback) {
        document.addEventListener(TimePickerDropdown.eventId, callback);
    }
    toggleRangeTypeDropdown() {
        this.rangeTypeComp.toggleClass("open");
    }
    toggleRangeValueDropdown() {
        this.rangeValueComp.toggleClass("open");
    }
    toggleStepDropdown() {
        this.stepSelectorComp.toggleClass("open");
    }
    /**
     * fires an event (the parent page should have a registered callback - see `this.addEventListener`)
     * that contains the required prometheus query params
     */
    submit() {
        localStorage.setItem("timePickerRel", this.lastRelativeSelectionId);
        localStorage.setItem("timePickerStep", this.lastStepSelectionId);
        const event = new CustomEvent(TimePickerDropdown.eventId, {
            detail: {
                start: this.start,
                end: this.end,
                step: this.step
            }
        });
        event.preventDefault();
        document.dispatchEvent(event);
    }
    initStep() {
        var _a;
        let stepName = (_a = localStorage.getItem("timePickerStep")) !== null && _a !== void 0 ? _a : STEPS.HOURLY;
        this.step = STEP_VALUES[stepName];
        this._selectStep(stepName);
        this.availableSteps.forEach(step => {
            var jstep = $(`#${step}`);
            if (jstep.hasClass("active")) {
                this.setStepText(jstep.text());
            }
        });
    }
    initRelativeTime() {
        var _a;
        let rel = (_a = localStorage.getItem("timePickerRel")) !== null && _a !== void 0 ? _a : "7d";
        let targetEl = $(`#${rel}`);
        targetEl.addClass("active");
        this.lastRelativeSelectionId = rel;
        this.setRangeValueText(targetEl.text());
        let abs = TimePickerDropdown.relativeToAbsolute(rel);
        this.start = abs.start;
        this.end = abs.end;
    }
    initDatePicker() {
        const start = TimePickerDropdown.getLastWeek();
        const end = new Date();
        $("#absoluteDateRangePicker").kendoDateRangePicker({
            labels: false,
            footer: "",
            format: "MM/dd/yy HH:mm:ss",
            range: {
                end: end,
                start: start
            },
            max: new Date(),
            min: new Date("2023-01-01"),
            change: this.selectAbsoluteRange.bind(this)
        });
        //adds a dash between the two date inputs
        const inputsAndSpace = $("#absoluteDateRangePicker").find("span").get();
        if (inputsAndSpace.length === 5) {
            const space = inputsAndSpace[2];
            $(space).addClass("date-range-input-separator");
            $(space).html("&nbsp;-&nbsp;");
        }
    }
    initRangeType() {
        this.relativeRangeText.addClass("active");
        this.absoluteRangeText.removeClass("active");
        this.rangeValueComp.find("#m-icon-calendar-clock").show();
        this.rangeValueComp.find("#m-icon-calendar").hide();
        this.lastRangeTypeSelectionId = this.relativeRangeText.attr("c-id");
    }
    // ** GETTER ***
    /**
     * used by the page to get default Controller params for initializing charts
     * @returns
     */
    static getDefaultParams(defaultStep = STEPS.FIFTEEN_MINUTE, useCache = true) {
        let rel = localStorage.getItem("timePickerRel");
        let stepCache = localStorage.getItem("timePickerStep");
        var start, end, step;
        if (rel && useCache) {
            let abs = TimePickerDropdown.relativeToAbsolute(rel);
            start = abs.start;
            end = abs.end;
        }
        else {
            start = Math.floor(TimePickerDropdown.getLastWeek().getTime() / 1000);
            end = Math.floor(Date.now() / 1000);
        }
        if (stepCache && useCache) {
            step = stepCache;
        }
        else {
            step = defaultStep;
        }
        return {
            start: start,
            end: end,
            step: STEP_VALUES[step]
        };
    }
    /**
     *
     * @param relativeTextString - the text value of a list item in the "relative range"" list
     * used to set the middle text of the dropdown
     */
    setRangeValueText(relativeTextString) {
        if (relativeTextString) {
            this.rangeValueComp.find(".selector-text").text(relativeTextString);
        }
        else {
            const startString = window.moment(this.start * 1000).format("YYYY-MM-DD (HH:mm:ss)");
            const endString = window.moment(this.end * 1000).format("YYYY-MM-DD (HH:mm:ss)");
            this.rangeValueComp.find(".selector-text").text(`${startString} - ${endString}`);
        }
    }
    setStepText(textString) {
        this.stepSelectorComp.find(".selector-text").text(textString);
    }
    /**
     * used to remove the "selected" styling
     * of the last used relative time
     */
    removePrevRelativeStyling() {
        if (this.lastRelativeSelectionId) {
            let lastTargetEl = $(`#${this.lastRelativeSelectionId}`);
            lastTargetEl.removeClass("active");
        }
    }
    /**
     * helper function that saves the start and end time
     * of the kendo range picker
     */
    storeAbsoluteParams() {
        const rangePicker = $("#absoluteDateRangePicker").data("kendoDateRangePicker");
        const range = rangePicker.range();
        if (!range) {
            return;
        }
        if (range.start) {
            this.start = range.start.getTime() / 1000;
        }
        if (range.end) {
            this.end = range.end.getTime() / 1000;
        }
    }
    /**
     * used to manually set the range picker inputs
     * when a relative time is selected
     */
    setAbsoluteTimeInputs() {
        const rangePicker = $("#absoluteDateRangePicker").data("kendoDateRangePicker");
        rangePicker.range({
            end: window.moment(this.end * 1000).toDate(),
            start: window.moment(this.start * 1000).toDate()
        });
    }
    /**
     * used to disable steps that are larger than
     * the selected time range
     */
    handleStepLimits() {
        const currentDiff = this.end - this.start;
        Object.entries(STEP_VALUES).map(entry => {
            const id = entry[0];
            const step = entry[1];
            const availableSteps = this.availableSteps.map(s => s.toString());
            const forceInvalid = !availableSteps.includes(id);
            let targetEl = $(`#${id}`);
            if (forceInvalid) {
                targetEl.addClass("invalid");
            }
            else if (step <= HOUR && currentDiff >= DAY * 30 * 3) {
                targetEl.addClass("invalid");
            }
            else if (step <= MIN * 15 && currentDiff >= DAY * 30) {
                targetEl.addClass("invalid");
            }
            else if (step === MIN && currentDiff > HOUR * 12) {
                targetEl.addClass("invalid");
            }
            else if (step >= currentDiff) {
                targetEl.addClass("invalid");
            }
            else {
                targetEl.removeClass("invalid");
            }
        });
        this.handleStepSelectionLoss();
    }
    handleStepSelectionLoss() {
        if (!$(`#${this.lastStepSelectionId}`).hasClass("invalid")) {
            return;
        }
        var items = this.availableSteps.map((key) => {
            return { "StepName": key, "StepValue": STEP_VALUES[key] };
        });
        items.sort(function compare(kv1, kv2) {
            return kv1["StepValue"] - kv2["StepValue"];
        });
        items.every(kv => {
            if (!$(`#${kv["StepName"]}`).hasClass("invalid")) {
                this._selectStep(kv["StepName"]);
                this.setStepText($("#".concat(kv["StepName"])).text());
                return false;
            }
            return true;
        });
    }
    selectRangeType(e) {
        if (e.attributes.getNamedItem("c-id").value == this.lastRangeTypeSelectionId)
            return;
        this.rangeTypeComp.find(".selector-text").text(e.textContent);
        if (e.attributes.getNamedItem("c-id").value == this.relativeRangeText.attr("c-id")) {
            $(".relative-range-wrapper").addClass("active");
            $(".absolute-range-wrapper").removeClass("active");
            this.absoluteRangeText.removeClass("active");
            this.relativeRangeText.addClass("active");
            this.initRelativeTime();
            this.rangeValueComp.find(".absolute-menu").removeClass("open");
            this.rangeValueComp.find(".options").show();
            this.rangeValueComp.find("#m-icon-calendar-clock").show();
            this.rangeValueComp.find("#m-icon-calendar").hide();
        }
        else {
            $(".relative-range-wrapper").removeClass("active");
            $(".absolute-range-wrapper").addClass("active");
            this.relativeRangeText.removeClass("active");
            this.absoluteRangeText.addClass("active");
            this.setRangeValueText();
            this.setAbsoluteTimeInputs();
            this.rangeValueComp.find(".options").hide();
            this.rangeValueComp.find(".absolute-menu").addClass("open");
            this.rangeValueComp.find("#m-icon-calendar-clock").hide();
            this.rangeValueComp.find("#m-icon-calendar").show();
        }
        this.lastRangeTypeSelectionId = e.id;
        this.toggleRangeTypeDropdown();
        this.handleStepLimits();
        this.submit();
    }
    // ** SAVES **
    /**
     * called by ascx component elements
     * @param e
     */
    selectAbsoluteRange() {
        // update
        this.storeAbsoluteParams();
        // remove relative styling
        this.removePrevRelativeStyling();
        this.handleStepLimits();
        // update dd text
        this.setRangeValueText();
        this.handleStepSelectionLoss();
        this.submit();
        this.toggleRangeValueDropdown();
    }
    /**
     * called by ascx component elements
     * @param e
     */
    selectRelativeRange(e) {
        // data updates
        const { start, end } = TimePickerDropdown.relativeToAbsolute(e.id);
        this.start = start;
        this.end = end;
        if (e.id == this.lastRelativeSelectionId)
            return;
        // styling target element
        let targetEl = $(`#${e.id}`);
        if (!targetEl.hasClass("active")) {
            targetEl.addClass("active");
        }
        // remove style from previous selection
        this.removePrevRelativeStyling();
        this.lastRelativeSelectionId = e.id;
        // update kendo picker
        this.setAbsoluteTimeInputs();
        this.handleStepLimits();
        // update dd text
        this.setRangeValueText(e.textContent);
        this.submit();
        this.toggleRangeValueDropdown();
    }
    /**
     * called by ascx component elements
     * @param e
     */
    selectStep(e) {
        this.toggleStepDropdown();
        if (e.id == this.lastStepSelectionId)
            return;
        this._selectStep(e.id);
        this.setStepText(e.innerText);
        this.submit();
    }
    _selectStep(id) {
        if (id == this.lastStepSelectionId)
            return;
        Object.values(STEPS).forEach(step => {
            $(`#${step}`).removeClass("active");
        });
        this.step = STEP_VALUES[id];
        // styling target element
        $(`#${id}`).addClass("active");
        this.lastStepSelectionId = id;
        this.handleStepLimits();
    }
    // ** UTILS **
    /**
     * helper function to convert a relative time string into a start and end timestamp
     * @param relString
     * @returns
     */
    static relativeToAbsolute(relString) {
        const currentTime = Math.floor(new Date().getTime() / 1000);
        const diff = RELATIVE_TIMES[relString];
        return {
            start: currentTime - diff,
            end: currentTime
        };
    }
    /**
     * helper to get the date 1 week ago (used for initializing)
     * @returns
     */
    static getLastWeek() {
        return window.moment().subtract('days', 7).toDate();
    }
    static overrideOnlyHourlyStep() {
        // hide relative ranges less than a DAY
        Object.entries(RELATIVE_TIMES).forEach(([id, stepTime]) => {
            if (stepTime < DAY) {
                $(`#${id}`).css('display', "none");
            }
        });
        // hide steps other than hourly
        Object.keys(STEP_VALUES).forEach(id => {
            if (id.toLowerCase() !== "hourly") {
                $(`#${id}`).css('display', "none");
            }
        });
        // set local storage to hourly
        $("#hourly").click();
        $("#7d").click();
        $("#mainContent").click();
    }
    static useLastSevenDaysWithHourlyInterval() {
        $("#hourly").click();
        $("#7d").click();
        $("#mainContent").click();
    }
}
TimePickerDropdown.eventId = "timePicker";

class RackCard {
    constructor(parentEl, initData) {
        this.parentEl = parentEl;
        this.initData = initData;
        this.mustache = window.Mustache;
        this.changes = [];
        this.rows = [];
        this.render();
    }
    getRack() {
        // get rack name and rows
        return {
            originalName: this.initData.rackDetails.name,
            name: this.rackEl.find("input[name='rackName']").val(),
            rows: this.rows.map(row => row.getRow()),
            agents: [],
            changes: this.changes,
        };
    }
    rackName() {
        return this.rackEl.find("input[name='rackName']").val();
    }
    render() {
        const rackData = {
            rackName: this.initData.rackDetails.name,
            readOnly: this.initData.readOnly
        };
        const rackTemplate = $(this.mustache.to_html(RACK_TEMPLATE, rackData));
        this.parentEl.append(rackTemplate);
        this.rackEl = rackTemplate;
        this.rackEl.find(".add-row").first().click(this.addRow.bind(this));
        // cant add event handlers to readonly row
        try {
            this.rackEl.find(".del-rack").click(() => this.initData.deleteRackHandler());
        }
        catch (_a) { }
        // add rows
        const rowEl = this.rackEl.find(".rows");
        this.initData.rackDetails.rows.forEach((row, index) => {
            const rowData = {
                rowDetails: row,
                readOnly: this.initData.readOnly,
                onUpdateSlotCount: this.updateSlotCount.bind(this),
                calledFromRackCard: false,
                invertedRows: this.initData.invertedRows,
                onRenameRow: this.handleRenameRow.bind(this),
                onNumSlotChange: this.handleUpdateRowSlots.bind(this),
            };
            const rowClass = new RackRow(rowEl, rowData);
            rowClass.addRow = this.addRow.bind(this);
            rowClass.deleteRow = this.deleteRow.bind(this, index);
            this.rows.push(rowClass);
        });
        this.updateSlotCount();
    }
    // simply append row
    addRow() {
        const rowCount = this.rows.length;
        const rowEl = this.rackEl.find(".rows");
        let prevRowName = Number(this.rows[0].rowName());
        if (!this.initData.invertedRows) {
            prevRowName = Number(this.rows[this.rows.length - 1].rowName());
        }
        const rowName = prevRowName ? prevRowName + 1 : (rowCount + 1).toString();
        let rowData = {
            rowDetails: {
                name: rowName.toString(),
                numSlots: RackRow.DEFAULT_SLOT_COUNT,
            },
            readOnly: this.initData.readOnly,
            onUpdateSlotCount: this.updateSlotCount.bind(this),
            calledFromRackCard: true,
            invertedRows: this.initData.invertedRows,
            onRenameRow: this.handleRenameRow.bind(this) // Add this line
        };
        if (this.rows.length > 0) {
            rowData.rowDetails.numSlots = this.rows[this.rows.length - 1].getSlotCount();
        }
        const rowClass = new RackRow(rowEl, rowData);
        rowClass.addRow = this.addRow.bind(this, rowCount);
        rowClass.deleteRow = this.deleteRow.bind(this, rowCount);
        this.initData.invertedRows ? this.rows.unshift(rowClass) : this.rows.push(rowClass);
        this.changes.push({ type: 'add', row: rowClass, originalName: rowClass.rowName(), numSlots: rowData.rowDetails.numSlots });
        this.updateSlotCount();
    }
    // delete row and update rowNames of every succeeding row
    deleteRow(rowIndex) {
        if (this.rows.length === 1)
            return;
        let rows = [];
        this.rows.forEach((row, index) => {
            if (index < rowIndex) {
                rows.push(row);
            }
            else if (index > rowIndex) {
                row.updateRowName(index.toString());
                row.deleteRow = this.deleteRow.bind(this, index - 1);
                rows.push(row);
            }
            else {
                row.deleteRowHtml();
                this.changes.push({ type: 'delete', rowId: rowIndex, originalName: row.rowName(), numSlots: row.getSlotCount() });
            }
        });
        this.rows = rows;
        this.updateSlotCount();
    }
    deleteRackHtml() {
        this.rackEl.remove();
    }
    updateSlotCount() {
        let slotCount = 0;
        this.rows.forEach(row => {
            slotCount += Number(row.getSlotCount());
        });
        this.rackEl.find(".total-slot-count").text(slotCount);
        this.updateLinkedMinerCount();
    }
    updateLinkedMinerCount() {
        const linkedMinerCount = this.rackEl.find(".highlighted").toArray().length;
        const linkedMinerEl = this.rackEl.find(".linked-miner-count");
        if (linkedMinerCount > 0) {
            linkedMinerEl.text(linkedMinerCount);
            linkedMinerEl.parent().addClass("active");
        }
        else {
            linkedMinerEl.parent().removeClass("active");
        }
    }
    invalidate(msg) {
        const errorEl = this.rackEl.find(".error-msg").first();
        errorEl.addClass("active").text(msg);
        errorEl.focus();
    }
    validate() {
        this.rackEl.find(".error-msg").first().removeClass("active");
    }
    hasLinkedMiners() {
        return this.rackEl.find(".highlighted").length > 0;
    }
    handleRenameRow(originalName, newName, numSlots) {
        const regExp = /[^1-9]/g;
        // only track valid name changes
        // invalid inputs are handled on submit in RackDetailsFormView validate()
        if (!regExp.test(newName)) {
            this.changes.push({ type: 'rename', rowId: parseInt(originalName), originalName, newName, numSlots: numSlots }); // Track rename change
        }
    }
    handleUpdateRowSlots(originalName, newNumSlots) {
        this.changes.push({ type: 'slots', rowId: parseInt(originalName), originalName, numSlots: newNumSlots });
    }
}
RackCard.DEFAULT_RACK = {
    name: "",
    rows: [RackRow.DEFAULT_ROW],
    agents: [],
    changes: [],
};
const RACK_TEMPLATE = `
            <div class="m-box rack-box">
                <div class="m-stack" style="overflow:auto">
                    {{^readOnly}}
                        <div class="rack-name">
                            <div class="m-stack is-horizontal is-align-center has-space-between">
                                <label class="m-label is-required" for="rackName">Rack Name</label>
                                <span class="del-rack">
                                    <m-icon size="xl" name="x-circle"></m-icon>
                                </span>
                            </div>
                            <input type="text" maxlength="10" class="m-input" name="rackName" placeholder="Rack A" data-form-type="other" value="{{rackName}}" required />
                            <p class="m-help-text is-error error-msg">Rack name required</p>
                        </div>
                    {{/readOnly}}

                    <div class="rows">
                    </div>

                    <button class="m-button is-secondary expanded add-row" type="button">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M8 3.3335V12.6668" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M3.33325 8H12.6666" stroke="#00E67E" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        Add Row
                    </button>

                    <div class="m-stack is-horizontal has-space-between">
                        <div class="m-stack is-horizontal m-text is-tertiary">
                            <span class="total-slot-count">{{slotCount}}</span>
                            <span>SLOTS</span>
                        </div>
                        <div class="m-stack is-horizontal m-text is-accent linked-miners">
                            <span class="linked-miner-count">0</span>
                            <span>LINKED MINERS</span>
                        </div>
                    </div>

                </div>
            </div>
    `;

var ZoneCardType;
(function (ZoneCardType) {
    ZoneCardType[ZoneCardType["View"] = 0] = "View";
    ZoneCardType[ZoneCardType["ViewWithRackEdit"] = 1] = "ViewWithRackEdit";
    ZoneCardType[ZoneCardType["ViewWithRackDelete"] = 2] = "ViewWithRackDelete";
    ZoneCardType[ZoneCardType["FullWrite"] = 3] = "FullWrite";
})(ZoneCardType || (ZoneCardType = {}));
class ZoneCard {
    constructor(parentEl, initData) {
        this.parentEl = parentEl;
        this.initData = initData;
        this.mustache = window.Mustache;
        this.racks = [];
        this.render();
    }
    getZone() {
        // get rack name and rows
        return {
            zoneId: this.id,
            zoneName: this.zoneEl.find(".zone-name").first().val().trim() || this.zoneEl.find(".zone-name").first().text().trim(),
            agentName: this.initData.zoneDetails.agentName,
            racks: this.racks.map(rack => rack.getRack()),
            invertedRows: this.initData.zoneDetails.invertedRows
        };
    }
    render() {
        var _a, _b;
        this.id = (_a = this.initData.zoneDetails) === null || _a === void 0 ? void 0 : _a.zoneId;
        const zoneData = {
            zoneId: (_b = this.initData.zoneDetails) === null || _b === void 0 ? void 0 : _b.zoneId,
            zoneName: this.initData.zoneDetails.zoneName,
            readOnly: this.initData.cardType !== ZoneCardType.FullWrite,
            allowDelete: this.initData.cardType === ZoneCardType.ViewWithRackDelete
        };
        const zoneTemplate = $(this.mustache.to_html(ZONE_TEMPLATE, zoneData));
        this.parentEl.append(zoneTemplate);
        this.zoneEl = zoneTemplate;
        // cant add event handlers to readonly zone card
        switch (this.initData.cardType) {
            case ZoneCardType.ViewWithRackDelete:
                this.parentEl.find(".del-rack").click(this.deleteRack.bind(this));
                break;
            case ZoneCardType.ViewWithRackEdit:
            case ZoneCardType.FullWrite:
                this.parentEl.find(".duplicate-rack").click(this.duplicateRack.bind(this));
                this.parentEl.find(".add-rack").click(this.addRack.bind(this));
                break;
        }
        // add racks
        this.rackListEl = this.zoneEl.find(".rack-list");
        this.initData.zoneDetails.racks.forEach((rack, index) => {
            const rackData = {
                rackDetails: rack,
                readOnly: this.getRackReadOnly(),
                deleteRackHandler: this.deleteRackByIndex.bind(this, index),
                invertedRows: this.initData.zoneDetails.invertedRows,
            };
            const rackClass = new RackCard(this.rackListEl, rackData);
            this.racks.push(rackClass);
        });
        if (this.racks.length === 0) {
            this.addRack();
        }
    }
    duplicateRack(event) {
        const rackToDuplicate = this.racks[this.racks.length - 1];
        const rackData = {
            rackDetails: rackToDuplicate.getRack(),
            readOnly: this.getRackReadOnly(),
            deleteRackHandler: this.deleteRackByIndex.bind(this, this.racks.length),
            invertedRows: this.initData.zoneDetails.invertedRows,
        };
        const rackClass = new RackCard(this.rackListEl, rackData);
        this.racks.push(rackClass);
    }
    addRack(event) {
        const rackData = {
            rackDetails: RackCard.DEFAULT_RACK,
            readOnly: this.getRackReadOnly(),
            deleteRackHandler: this.deleteRackByIndex.bind(this, this.racks.length),
            invertedRows: this.initData.zoneDetails.invertedRows,
        };
        const rackClass = new RackCard(this.rackListEl, rackData);
        this.racks.push(rackClass);
    }
    deleteRack(event) {
        this.initData.onDelete(this.id);
    }
    deleteRackByIndex(rackIndex) {
        if (this.racks.length === 1)
            return;
        let racks = [];
        this.racks.forEach((rack, index) => {
            if (index < rackIndex) {
                racks.push(rack);
            }
            else if (index > rackIndex) {
                rack.initData.deleteRackHandler = this.deleteRackByIndex.bind(this, index - 1);
                racks.push(rack);
            }
            else {
                rack.deleteRackHtml();
            }
        });
        this.racks = racks;
    }
    invalidate(msg) {
        const errorEl = this.zoneEl.find(".error-msg").first();
        errorEl.addClass("active").text(msg);
        errorEl.focus();
    }
    validate() {
        this.zoneEl.find(".error-msg").first().removeClass("active");
    }
    linkedMinerCount() {
        return this.zoneEl.find(".highlighted").length;
    }
    getRackReadOnly() {
        switch (this.initData.cardType) {
            case ZoneCardType.FullWrite:
            case ZoneCardType.ViewWithRackEdit:
            case ZoneCardType.ViewWithRackDelete:
                return false;
            default:
                return true;
        }
    }
}
ZoneCard.DEFAULT_ZONE = {
    zoneName: "",
    agentName: "",
    racks: [RackCard.DEFAULT_RACK],
    invertedRows: false,
};
const ZONE_TEMPLATE = `
        <div id="{{zoneId}}" class="zone-box m-box">
            <div class="m-stack">

                {{#readOnly}}
                    <p class="m-text is-tertiary">Zone: <span class="zone-name">{{zoneName}}</span></p>
                {{/readOnly}}
                {{^readOnly}}
                    <div>
                        <div class="m-form-control">
                            <label class="m-label is-required" for="zoneName">Zone Name</label>
                            <input type="text" maxlength="40" class="m-input zone-name" name="zoneName" placeholder="Zone name ..." data-form-type="other" value="{{zoneName}}" required />
                            <p class="m-help-text is-error error-msg">Zone name required</p>
                        </div>
                    </div>
                {{/readOnly}}

                <div class="m-stack has-space-s rack-list"></div>

                <div class="has-space-s m-form-group is-grouped-right">

                    {{^allowDelete}}
                        <div>
                            <button class="m-button is-secondary duplicate-rack" type="button" data-form-type="other">
                                <m-icon class="m-button-icon" name="layers-2"></m-icon>
                                Duplicate Rack</button>
                        </div>

                        <div>
                            <button class="m-button is-secondary add-rack" type="button" data-form-type="other">
                                <m-icon class="m-button-icon" name="plus"></m-icon>
                                Add Rack
                            </button>
                        </div>
                    {{/allowDelete}}
                    {{#allowDelete}}
                        <button class="m-button is-destructive del-rack" type="button" data-form-type="other">Delete Rack</button>
                    {{/allowDelete}}

                </div>
            </div>
        </div>
    `;

class ExcusedEventsGrid extends OptiFleetService {
    constructor() {
        super();
        this.scheduledShutdownsUrl = "/ScheduledShutdowns";
        this.DEFAULT_GRID_OPTIONS = {
            pageable: {
                pageSizes: [10, 100, 500, 1000, 5000],
                buttonCount: 5,
                responsive: false
            },
            sortable: true,
            mobile: false,
            persistSelection: true,
            resizable: true,
            filterable: true,
            columnMenu: false,
            scrollable: false,
            editable: false,
            excel: {
                allPages: true
            },
            columns: [
                { field: "type", title: "Type", filterable: { multi: true }, template: ExcusedEventsGrid.typeTemplate.bind(this) },
                { field: "filterableStart", title: "Started", template: ExcusedEventsGrid.startTimeTemplate.bind(this) },
                { field: "filterableEnd", title: "Ended", template: ExcusedEventsGrid.endTimeTemplate.bind(this) },
                { field: "duration", title: "Duration", template: ExcusedEventsGrid.durationTemplate.bind(this) },
                { field: "description", title: "Description", filterable: false },
                { field: "zones", title: "Zones", filterable: false, template: ExcusedEventsGrid.zonesTemplate.bind(this) },
                { field: "siteName", title: "Site", width: "150px", filterable: { multi: true } },
            ]
        };
        this.init();
    }
    init() {
        $("#excusedEventsGrid").kendoGrid(Object.assign({ dataSource: {
                data: [],
                pageSize: 10
            } }, this.DEFAULT_GRID_OPTIONS)).data("kendoGrid");
    }
    refresh(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = window.moment(new Date(params.start * 1000)).format('YYYY-MM-DDTHH:mm:ss');
            const end = window.moment(new Date(params.end * 1000)).format('YYYY-MM-DDTHH:mm:ss');
            const resp = yield this.get(this.scheduledShutdownsUrl + `?siteId=${params.siteId}&start=${start}&end=${end}`);
            if (resp.scheduledShutdowns.length === 0) {
                this.hideEvents();
                return Promise.resolve([]);
            }
            this.populateGrid(resp.scheduledShutdowns);
            return resp.scheduledShutdowns;
        });
    }
    populateGrid(data) {
        $("#excusedEventsCount").text(data.length);
        const totalDurationSecs = data.reduce((acc, val) => acc + val.duration, 0);
        const formattedTotalDuration = ExcusedEventsGrid.formatDuration(totalDurationSecs);
        $("#excusedEventsDuration").text(formattedTotalDuration);
        data = data.map(d => {
            let end = new Date(d.start);
            end.setSeconds(end.getSeconds() + d.duration);
            d['end'] = end.toDateString();
            return d;
        });
        const dataSource = new self.kendo.data.DataSource({
            data,
            pageSize: 10,
            schema: {
                model: {
                    id: "scheduledShutdownId",
                    fields: {
                        type: { type: "string" },
                        title: { type: "string" },
                        siteId: { type: "number" },
                        siteName: { type: "string" },
                        start: { type: "date" },
                        filterableStart: { type: "date" },
                        duration: { type: "number" },
                        end: { type: "date" },
                        filterableEnd: { type: "date" },
                    }
                },
                parse: function (d) {
                    // Set filterable start and end to date with no time allows Kendo grid to ignore time
                    $.each(d, function (idx, elem) {
                        elem.filterableStart = new Date(new Date(elem.start).toDateString());
                        let endDate = new Date(elem.start);
                        endDate.setSeconds(endDate.getSeconds() + elem.duration);
                        elem.filterableEnd = new Date(endDate.toDateString());
                    });
                    return d;
                }
            }
        });
        const grid = $("#excusedEventsGrid").data("kendoGrid");
        grid.setOptions(Object.assign({ dataSource }, this.DEFAULT_GRID_OPTIONS));
        grid.dataSource.read();
        grid.refresh();
        this.showEvents();
    }
    hideEvents() {
        const elWithEvents = $(".ee-with-events");
        const elWithoutEvents = $(".ee-without-events");
        elWithEvents.hasClass("active") && elWithEvents.removeClass("active");
        elWithoutEvents.hasClass("active") || elWithoutEvents.addClass("active");
    }
    showEvents() {
        const elWithEvents = $(".ee-with-events");
        const elWithoutEvents = $(".ee-without-events");
        elWithEvents.hasClass("active") || elWithEvents.addClass("active");
        elWithoutEvents.hasClass("active") && elWithoutEvents.removeClass("active");
    }
    exportExcel() {
        $("#excusedEventsGrid")
            .data("kendoGrid")
            .saveAsExcel();
    }
    /**
     * returns normalized string format for duration (DD.HH:mm:ss)
     * @param duration: duration in seconds
     */
    static formatDuration(duration) {
        const SECONDS = 1;
        const MIN = SECONDS * 60;
        const HOUR = MIN * 60;
        const DAY = HOUR * 24;
        let d = duration;
        const days = Math.floor(d / DAY);
        d = d - (days * DAY);
        const hours = Math.floor(d / HOUR);
        d = d - (hours * HOUR);
        const minutes = Math.floor(d / MIN);
        d = d - (minutes * MIN);
        const seconds = d;
        return `${days.toString().padStart(2, '0')}.${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    /** GRID TEMPLATES **/
    static typeTemplate(data) {
        const color = ExcusedEventsGrid.EVENT_TYPE_COLORS[data.typeId] || ExcusedEventsGrid.EVENT_TYPE_COLORS[1];
        return `
            <div class="m-chip">
                <div class="ee-type-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="6" height="6" viewBox="0 0 6 6" fill="none">
                    <circle cx="3" cy="3" r="3" fill="${color}"/>
                </svg>
                </div>
                <p class="ee-type-label m-text is-tertiary">${data.type}</p>
            </div>
            `;
    }
    static startTimeTemplate(data) {
        if (!data || !data.start) {
            return "---";
        }
        const start = window.moment(new Date(data.start)).format("MM/DD/YYYY HH:mm");
        return `<span class="metric-text">${start}</span>`;
    }
    static endTimeTemplate(data) {
        if (!data || !data.start) {
            return "---";
        }
        let start = new Date(data.start);
        start.setSeconds(start.getSeconds() + data.duration);
        const end = window.moment(start).format("MM/DD/YYYY HH:mm");
        return `<span class="metric-text">${end}</span>`;
    }
    static durationTemplate(data) {
        const duration = ExcusedEventsGrid.formatDuration(data.duration);
        return `<span class="metric-text">${duration}</span>`;
    }
    static zonesTemplate(data) {
        if (data.zoneNames.length === 0) {
            return "All Zones";
        }
        return data.zoneNames.join(", ");
    }
}
ExcusedEventsGrid.EVENT_TYPE_COLORS = {
    1: "#F0F016",
    2: "#F81717",
    3: "#7B00FF",
    4: "#BBEB00",
    5: "#FFBA00",
    6: "#FF8200",
    7: "#2966FF",
    8: "#00FFFF",
    9: "#D232FF"
};

class HashrateGauge extends OptiFleetPage {
    constructor(showCurrent) {
        super();
        this.showCurrent = showCurrent;
        this.chart = new Gauge([HashrateGauge.overallQuery], "#hashRateGaugeBusy");
        this.chart.title = "Hash Rate Performance";
        this.chart.elementSelector = "hashRateGauge";
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        $(window).on('resize', this.handleWindowResize.bind(this));
    }
    handleWindowResize(event) {
        this.chart.render();
    }
    load(siteId) {
        this.loadGauge(siteId);
    }
    loadGauge(siteId) {
        this.chart.companyFilter = this.getSelectedCompanyId();
        this.chart.load([["siteId", siteId]]);
    }
    onGraphDataReceived(graphData) {
        if (!this.showCurrent) {
            this.populateOvertimeHashrate(graphData);
            return;
        }
        this.populateCurrentHashrate(graphData);
    }
    populateOvertimeHashrate(graphData) {
        try {
            let hashrate = 0;
            let count = 0;
            graphData[0].data.result[0].values.forEach((value) => {
                try {
                    const hashrateEfficiency = parseFloat(value[1]);
                    if (isNaN(hashrateEfficiency)) {
                        return;
                    }
                    count++;
                    hashrate = hashrate + hashrateEfficiency;
                }
                catch (_a) {
                    //eat
                }
            });
            let avg = parseFloat(((hashrate / count) * 100).toFixed(1));
            if (isNaN(avg)) {
                avg = 0;
            }
            this.chart.stat = avg;
            this.chart.render();
        }
        catch (ex) {
            this.chart.stat = -1;
            this.chart.render();
        }
    }
    populateCurrentHashrate(graphData) {
        try {
            const lastValue = graphData[0].data.result[0].values[graphData[0].data.result[0].values.length - 1];
            const hashrateEfficiency = parseFloat(lastValue[1]);
            let avg = parseFloat((hashrateEfficiency * 100).toFixed(1));
            this.chart.stat = avg;
            this.chart.render();
        }
        catch (ex) {
            this.chart.stat = -1;
            this.chart.render();
        }
    }
    formatter(val, index) {
        if (val === 0) {
            return "--";
        }
        if (val === -1) {
            return "N/A";
        }
        return `${(val).toFixed(1)}%`;
    }
}
HashrateGauge.overallQuery = "/OverallVsTheoreticalHashrate";

class HashrateStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/HashrateStat";
        this.hashingType = 1;
    }
    load(siteId) {
        this.loadStat(siteId);
    }
    loadStat(siteId) {
        let url = "";
        if (siteId) {
            url = `${this.url}?siteId=${siteId}`;
        }
        else {
            url = this.url;
        }
        this.toggleStatBusy(true);
        this.get(url)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    getStat(siteId) {
        let url = "";
        if (siteId) {
            url = `${this.url}?siteId=${siteId}`;
        }
        else {
            url = this.url;
        }
        return this.get(url);
    }
    populateStat(resp) {
        try {
            const hashrate = this.getHashrate(resp);
            $("#hashrateStat").text(hashrate);
        }
        catch (_a) {
            $("#hashrateStat").text("0 Hs");
        }
    }
    getHashrate(resp) {
        const rate = resp.data.result[0].value[1];
        return this.formatter(rate);
    }
    formatter(val) {
        return HashrateUtil.parseHashrate(val, this.hashingType);
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#hashRateStatBusy").removeClass("active");
            return;
        }
        $("#hashRateStatBusy").addClass("active");
    }
}

class MinersHashrate {
    constructor(overrideOptions) {
        this.overrideOptions = overrideOptions;
        this.chart = new LineChart([MinersHashrate.overallQuery, MinersHashrate.theoreticalQuery], "#hashrateBusy");
        this.hashingType = 1;
        this.chart.elementSelector = "hashrateChart";
        if (overrideOptions) {
            this.chart.overrideOptions = overrideOptions;
        }
        else {
            this.chart.title = "Hash Rate";
            this.chart.extraOptions.formatter = this.formatter.bind(this);
            this.chart.extraOptions.export = {
                csv: {
                    filename: "Hash Rate",
                    headerCategory: "Time",
                    headerValue: "Hash Rate",
                    dateFormatter: (timeStamp) => {
                        const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                        return time;
                    }
                }
            };
        }
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        const legend = this.overrideOptions ? ['Actual', 'Baseline'] : ["Actual Hash Rate", "Expected Hash Rate"];
        try {
            graphData.forEach((resp) => {
                serieData.push({
                    name: (resp.internalName === "Actual Hash Rate") ? legend[0] : legend[1],
                    data: this.filterOutNaN(resp.data.result[0].values)
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.series = serieData;
        $(".hashrate-chart").addClass("active");
        this.chart.render();
    }
    filterOutNaN(values) {
        return values.filter((value) => {
            return !isNaN(value[1]); // +Inf & NaN;
        });
    }
    formatter(val, index) {
        return HashrateUtil.parseHashrate(val, this.hashingType);
    }
    setHashingType(hashingType) {
        const changed = this.hashingType != hashingType;
        this.hashingType = hashingType;
        if (changed) {
            this.chart.render();
        }
    }
}
MinersHashrate.overallQuery = "/OverallHashrate";
MinersHashrate.theoreticalQuery = "/TheoreticalHashrate";

class PoolHashrate {
    constructor() {
        this.chart = new LineChart([PoolHashrate.poolHashrateQuery], "#poolHashrateBusy");
        this.hashingType = 1;
        this.chart.elementSelector = "poolHashrateChart";
        this.chart.title = "Hash Rate by Pool";
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.extraOptions.tooltip = {
            shared: true,
            inverseOrder: false,
            x: {
                show: true,
                format: 'yyyy-MM-dd hh:mm:ss TT'
            },
        },
            this.chart.extraOptions.autoColor = true;
        this.chart.extraOptions.export = {
            csv: {
                filename: "Hash Rate by Pool (24h)",
                headerCategory: "Time",
                headerValue: "Hash Rate",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        try {
            graphData.forEach((resp) => {
                resp.data.result.forEach((result) => {
                    serieData.push({
                        name: result.metric.pool,
                        data: this.filterOutNaN(result.values)
                    });
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.series = serieData;
        $(".poolHashrate-chart").addClass("active");
        this.chart.render();
    }
    filterOutNaN(values) {
        return values.filter((value) => {
            return !isNaN(value[1]); // +Inf & NaN;
        });
    }
    formatter(val, index) {
        return HashrateUtil.parseHashrate(val, this.hashingType);
    }
    setHashingType(hashingType) {
        const changed = this.hashingType != hashingType;
        this.hashingType = hashingType;
        if (changed) {
            this.chart.render();
        }
    }
}
PoolHashrate.poolHashrateQuery = "/PoolHashrate";

class SensorPushHumidityGraph {
    constructor() {
        this.chart = new LineChart([SensorPushHumidityGraph.sensorUrl], "#humidityBusy");
        this.chart.elementSelector = "humidityGraph";
        this.chart.title = "Sensor Push";
        this.chart.extraOptions.export = {
            csv: {
                filename: "Sensor Push (24h)",
                headerCategory: "Time",
                headerValue: "Sensor Data",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        try {
            graphData.forEach((resp) => {
                serieData.push({
                    name: "Humidity",
                    data: this.filterOutNaN(resp.data.result[0].values)
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.series = serieData;
        $(".humidity-graph").addClass("active");
        this.chart.render();
    }
    filterOutNaN(values) {
        return values.filter((value) => {
            return !isNaN(value[1]); // +Inf & NaN;
        });
    }
}
SensorPushHumidityGraph.sensorUrl = "/SensorPushHumidity";

class SensorPushTemperatureGraph {
    constructor() {
        this.chart = new LineChart([SensorPushTemperatureGraph.sensorUrl], "#tempBusy");
        this.chart.elementSelector = "tempGraph";
        this.chart.title = "Sensor Push";
        this.chart.extraOptions.export = {
            csv: {
                filename: "Sensor Push (24h)",
                headerCategory: "Time",
                headerValue: "Sensor Data",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        try {
            graphData.forEach((resp) => {
                serieData.push({
                    name: "Temperature",
                    data: this.filterOutNaN(resp.data.result[0].values)
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.series = serieData;
        $(".temp-graph").addClass("active");
        this.chart.render();
    }
    filterOutNaN(values) {
        return values.filter((value) => {
            return !isNaN(value[1]); // +Inf & NaN;
        });
    }
}
SensorPushTemperatureGraph.sensorUrl = "/SensorPushTemperature";

class ErrorView extends OptiFleetPage {
    constructor(onDataLoaded, siteId) {
        super();
        this.siteId = siteId;
        this.url = "/ErrorView?siteId=";
        this.init();
        this.onDataLoaded = onDataLoaded;
    }
    init() {
        this.setHeader();
        this.showColumns();
        this.load();
    }
    setHeader() {
        $("#viewHeader").text("Miners with Polling Errors");
    }
    showColumns() {
        const grid = $("#minerList").data("kendoGrid");
        grid.showColumn("status");
    }
    load() {
        this.toggleBusy(true);
        this.get(this.url + this.siteId)
            .then((resp) => {
            this.populateMinersGrid(resp.miners);
            this.onDataLoaded(resp.miners);
            this.toggleBusy(false);
        });
    }
    populateMinersGrid(miners) {
        const grid = $("#minerList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: miners,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
    }
}

class OfflineView extends OptiFleetPage {
    constructor(onDataLoaded, siteId) {
        super();
        this.siteId = siteId;
        this.url = "/OfflineMinersView?siteId=";
        this.init();
        this.onDataLoaded = onDataLoaded;
    }
    init() {
        this.setHeader();
        this.showColumns();
        this.load();
    }
    setHeader() {
        $("#viewHeader").text("Offline Miners");
    }
    showColumns() {
        const grid = $("#minerList").data("kendoGrid");
        grid.showColumn("status");
    }
    load() {
        this.toggleBusy(true);
        this.get(this.url + this.siteId)
            .then((resp) => {
            this.populateMinersGrid(resp.miners);
            this.onDataLoaded(resp.miners);
            this.toggleBusy(false);
        });
    }
    populateMinersGrid(miners) {
        const grid = $("#minerList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: miners,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
    }
}

class LowHashingView extends OptiFleetPage {
    constructor(onDataLoaded, siteId) {
        super();
        this.siteId = siteId;
        this.url = "/LowHashingView?siteId=";
        this.init();
        this.onDataLoaded = onDataLoaded;
    }
    init() {
        this.setHeader();
        this.showColumns();
        this.load();
    }
    setHeader() {
        $("#viewHeader").text("Low-Hashing Miners");
    }
    showColumns() {
        const grid = $("#minerList").data("kendoGrid");
        grid.showColumn("hashrate");
        grid.showColumn("expectedHashrate");
    }
    load() {
        this.toggleBusy(true);
        this.get(this.url + this.siteId)
            .then((resp) => {
            this.populateMinersGrid(resp.miners);
            this.onDataLoaded(resp.miners);
            this.toggleBusy(false);
        });
    }
    populateMinersGrid(miners) {
        const grid = $("#minerList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: miners,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
    }
}

class NonHashingView extends OptiFleetPage {
    constructor(onDataLoaded, siteId) {
        super();
        this.siteId = siteId;
        this.url = "/NonHashingView?siteId=";
        this.init();
        this.onDataLoaded = onDataLoaded;
    }
    init() {
        this.setHeader();
        this.showColumns();
        this.load();
    }
    setHeader() {
        $("#viewHeader").text("Non-Hashing Miners");
    }
    showColumns() {
        const grid = $("#minerList").data("kendoGrid");
        grid.showColumn("hashrate");
    }
    load() {
        this.toggleBusy(true);
        this.get(this.url + this.siteId)
            .then((resp) => {
            this.populateMinersGrid(resp.miners);
            this.onDataLoaded(resp.miners);
            this.toggleBusy(false);
        });
    }
    populateMinersGrid(miners) {
        const grid = $("#minerList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: miners,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
    }
}

class PendingRMAView extends OptiFleetPage {
    constructor(onDataLoaded, siteId) {
        super();
        this.siteId = siteId;
        this.url = "/PendingRMAMinerView?siteId=";
        this.init();
        this.onDataLoaded = onDataLoaded;
    }
    init() {
        this.setHeader();
        this.showColumns();
        this.load();
    }
    setHeader() {
        $("#viewHeader").text("Miners Pending Repair");
    }
    showColumns() {
        const grid = $("#minerList").data("kendoGrid");
        grid.showColumn("rmaDate");
    }
    load() {
        this.toggleBusy(true);
        this.get(this.url + this.siteId)
            .then((resp) => {
            this.populateMinersGrid(resp.miners);
            this.onDataLoaded(resp.miners);
            this.toggleBusy(false);
        });
    }
    populateMinersGrid(miners) {
        const grid = $("#minerList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: miners,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
    }
}

class RMAView extends OptiFleetPage {
    constructor(onDataLoaded, siteId) {
        super();
        this.siteId = siteId;
        this.url = "/RMAMinerView?siteId=";
        this.init();
        this.onDataLoaded = onDataLoaded;
    }
    init() {
        this.setHeader();
        this.showColumns();
        this.load();
    }
    setHeader() {
        $("#viewHeader").text("Miners In Repair");
    }
    showColumns() {
        const grid = $("#minerList").data("kendoGrid");
        grid.showColumn("rmaDate");
    }
    load() {
        this.toggleBusy(true);
        this.get(this.url + this.siteId)
            .then((resp) => {
            this.populateMinersGrid(resp.miners);
            this.onDataLoaded(resp.miners);
            this.toggleBusy(false);
        });
    }
    populateMinersGrid(miners) {
        const grid = $("#minerList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: miners,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
    }
}

class InstalledStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/InstalledMinersStat";
    }
    load(siteId) {
        this.loadStat(siteId);
    }
    loadStat(siteId) {
        let url = "";
        if (siteId) {
            url = `${this.url}?siteId=${siteId}`;
        }
        else {
            url = this.url;
        }
        this.toggleStatBusy(true);
        this.get(url)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            $("#installedStat").text(resp.stat);
        }
        catch (_a) {
            $("#installedStat").text("0");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#installedStatBusy").removeClass("active");
            return;
        }
        $("#installedStatBusy").addClass("active");
    }
}

class LowHashingStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/LowHashingView";
    }
    load(siteId) {
        this.loadStat(siteId);
    }
    loadStat(siteId) {
        let url = "";
        if (siteId) {
            url = `${this.url}?siteId=${siteId}`;
        }
        else {
            url = this.url;
        }
        this.toggleStatBusy(true);
        this.get(url)
            .then((resp) => {
            this.populateStat(resp.miners.length);
            this.toggleStatBusy(false);
        });
    }
    getStat(siteId) {
        let url = "";
        if (siteId) {
            url = `${this.url}?siteId=${siteId}`;
        }
        else {
            url = this.url;
        }
        return this.get(url);
    }
    populateStat(count) {
        try {
            $("#lowHashingStat").text(count);
        }
        catch (_a) {
            $("#lowHashingStat").text("0");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#lowHashingBusy").removeClass("active");
            return;
        }
        $("#lowHashingBusy").addClass("active");
    }
}

class NonHashingStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/NonHashingView";
    }
    load(siteId) {
        this.loadStat(siteId);
    }
    loadStat(siteId) {
        let url = "";
        if (siteId) {
            url = `${this.url}?siteId=${siteId}`;
        }
        else {
            url = this.url;
        }
        this.toggleStatBusy(true);
        this.get(url)
            .then((resp) => {
            this.populateStat(resp.miners.length);
            this.toggleStatBusy(false);
        });
    }
    getStat(siteId) {
        let url = "";
        if (siteId) {
            url = `${this.url}?siteId=${siteId}`;
        }
        else {
            url = this.url;
        }
        return this.get(url);
    }
    populateStat(count) {
        try {
            $("#nonHashingStat").text(count);
        }
        catch (_a) {
            $("#nonHashingStat").text("0");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#nonHashingBusy").removeClass("active");
            return;
        }
        $("#nonHashingBusy").addClass("active");
    }
}

class PendingRepairStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/PendingRepairStat";
    }
    load(siteId) {
        this.loadStat(siteId);
    }
    loadStat(siteId) {
        let url = "";
        if (siteId) {
            url = `${this.url}?siteId=${siteId}`;
        }
        else {
            url = this.url;
        }
        this.toggleStatBusy(true);
        this.get(url)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            const inRepair = Math.round(resp.stat);
            $("#pendingRepairStat").text(inRepair);
        }
        catch (_a) {
            $("#pendingRepairStat").text("0");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#pendingRepairStatBusy").removeClass("active");
            return;
        }
        $("#pendingRepairStatBusy").addClass("active");
    }
}

class RepairStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/RepairStat";
    }
    load(siteId) {
        this.loadStat(siteId);
    }
    loadStat(siteId) {
        let url = "";
        if (siteId) {
            url = `${this.url}?siteId=${siteId}`;
        }
        else {
            url = this.url;
        }
        this.toggleStatBusy(true);
        this.get(url)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            const inRepair = Math.round(resp.stat);
            $("#rmaStat").text(inRepair);
        }
        catch (_a) {
            $("#rmaStat").text("0");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#rmaBusy").removeClass("active");
            return;
        }
        $("#rmaBusy").addClass("active");
    }
}

class ConfigForm {
    constructor(page) {
        this.page = page;
        this.mustache = window.Mustache;
        this.canEdit = window.canEdit;
        this.configFormElem = $("#configFormElem");
        this.configFormSubmitBtn = $("");
        this.configFormGrid = $("");
        this.configForm = {
            powerMarket: {
                label: $(""),
                input: $(""),
                errMsg: $(""),
            },
            loadZone: {
                label: $(""),
                input: $(""),
                errMsg: $(""),
            },
            rampDownWatts: {
                label: $(""),
                input: $(""),
                errMsg: $(""),
            },
            rampDownDuration: {
                label: $(""),
                input: $(""),
                errMsg: $(""),
            },
            rampUpWatts: {
                label: $(""),
                input: $(""),
                errMsg: $(""),
            },
            rampUpDuration: {
                label: $(""),
                input: $(""),
                errMsg: $(""),
            },
            holdPeriodMinutes: {
                label: $(""),
                input: $(""),
                errMsg: $(""),
            }
        };
        this.canEdit = (this.canEdit.toLowerCase() === "true");
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.interactionMode || !this.canEdit) {
            this.interactionMode = "view";
        }
        if (this.page.curtailmentConfig === null) {
            this.interactionMode = "edit";
        }
        const selectedPowerMarket = this.page.powerMarkets.find((p) => {
            var _a, _b, _c;
            return p.id === ((_c = (_b = (_a = this.page.curtailmentConfig) === null || _a === void 0 ? void 0 : _a.market) === null || _b === void 0 ? void 0 : _b.marketSupplier) === null || _c === void 0 ? void 0 : _c.id);
        });
        let powerMarketOptions = [{ value: "unassigned", label: "Unassigned", selected: "", }].concat(this.page.powerMarkets.map((powerMarket) => {
            const isSelected = (selectedPowerMarket === null || selectedPowerMarket === void 0 ? void 0 : selectedPowerMarket.id) === powerMarket.id;
            return { value: powerMarket.id.toString(), selected: isSelected ? "selected" : "", label: powerMarket.name };
        }));
        let loadZoneOptions = derive(() => {
            if (typeof selectedPowerMarket === "undefined") {
                return [{ value: "unassigned", label: "Unassigned", selected: "", }];
            }
            return selectedPowerMarket.loadZones.map((loadZone) => {
                var _a, _b, _c;
                const isSelected = ((_c = (_b = (_a = this.page.curtailmentConfig) === null || _a === void 0 ? void 0 : _a.market) === null || _b === void 0 ? void 0 : _b.marketZone) === null || _c === void 0 ? void 0 : _c.id) === loadZone.id;
                return {
                    value: loadZone.id,
                    label: loadZone.name,
                    selected: isSelected ? "selected" : "",
                };
            });
        });
        const templateData = {
            hasConfig: this.page.curtailmentConfig !== null,
            powerMarketOptions,
            loadZoneOptions,
            canEdit: this.canEdit,
            isEdit: this.interactionMode === "edit",
            rampDownWatts: ((_a = this.page.curtailmentConfig) === null || _a === void 0 ? void 0 : _a.rampDown.wattsPerSecond) || "NOT SET",
            rampDownDuration: this.page.curtailmentConfig !== null
                ? (this.page.curtailmentStats.totalPowerConsumptionWatts / ((_b = this.page.curtailmentConfig) === null || _b === void 0 ? void 0 : _b.rampDown.wattsPerSecond) / 60).toFixed(2)
                : "NOT SET",
            rampUpWatts: ((_c = this.page.curtailmentConfig) === null || _c === void 0 ? void 0 : _c.rampUp.wattsPerSecond) || "NOT SET",
            rampUpDuration: this.page.curtailmentConfig !== null
                ? (this.page.curtailmentStats.totalPowerConsumptionWatts / ((_d = this.page.curtailmentConfig) === null || _d === void 0 ? void 0 : _d.rampUp.wattsPerSecond) / 60).toFixed(2)
                : "NOT SET",
            holdPeriodMinutes: this.page.curtailmentConfig !== null
                ? (((_e = this.page.curtailmentConfig) === null || _e === void 0 ? void 0 : _e.holdPeriodSeconds) / 60).toFixed(2)
                : "NOT SET",
            powerMarket: (selectedPowerMarket === null || selectedPowerMarket === void 0 ? void 0 : selectedPowerMarket.name) || "Unassigned",
            loadZone: ((_g = (_f = this.page.curtailmentConfig) === null || _f === void 0 ? void 0 : _f.market) === null || _g === void 0 ? void 0 : _g.marketZone.name) || "Unassigned"
        };
        const renderedConfigForm = this.mustache.to_html(ConfigForm.template, templateData);
        this.configFormElem.empty().append(renderedConfigForm);
        this.configFormSubmitBtn = this.configFormElem.find("#configFormSubmitBtn");
        this.configFormGrid = this.configFormElem.find("#configGrid");
        this.configForm.powerMarket.label = $("#powerMarketLabel");
        this.configForm.powerMarket.input = $("#powerMarket");
        this.configForm.powerMarket.errMsg = $("#powerMarketErrMsg");
        this.configForm.loadZone.label = $("#loadZoneLabel");
        this.configForm.loadZone.input = $("#loadZone");
        this.configForm.loadZone.errMsg = $("#loadZoneErrMsg");
        this.configForm.rampDownWatts.label = $("#rampDownWattsLabel");
        this.configForm.rampDownWatts.input = $("#rampDownWatts");
        this.configForm.rampDownWatts.errMsg = $("#rampDownWattsErrMsg");
        this.configForm.rampDownDuration.label = $("#rampDownDurationLabel");
        this.configForm.rampDownDuration.input = $("#rampDownDuration");
        this.configForm.rampDownDuration.errMsg = $("#rampDownDurationErrMsg");
        this.configForm.rampUpWatts.label = $("#rampUpWattsLabel");
        this.configForm.rampUpWatts.input = $("#rampUpWatts");
        this.configForm.rampUpWatts.errMsg = $("#rampUpWattsErrMsg");
        this.configForm.rampUpDuration.label = $("#rampUpDurationLabel");
        this.configForm.rampUpDuration.input = $("#rampUpDuration");
        this.configForm.rampUpDuration.errMsg = $("#rampUpDurationErrMsg");
        this.configForm.holdPeriodMinutes.label = $("#holdPeriodMinutesLabel");
        this.configForm.holdPeriodMinutes.input = $("#holdPeriodMinutes");
        this.configForm.holdPeriodMinutes.errMsg = $("#holdPeriodMinutesErrMsg");
        this.bindRampInputs();
        this.configForm.powerMarket.input.on("change", () => {
            this.populateLoadZones(this.page.powerMarkets.find((p) => p.id == this.configForm.powerMarket.input.val()));
        });
        $("[configform-elem]").on("change", () => this.handleConfigFormChange());
        this.configFormSubmitBtn.on("click", () => this.saveConfigSettings());
    }
    populatePowerMarkets() {
        let powerMarketOptions = `<option value="unassigned">Unassigned</option>`;
        const selectedPowerMarket = this.page.powerMarkets.find((p) => { var _a, _b, _c; return p.id === ((_c = (_b = (_a = this.page.curtailmentConfig) === null || _a === void 0 ? void 0 : _a.market) === null || _b === void 0 ? void 0 : _b.marketSupplier) === null || _c === void 0 ? void 0 : _c.id); });
        for (let i = 0; i < this.page.powerMarkets.length; i++) {
            const powerMarket = this.page.powerMarkets[i];
            const isSelected = (selectedPowerMarket === null || selectedPowerMarket === void 0 ? void 0 : selectedPowerMarket.id) === powerMarket.id;
            powerMarketOptions += `
                    <option value="${powerMarket.id}" ${isSelected ? "selected" : ""}>${powerMarket.name}</option>
                `;
        }
        this.configForm.powerMarket.input.empty().append(powerMarketOptions);
        this.populateLoadZones(selectedPowerMarket);
    }
    populateLoadZones(selectedPowerMarket) {
        var _a, _b, _c;
        let loadZoneOptions = "";
        if (!selectedPowerMarket) {
            loadZoneOptions += `<option value="unassigned">Unassigned</option>`;
            this.configForm.loadZone.input.empty().append(loadZoneOptions);
            return;
        }
        for (let i = 0; i < selectedPowerMarket.loadZones.length; i++) {
            const loadZone = selectedPowerMarket.loadZones[i];
            const isSelected = ((_c = (_b = (_a = this.page.curtailmentConfig) === null || _a === void 0 ? void 0 : _a.market) === null || _b === void 0 ? void 0 : _b.marketZone) === null || _c === void 0 ? void 0 : _c.id) === loadZone.id;
            loadZoneOptions += `
                    <option value="${loadZone.id}" ${isSelected ? "selected" : ""}>${loadZone.name}</option>
                `;
        }
        this.configForm.loadZone.input.empty().append(loadZoneOptions);
    }
    cancel() {
        this.interactionMode = "view";
        this.render();
    }
    edit() {
        this.interactionMode = "edit";
        this.render();
    }
    saveConfigSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            this.page.toggleBusy(true);
            const holdPeriodVal = this.configForm.holdPeriodMinutes.input.val();
            const holdPeriodSeconds = holdPeriodVal * 60;
            const settings = {
                id: (_a = this.page.curtailmentConfig) === null || _a === void 0 ? void 0 : _a.id,
                rampUp: { wattsPerSecond: parseInt(this.configForm.rampUpWatts.input.val()) },
                rampDown: { wattsPerSecond: parseInt(this.configForm.rampDownWatts.input.val()) },
                market: {
                    marketSupplier: this.configForm.powerMarket.input.val() === "unassigned" ? null : {
                        id: this.configForm.powerMarket.input.val(),
                        name: this.page.powerMarkets.find((p) => p.id == this.configForm.powerMarket.input.val()).name
                    },
                    marketZone: this.configForm.loadZone.input.val() === "unassigned" ? null : {
                        id: this.configForm.loadZone.input.val(),
                        name: this.page.powerMarkets.find((p) => p.id == this.configForm.powerMarket.input.val()).loadZones.find((lz) => lz.id == this.configForm.loadZone.input.val()).name
                    }
                },
                holdPeriodSeconds: holdPeriodVal === "" ? undefined : holdPeriodSeconds
            };
            if (this.page.curtailmentConfig === null) {
                this.page.curtailmentConfig = yield this.page.post(`/Curtailment/Config?siteId=${this.page.currentSiteId}`, undefined, true);
            }
            this.page.patch(`/Curtailment/Config/${(_b = this.page.curtailmentConfig) === null || _b === void 0 ? void 0 : _b.id}/Settings`, settings, true)
                .then((res) => {
                this.page.toggleBusy(false);
                this.interactionMode = "view";
                this.page.loadAndRenderAll();
                if (res.isAxiosError) {
                    this.page.showErrorMessage("An error occured while updating settings.");
                }
                else {
                    this.page.showSuccessMessage("Updated settings.");
                }
            });
        });
    }
    handleConfigFormChange() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        let formValid = true;
        $("[configform-errmsg]").empty().hide();
        $("[configform-elem").removeClass("is-error");
        this.configFormGrid.css("gap", "1.5rem"); // reset gap trick here
        this.configForm;
        const setErrMsg = (name, msg) => {
            $("[configform-errmsg]").show(); // show all error message blocks, even empty ones, for layout reasons...
            this.configForm[name].errMsg
                .text(msg);
            this.configForm[name].input.addClass("is-error");
            this.configFormGrid.css("gap", "0px 1.5rem"); // get rid of the gap on the form grid, for layout reasons...
            formValid = false;
        };
        const formData = {
            powerMarket: this.configForm.powerMarket.input.val(),
            loadZone: this.configForm.loadZone.input.val(),
            rampDownWatts: this.configForm.rampDownWatts.input.val(),
            rampDownDuration: this.configForm.rampDownDuration.input.val(),
            rampUpWatts: this.configForm.rampUpWatts.input.val(),
            rampUpDuration: this.configForm.rampUpDuration.input.val(),
            holdPeriodMinutes: this.configForm.holdPeriodMinutes.input.val(),
        };
        if (formData.rampDownWatts === "") {
            setErrMsg("rampDownWatts", "This field is required.");
        }
        if (formData.rampDownDuration === "") {
            setErrMsg("rampDownDuration", "This field is required.");
        }
        if (formData.rampUpWatts === "") {
            setErrMsg("rampUpWatts", "This field is required.");
        }
        if (parseFloat(formData.rampUpDuration) <= 0) {
            setErrMsg("rampUpDuration", "This field is required.");
        }
        if (parseFloat(formData.rampDownWatts) <= 0) {
            setErrMsg("rampDownWatts", "Value must be greater than zero.");
        }
        if (parseFloat(formData.rampDownDuration) <= 0) {
            setErrMsg("rampDownDuration", "Value must be greater than zero.");
        }
        if (parseFloat(formData.rampUpWatts) <= 0) {
            setErrMsg("rampUpWatts", "Value must be greater than zero.");
        }
        if (parseFloat(formData.rampUpDuration) <= 0) {
            setErrMsg("rampUpDuration", "Value must be greater than zero.");
        }
        if (parseFloat(formData.holdPeriodMinutes) < 0) {
            setErrMsg("holdPeriodMinutes", "Value must not be negative.");
        }
        const rampDownWattsChanged = ((_a = this.page.curtailmentConfig) === null || _a === void 0 ? void 0 : _a.rampDown.wattsPerSecond) !== Number(formData.rampDownWatts);
        const rampUpWattsChanged = ((_b = this.page.curtailmentConfig) === null || _b === void 0 ? void 0 : _b.rampUp.wattsPerSecond) !== Number(formData.rampUpWatts);
        const powerMarketChanged = formData.powerMarket === "unassigned"
            ? ((_e = (_d = (_c = this.page.curtailmentConfig) === null || _c === void 0 ? void 0 : _c.market) === null || _d === void 0 ? void 0 : _d.marketSupplier) === null || _e === void 0 ? void 0 : _e.id) !== null
            : ((_h = (_g = (_f = this.page.curtailmentConfig) === null || _f === void 0 ? void 0 : _f.market) === null || _g === void 0 ? void 0 : _g.marketSupplier) === null || _h === void 0 ? void 0 : _h.id) !== Number(formData.powerMarket);
        const loadZoneChanged = formData.loadZone === "unassigned"
            ? ((_l = (_k = (_j = this.page.curtailmentConfig) === null || _j === void 0 ? void 0 : _j.market) === null || _k === void 0 ? void 0 : _k.marketSupplier) === null || _l === void 0 ? void 0 : _l.id) !== null
            : Number(formData.loadZone) !== ((_m = this.page.curtailmentConfig) === null || _m === void 0 ? void 0 : _m.market.marketZone.id);
        const holdPeriodMinutesChanged = formData.holdPeriodMinutes !== (((_o = this.page.curtailmentConfig) === null || _o === void 0 ? void 0 : _o.holdPeriodSeconds) / 60).toString();
        const hasChanged = rampDownWattsChanged || rampUpWattsChanged || powerMarketChanged || loadZoneChanged || holdPeriodMinutesChanged;
        const shouldDisable = !formValid || !hasChanged;
        if (shouldDisable) {
            this.configFormSubmitBtn.prop("disabled", true);
            this.configFormSubmitBtn.removeClass("is-secondary");
        }
        else {
            this.configFormSubmitBtn.prop("disabled", false);
            this.configFormSubmitBtn.addClass("is-secondary");
        }
    }
    bindRampInputs() {
        this.configForm.rampDownWatts.input.on("input", () => {
            this.configForm.rampDownDuration.input.val((this.page.curtailmentStats.totalPowerConsumptionWatts / this.configForm.rampDownWatts.input.val() / 60).toFixed(2));
        });
        this.configForm.rampDownDuration.input.on("input", () => {
            this.configForm.rampDownWatts.input.val(Math.round(this.page.curtailmentStats.totalPowerConsumptionWatts / (this.configForm.rampDownDuration.input.val() * 60)));
        });
        this.configForm.rampUpWatts.input.on("input", () => {
            this.configForm.rampUpDuration.input.val((this.page.curtailmentStats.totalPowerConsumptionWatts / this.configForm.rampUpWatts.input.val() / 60).toFixed(2));
        });
        this.configForm.rampUpDuration.input.on("input", () => {
            this.configForm.rampUpWatts.input.val(Math.round(this.page.curtailmentStats.totalPowerConsumptionWatts / (this.configForm.rampUpDuration.input.val() * 60)));
        });
    }
    emptyInputs() {
        this.configForm.rampDownWatts.input.val("");
        this.configForm.rampDownDuration.input.val("");
        this.configForm.rampUpWatts.input.val("");
        this.configForm.rampUpDuration.input.val("");
        this.configForm.holdPeriodMinutes.input.val("");
        this.configForm.loadZone.input.empty();
        this.configForm.powerMarket.input.empty();
    }
}
ConfigForm.template = `
            <div class="m-stack is-horizontal has-space-between is-align-center">
                <h3 class="m-heading is-size-xl">
                    {{#canEdit}}
                        {{#hasConfig}}
                            Energy Control
                        {{/hasConfig}}
                        {{^hasConfig}}
                            Create Curtailment Configuration
                        {{/hasConfig}}
                    {{/canEdit}}
                    {{^canEdit}}
                        {{#hasConfig}}
                            Energy Control
                        {{/hasConfig}}
                        {{^hasConfig}}
                            <div class="m-text">There is no active configuration for this site</div>
                        {{/hasConfig}}
                    {{/canEdit}}
                </h3>
                {{#isEdit}}
                    {{#canEdit}}
                        <div id="configFormBtns" class="m-stack is-horizontal">
                            {{#hasConfig}}
                                <button class="m-button is-tertiary" type="button" onclick="c.handleCancelButtonClick();">Cancel</button>
                            {{/hasConfig}}
                            <button class="m-button" type="button" id="configFormSubmitBtn" disabled>Save</button>
                        </div>
                    {{/canEdit}}
                {{/isEdit}}
                {{^isEdit}}
                    {{#canEdit}}
                        <button class="m-button is-secondary" type="button" id="editBtn" onclick="c.handleEditButtonClick();">
                            <span class="m-button-label" type="button">Edit</span>
                        </button>
                    {{/canEdit}}
                {{/isEdit}}
            </div>
            <div id="configFormWrapper">
                <div id="configGrid" class="config-form m-stack is-horizontal is-align-center">
                    {{#isEdit}}
                        {{#canEdit}}
                            <div configform-section class="m-stack">
                                <h4 class="m-text is-size-l">Power Settings</h4>
                                <div class="m-form-group">
                                    <div class="m-form-control">
                                        <label class="m-label is-tertiary" for="powerMarket" id="powerMarketLabel">Power Market</label>
                                        <div class="m-select">
                                            <select id="powerMarket" configform-elem>
                                                {{#powerMarketOptions}}
                                                    <option value="{{value}}" {{{selected}}}>{{label}}</option>
                                                {{/powerMarketOptions}}
                                            </select>
                                        </div>
                                        <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="powerMarketErrMsg" configform-errmsg>Error message goes right here</span>
                                    </div>
                                    <div class="m-form-control">
                                        <label class="m-label is-tertiary" for="loadZone" id="loadZoneLabel">Load Zone</label>
                                        <div class="m-select">
                                            <select id="loadZone" configform-elem>
                                                    {{#loadZoneOptions}}
                                                        <option value="{{value}}" {{{selected}}}>{{label}}</option>
                                                    {{/loadZoneOptions}}
                                            </select>
                                        </div>
                                        <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="loadZoneErrMsg" configform-errmsg>Error message goes right here</span>
                                    </div>
                                </div>
                            </div>
                            <div class="m-stack is-horizontal has-space-m">
                                <div configform-section class="m-stack">
                                    <h4 class="m-text is-size-l">Ramp Down</h4>
                                    <div class="m-form-group">
                                        <div class="m-form-control">
                                            <label class="m-label is-tertiary is-required" for="rampDownWatts" id="rampDownWattsLabel">Watts/s</label>
                                            <input class="m-input" id="rampDownWatts" type="number" configform-elem value="{{rampDownWatts}}"/>
                                            <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="rampDownWattsErrMsg" configform-errmsg>Error message goes right here</span>
                                        </div>
                                        <div class="m-form-control">
                                            <label class="m-label is-tertiary is-required" for="rampDownDuration" id="rampDownDurationLabel">Duration (minutes)</label>
                                            <input class="m-input" id="rampDownDuration" type="number" configform-elem value="{{rampDownDuration}}"/>
                                            <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="rampDownDurationErrMsg" configform-errmsg>Error message goes right here</span>
                                        </div>
                                    </div>
                                </div>
                                <div configform-section class="m-stack">
                                    <h4 class="m-text is-size-l">Ramp Up</h4>
                                    <div class="m-form-group">
                                        <div class="m-form-control">
                                            <label class="m-label is-tertiary is-required" for="rampUpWatts" id="rampUpWattsLabel">Watts/s</label>
                                            <input class="m-input" id="rampUpWatts" type="number" configform-elem value="{{rampUpWatts}}" />
                                            <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="rampUpWattsErrMsg" configform-errmsg>Error message goes right here</span>
                                        </div>
                                        <div class="m-form-control">
                                            <label class="m-label is-tertiary is-required" for="rampUpDuration" id="rampUpDurationLabel">Duration (minutes)</label>
                                            <input class="m-input" id="rampUpDuration" type="number" configform-elem value="{{rampUpDuration}}" />
                                            <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="rampUpDurationErrMsg" configform-errmsg>Error message goes right here</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div configform-section class="m-stack">
                                <h4 class="m-text is-size-l">Hold Period</h4>
                                <div class="m-form-control">
                                    <label class="m-label is-tertiary" for="holdPeriodMinutes" id="holdPeriodMinutesLabel">Minutes (optional)</label>
                                    <input class="m-input" id="holdPeriodMinutes" type="number" min="0" configform-elem value="{{holdPeriodMinutes}}" />
                                    <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="holdPeriodMinutesErrMsg" configform-errmsg>Error message goes right here</span>
                                </div>
                            </div>
                        {{/canEdit}}
                    {{/isEdit}}

                    {{^isEdit}}
                        <div configform-section class="m-stack">
                            <h4 class="m-text is-size-l">Power Settings</h4>
                            <div class="m-form-group">
                                <div class="config-stat m-stack has-space-s">
                                    <label class="m-label is-tertiary" for="powerMarket" id="powerMarketLabel">Power Market</label>
                                    <h3 class="m-heading is-size-l">{{powerMarket}}</h3>
                                    <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="powerMarketErrMsg" configform-errmsg>Error message goes right here</span>
                                </div>
                                <div class="config-stat m-stack has-space-s">
                                    <label class="m-label is-tertiary" for="loadZone" id="loadZoneLabel">Load Zone</label>
                                    <h3 class="m-heading is-size-l">{{loadZone}}</h3>
                                    <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="loadZoneErrMsg" configform-errmsg>Error message goes right here</span>
                                </div>
                            </div>
                        </div>
                        <div class="m-stack is-horizontal has-space-m">
                            <div configform-section class="m-stack">
                                <h4 class="m-text is-size-l">Ramp Down</h4>
                                <div class="m-form-group">
                                    <div class="config-stat m-stack has-space-s">
                                        <label class="m-label is-tertiary" for="rampDownWatts" id="rampDownWattsLabel">Watts/s</label>
                                        <h3 class="m-heading is-size-l">{{rampDownWatts}}</h3>
                                        <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="rampDownWattsErrMsg" configform-errmsg>Error message goes right here</span>
                                    </div>
                                    <div class="config-stat m-stack has-space-s">
                                        <label class="m-label is-tertiary" for="rampDownDuration" id="rampDownDurationLabel">Duration (minutes)</label>
                                        <h3 class="m-heading is-size-l">{{rampDownDuration}}</h3>
                                        <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="rampDownDurationErrMsg" configform-errmsg>Error message goes right here</span>
                                    </div>
                                </div>
                            </div>
                            <div configform-section class="m-stack">
                                <h4 class="m-text is-size-l">Ramp Up</h4>
                                <div class="m-form-group">
                                    <div class="config-stat m-stack has-space-s">
                                        <label class="m-label is-tertiary" for="rampUpWatts" id="rampUpWattsLabel">Watts/s</label>
                                        <h3 class="m-heading is-size-l">{{rampUpWatts}}</h3>
                                        <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="rampUpWattsErrMsg" configform-errmsg>Error message goes right here</span>
                                    </div>
                                    <div class="config-stat m-stack has-space-s">
                                        <label class="m-label is-tertiary" for="rampUpDuration" id="rampUpDurationLabel">Duration (minutes)</label>
                                        <h3 class="m-heading is-size-l">{{rampUpDuration}}</h3>
                                        <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="rampUpDurationErrMsg" configform-errmsg>Error message goes right here</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div configform-section class="m-stack">
                            <h4 class="m-text is-size-l">Hold Period</h4>
                            <div class="config-stat m-stack has-space-s">
                                <label class="m-label is-tertiary" for="holdPeriodMinutes" id="holdPeriodMinutesLabel">Minutes (optional)</label>
                                <h3 class="m-heading is-size-l">{{holdPeriodMinutes}}</h3>
                                <span class="m-help-text is-error" style="display: none; height: 2.25rem;" id="holdPeriodMinutesErrMsg" configform-errmsg>Error message goes right here</span>
                            </div>
                        </div>
                    {{/isEdit}}
                </div>
            </div>
        `;

class RuleForm {
    constructor(page) {
        this.page = page;
        this.canEdit = window.canEdit;
        this.defaultFormData = {
            id: -1,
            type: "",
            description: "",
            start: null,
            end: null,
            priceThresholdDollars: null,
            demandThresholdWatts: null,
            zones: [],
        };
        this.formData = Object.assign({}, this.defaultFormData);
        this.ruleFormTemplate = document.getElementById("ruleFormTemplate").innerHTML;
        // bind methods
        this.renderRuleForm = this.renderRuleForm.bind(this);
        this.renderZonesTable = this.renderZonesTable.bind(this);
        this.renderConditionalSection = this.renderConditionalSection.bind(this);
        this.validateRuleForm = this.validateRuleForm.bind(this);
        this.canEdit = (this.canEdit.toLowerCase() === "true");
    }
    renderRuleForm(ruleId) {
        if (!this.canEdit) {
            return;
        }
        this.isEditForm = Boolean(ruleId);
        this.formData = this.isEditForm ? this.page.curtailmentConfig.rules.find((r) => r.id === ruleId) : this.defaultFormData;
        this.originalFormData = Object.assign({}, this.formData);
        this.elem = this.page.mustache.to_html(this.ruleFormTemplate, {});
        this.dialogElem = this.isEditForm ? $(this.page.dialogEditRule) : $(this.page.dialogNewRule);
        this.dialogElem.find(".m-modal-content").empty().append(this.elem);
        // populate form
        if (this.isEditForm) {
            this.dialogElem.find("#ruleDescription").val(this.formData.description);
            this.dialogElem.find(`[name="radioType"][value="${this.formData.type}"]`).prop("checked", "true");
            this.renderConditionalSection();
        }
        const typeRadioBtns = this.dialogElem.find("[name='radioType']");
        const inputDescription = this.dialogElem.find("#ruleDescription");
        typeRadioBtns.on("change", (e) => {
            // reset conditional section of form data
            this.formData.start = null;
            this.formData.end = null;
            this.formData.priceThresholdDollars = null;
            this.formData.demandThresholdWatts = null;
            this.formData.zones = [];
            this.formData.type = this.dialogElem.find("[name='radioType']:checked").val();
            this.dialogElem.find("[conditional-section]").hide();
            this.renderConditionalSection();
            this.validateRuleForm();
        });
        inputDescription.on("change", (e) => {
            this.formData.description = $(e.target).val();
            this.validateRuleForm();
        });
        this.dialogElem.find("#submitBtn").off().on("click", (e) => {
            if (this.isEditForm) {
                this.page.closeDialogEditRule();
                this.page.toggleBusy(true);
                this.page.patch(`Curtailment/Config/${this.page.curtailmentConfig.id}/rules/${ruleId}`, this.formData, true).then((r) => {
                    this.page.loadAndRenderAll();
                    if (r.isAxiosError) {
                        this.page.showErrorMessage("An error occured while editing rule.");
                        return;
                    }
                });
                return;
            }
            this.page.closeDialogNewRule();
            this.page.toggleBusy(true);
            this.page.post(`Curtailment/Config/${this.page.curtailmentConfig.id}/rules`, this.formData, true).then((r) => {
                this.page.loadAndRenderAll();
                if (r.isAxiosError) {
                    this.page.showErrorMessage("An error occured while creating rule.");
                    return;
                }
            });
        });
    }
    renderZonesTable(conditionalSection) {
        const zones = this.page.zones.map((z) => {
            return {
                zoneName: z.zoneName,
                minersCount: z.minerCount,
                modelsCount: z.minerModelCount,
                totalPower: z.totalPowerConsumptionWatts,
                id: z.zoneId
            };
        });
        const totals = zones.reduce((acc, curr) => {
            acc.minersCount += curr.minersCount;
            acc.modelsCount += curr.modelsCount;
            acc.totalPower += curr.totalPower;
            return acc;
        }, { minersCount: 0, modelsCount: 0, totalPower: 0 });
        const tempData = {
            totals: {
                minersCount: totals.minersCount,
                modelsCount: "",
                totalPower: (totals.totalPower / 1000000).toFixed(4) + " MW",
            },
            zones: zones.map((z) => {
                return {
                    zoneName: z.zoneName,
                    minersCount: z.minersCount,
                    modelsCount: z.modelsCount + " Model(s)",
                    totalPower: (z.totalPower / 1000000).toFixed(4) + " MW",
                    id: z.id,
                };
            }),
        };
        const temp = document.getElementById("zoneTableTemplate").innerHTML;
        const elem = this.page.mustache.to_html(temp, tempData);
        conditionalSection.find("#zonesTable").empty().append(elem);
        conditionalSection.find("[name='zone']").on("change", (e) => {
            this.formData.zones = conditionalSection.find("[name='zone']:checked").toArray().map(z => Number($(z).val()));
            this.validateRuleForm();
        });
    }
    renderConditionalSection() {
        const conditionalSection = this.dialogElem.find(`[conditional-section='${this.formData.type}']`).show();
        switch (this.formData.type) {
            case "schedule":
                const from = this.isEditForm ? getFormDate(this.formData.start) : getFormDate();
                const to = this.isEditForm ? getFormDate(this.formData.end) : getFormDate();
                this.formData.start = formatDate(from);
                this.formData.end = formatDate(to);
                conditionalSection
                    .find("#fromDate")
                    .on("change", (e) => {
                    from.day = $(e.target).val();
                    this.formData.start = formatDate(from);
                    this.validateRuleForm();
                })
                    .val(from.day);
                conditionalSection
                    .find("#fromHour")
                    .on("change", (e) => {
                    from.hour = parseInt($(e.target).val());
                    this.formData.start = formatDate(from);
                    this.validateRuleForm();
                })
                    .val(from.hour);
                conditionalSection
                    .find("#fromMinute")
                    .on("change", (e) => {
                    from.minute = parseInt($(e.target).val());
                    this.formData.start = formatDate(from);
                    this.validateRuleForm();
                })
                    .val(from.minute);
                conditionalSection
                    .find("#fromPeriod")
                    .on("change", (e) => {
                    from.period = $(e.target).val();
                    this.formData.start = formatDate(from);
                    this.validateRuleForm();
                })
                    .val(from.period);
                conditionalSection
                    .find("#toDate")
                    .on("change", (e) => {
                    to.day = $(e.target).val();
                    this.formData.end = formatDate(to);
                    this.validateRuleForm();
                })
                    .val(to.day);
                conditionalSection
                    .find("#toHour")
                    .on("change", (e) => {
                    to.hour = parseInt($(e.target).val());
                    this.formData.end = formatDate(to);
                    this.validateRuleForm();
                })
                    .val(to.hour);
                conditionalSection
                    .find("#toMinute")
                    .on("change", (e) => {
                    to.minute = parseInt($(e.target).val());
                    this.formData.end = formatDate(to);
                    this.validateRuleForm();
                })
                    .val(to.minute);
                conditionalSection
                    .find("#toPeriod")
                    .on("change", (e) => {
                    to.period = $(e.target).val();
                    this.formData.end = formatDate(to);
                    this.validateRuleForm();
                })
                    .val(to.period);
                this.renderZonesTable.call(this, conditionalSection);
                for (const zone of this.formData.zones) {
                    this.dialogElem.find(`[name="zone"][value="${zone}"]`).prop("checked", "true");
                }
                break;
            case "market":
                conditionalSection
                    .find("#price")
                    .on("change", (e) => {
                    this.formData.priceThresholdDollars = Number($(e.target).val());
                    this.validateRuleForm();
                })
                    .val(this.formData.priceThresholdDollars);
                this.renderZonesTable.call(this, conditionalSection);
                for (const zone of this.formData.zones) {
                    this.dialogElem.find(`[name="zone"][value="${zone}"]`).prop("checked", "true");
                }
                break;
            case "system_demand":
                conditionalSection.find("#demand")
                    .on("change", (e) => {
                    this.formData.demandThresholdWatts = Number($(e.target).val());
                    this.validateRuleForm();
                })
                    .val(this.formData.demandThresholdWatts);
                this.renderZonesTable.call(this, conditionalSection);
                for (const zone of this.formData.zones) {
                    this.dialogElem.find(`[name="zone"][value="${zone}"]`).prop("checked", "true");
                }
                break;
        }
    }
    ;
    validateRuleForm() {
        this.dialogElem.find(".m-help-text.is-error").hide();
        this.dialogElem.find("input").removeClass("is-error");
        const ruleDescriptionInput = this.dialogElem.find("#ruleDescription");
        const ruleDescriptionErrMsg = this.dialogElem.find("#ruleDescriptionErrMsg");
        //const ruleTypeInput = this.dialogElem.find("[name='ruleType']");
        //const ruleTypeErrMsg = this.dialogElem.find("#ruleTypeErrMsg");
        let isFormValid = true;
        if (this.formData.description.length === 0) {
            if (this.isEditForm) {
                ruleDescriptionInput
                    .addClass("is-error");
                ruleDescriptionErrMsg
                    .text("This field is required.")
                    .show();
            }
            isFormValid = false;
        }
        // @ts-ignore
        if (this.formData.type === "") {
            isFormValid = false;
        }
        switch (this.formData.type) {
            case "market": {
                const priceInput = this.dialogElem.find("#price");
                const priceErrMsg = this.dialogElem.find("#priceErrMsg");
                const zonesInput = this.dialogElem.find("[name='zone']");
                const zonesErrMsg = this.dialogElem.find("#zonesErrMsg");
                if (this.formData.priceThresholdDollars === null) {
                    if (this.isEditForm) {
                        priceInput.addClass("is-error");
                        priceErrMsg.text("This field is required.");
                        priceErrMsg.show();
                    }
                    isFormValid = false;
                }
                if (this.formData.priceThresholdDollars <= 0) {
                    priceInput.addClass("is-error");
                    priceErrMsg.text("Value must be greater than zero.");
                    priceErrMsg.show();
                    isFormValid = false;
                }
                if (this.formData.zones.length === 0) {
                    if (this.isEditForm) {
                        zonesInput.addClass("is-error");
                        zonesErrMsg.text("Please select at least one zone.");
                        zonesErrMsg.show();
                    }
                    isFormValid = false;
                }
                break;
            }
            case "system_demand": {
                const demandInput = this.dialogElem.find("#demand");
                const demandErrMsg = this.dialogElem.find("#demandErrMsg");
                const zonesInput = this.dialogElem.find("[name='zone']");
                const zonesErrMsg = this.dialogElem.find("#zonesErrMsg");
                if (this.formData.demandThresholdWatts === null) {
                    if (this.isEditForm) {
                        demandInput.addClass("is-error");
                        demandErrMsg.text("This field is required.");
                        demandErrMsg.show();
                    }
                    isFormValid = false;
                }
                if (this.formData.demandThresholdWatts <= 0) {
                    demandInput.addClass("is-error");
                    demandErrMsg.text("Value must be greater than zero.");
                    demandErrMsg.show();
                    isFormValid = false;
                }
                if (this.formData.zones.length === 0) {
                    if (this.isEditForm) {
                        zonesInput.addClass("is-error");
                        zonesErrMsg.text("Please select at least one zone.");
                        zonesErrMsg.show();
                    }
                    isFormValid = false;
                }
                break;
            }
            case "schedule": {
                const fromDateInput = this.dialogElem.find("#fromDate");
                const fromDateErrMsg = this.dialogElem.find("#fromDateErrMsg");
                const toDateInput = this.dialogElem.find("#toDate");
                const toDateErrMsg = this.dialogElem.find("#toDateErrMsg");
                const zonesInput = this.dialogElem.find("[name='zone']");
                const zonesErrMsg = this.dialogElem.find("#zonesErrMsg");
                if (this.formData.start === null) {
                    if (this.isEditForm) {
                        fromDateInput.addClass("is-error");
                        fromDateErrMsg.text("This field is required.");
                        fromDateErrMsg.show();
                    }
                    isFormValid = false;
                }
                if (this.formData.end === null) {
                    if (this.isEditForm) {
                        toDateInput.addClass("is-error");
                        toDateErrMsg.text("This field is required.");
                        toDateErrMsg.show();
                    }
                    isFormValid = false;
                }
                if (this.formData.zones.length === 0) {
                    if (this.isEditForm) {
                        zonesInput.addClass("is-error");
                        zonesErrMsg.text("Please select at least one zone.");
                        zonesErrMsg.show();
                    }
                    isFormValid = false;
                }
                break;
            }
        }
        if (isFormValid) {
            if (this.isEditForm) {
                const isOrigType = this.originalFormData.type === this.formData.type;
                const isOrigDescription = this.originalFormData.description === this.formData.description;
                const isOrigStart = this.originalFormData.start === this.formData.start;
                const isOrigEnd = this.originalFormData.end === this.formData.end;
                const isOrigPrice = this.originalFormData.priceThresholdDollars === this.formData.priceThresholdDollars;
                const isOrigDemand = this.originalFormData.demandThresholdWatts === this.formData.demandThresholdWatts;
                const isOrigZones = this.originalFormData.zones.toString() === this.formData.zones.toString();
                const isFormDataSame = isOrigType && isOrigDescription && isOrigStart && isOrigEnd && isOrigPrice && isOrigDemand && isOrigZones;
                if (isFormDataSame) {
                    this.dialogElem.find("#submitBtn").prop("disabled", true);
                }
                else {
                    this.dialogElem.find("#submitBtn").prop("disabled", false);
                }
            }
            else {
                this.dialogElem.find("#submitBtn").prop("disabled", false);
            }
        }
        else {
            this.dialogElem.find("#submitBtn").prop("disabled", true);
        }
    }
}
function formatDate(d) {
    const hour = derive(() => {
        const h = d.period === "AM" ? d.hour : d.hour + 12;
        if (h === 24) {
            return 12;
        }
        if (h === 12) {
            return 0;
        }
        return h;
    });
    return window.moment(d.day)
        .add(hour, "hours")
        .add(d.minute, "minutes")
        .toISOString();
}
function getFormDate(d) {
    const date = d ? window.moment(d) : window.moment();
    const [hour, period] = derive(() => {
        const h = date.hour();
        if (h === 0) {
            return [12, "AM"];
        }
        if (h === 12) {
            return [12, "PM"];
        }
        if (h > 12) {
            return [h - 12, "PM"];
        }
        return [h, "AM"];
    });
    return {
        day: date.format("YYYY-MM-DD"),
        hour,
        minute: date.minute(),
        period
    };
}

class HistoricalStats extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: true, elemId: "ddlSites" });
        this.minute = 60 * 1000;
        this.sitesUrl = "/sites";
        //private highTempMiners: HighTempMinersGraph;
        //private hashrateGauge: HashrateGauge;
        this.selectedZoneId = "-1";
        this.selectedHashingType = "0";
        this.init();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        setInterval(() => __awaiter(this, void 0, void 0, function* () {
            const queryParams = this.datePicker.isAbsoluteRange ?
                this.datePicker.refreshParams() : this.datePicker.getParams();
            queryParams.siteId = parseInt(yield this.siteCache.getSiteId());
            this.loadQueries(queryParams);
        }), 120000);
    }
    init() {
        this.overallHashrate = new MinersHashrate();
        this.poolHashrate = new PoolHashrate();
        this.offlineMiners = new OfflineMinerGraph();
        this.nonHashingMiners = new NonHashingMinersGraph();
        this.lowHashingMiners = new LowHashingMinersGraph();
        this.buildZones();
        this.buildHashingTypes();
        this.datePicker = new DatePicker("#datePicker", this.loadQueries.bind(this));
    }
    handleCompanyFilterChanged(companyId) {
        if (!this.hasMiners(companyId)) {
            this.showNullState("There aren't any miners setup yet.");
        }
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(siteId) {
        this.getDataForZones()
            .then(() => {
            const queryParams = this.datePicker.getParams();
            this.loadQueries(queryParams);
            this.hideNullState();
            this.getUnsupportedModels().then((models) => {
                this.handleUnsupportedModelsWarning(models);
            });
        });
    }
    handleUnsupportedModelsWarning(models) {
        if (models.length === 0) {
            $(".unsupported-models").removeClass("active");
            return;
        }
        $(".unsupported-models").addClass("active");
    }
    buildZones() {
        const ddlZones = document.getElementById("ddlZones");
        ddlZones.options = [{
                label: "All Zones",
                value: "-1"
            }];
        ddlZones.addEventListener("on-change", (e) => {
            // @ts-ignore
            this.selectedZoneId = e.detail.value;
            const queryParams = this.datePicker.getParams();
            this.loadQueries(queryParams);
        });
        this.getDataForZones();
    }
    getDataForZones() {
        return this.get(`/Zones`)
            .then((resp) => __awaiter(this, void 0, void 0, function* () {
            const ddlZones = document.getElementById("ddlZones");
            const siteId = yield this.siteCache.getSiteId();
            const zones = resp.zones.filter(zone => siteId == zone.siteId.toString()).map(zone => {
                return {
                    label: zone.zoneName,
                    value: zone.zoneId.toString(),
                };
            });
            zones.unshift({
                label: "All Zones",
                value: "-1"
            });
            ddlZones.options = zones;
        }));
    }
    buildHashingTypes() {
        const ddlHashingTypes = document.getElementById("ddlHashingTypes");
        ddlHashingTypes.options = [
            { label: "Mixed", value: "0" },
            { label: "Hashes", value: "1" },
            { label: "Solutions", value: "2", },
        ];
        ddlHashingTypes.addEventListener("on-change", (e) => {
            // @ts-ignore
            this.selectedHashingType = e.detail.value;
            const queryParams = this.datePicker.getParams();
            this.loadQueries(queryParams);
        });
    }
    loadQueries(params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.overallHashrate.chart.currentQueryParams = params;
            this.offlineMiners.chart.currentQueryParams = params;
            this.nonHashingMiners.chart.currentQueryParams = params;
            this.lowHashingMiners.chart.currentQueryParams = params;
            //this.highTempMiners.chart.selectedInterval = this.selectedInterval;
            //this.hashrateGauge.chart.selectedInterval = this.selectedInterval;
            this.poolHashrate.chart.currentQueryParams = params;
            this.overallHashrate.chart.companyFilter = this.getSelectedCompanyId();
            this.offlineMiners.chart.companyFilter = this.getSelectedCompanyId();
            this.nonHashingMiners.chart.companyFilter = this.getSelectedCompanyId();
            this.lowHashingMiners.chart.companyFilter = this.getSelectedCompanyId();
            //this.highTempMiners.chart.companyFilter = this.selectedCompanyId;
            //this.hashrateGauge.chart.companyFilter = this.getSelectedCompanyId();
            this.poolHashrate.chart.companyFilter = this.getSelectedCompanyId();
            const extraFilters = yield this.getFacilityAndZone();
            var hashingTypeId = extraFilters.find(filter => filter[0] == "hashingTypeId")[1];
            if (hashingTypeId == 0) {
                hashingTypeId = 1;
            }
            this.overallHashrate.chart.load(extraFilters);
            this.overallHashrate.setHashingType(hashingTypeId);
            this.offlineMiners.chart.load(extraFilters);
            this.nonHashingMiners.chart.load(extraFilters);
            this.lowHashingMiners.chart.load(extraFilters);
            //this.highTempMiners.chart.load(extraFilters);
            //this.hashrateGauge.chart.load(extraFilters);
            this.poolHashrate.chart.load(extraFilters);
            this.poolHashrate.setHashingType(hashingTypeId);
        });
    }
    getFacilityAndZone() {
        return __awaiter(this, void 0, void 0, function* () {
            const filters = [];
            const siteId = parseInt(yield this.siteCache.getSiteId());
            const zoneId = parseInt(this.selectedZoneId);
            const hashingTypeId = parseInt(this.selectedHashingType);
            filters.push(["siteId", siteId]);
            filters.push(["zoneId", zoneId === -1 ? "" : zoneId]);
            filters.push(["hashingTypeId", hashingTypeId]);
            return filters;
        });
    }
}

class LowHashingMinersGraph {
    constructor() {
        this.chart = new LineChart([LowHashingMinersGraph.lowHashingQuery], "#lowHashingBusy");
        this.chart.elementSelector = "lowHashingChart";
        this.chart.title = "Low-hashing Miners";
        this.chart.extraOptions.export = {
            csv: {
                filename: "Low-hashing Miners",
                headerCategory: "Time",
                headerValue: "Count",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        let serieData = [];
        try {
            serieData.push({
                name: "Low-Hashing Miners",
                data: graphData[0].data.result[0].values
            });
        }
        catch (_a) {
            return;
        }
        this.chart.extraOptions.formatter = this.formatter;
        this.chart.series = serieData;
        $(".lowHashing-chart").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return `${val.toFixed(0)}`;
    }
}
LowHashingMinersGraph.lowHashingQuery = "/LowHashingMiners";

class NonHashingMinersGraph {
    constructor() {
        this.chart = new LineChart([NonHashingMinersGraph.notHashingQuery], "#nonHashingBusy");
        this.chart.elementSelector = "nonHashingChart";
        this.chart.title = "Non-hashing Miners";
        this.chart.extraOptions.export = {
            csv: {
                filename: "Non-hashing Miners",
                headerCategory: "Time",
                headerValue: "Count",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        let serieData = [];
        try {
            serieData.push({
                name: "Non-Hashing Miners",
                data: graphData[0].data.result[0].values
            });
        }
        catch (_a) {
            return;
        }
        this.chart.extraOptions.formatter = this.formatter;
        this.chart.series = serieData;
        $(".nonHashing-chart").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return `${val.toFixed(0)}`;
    }
}
NonHashingMinersGraph.notHashingQuery = "/NonHashingMiners";

class OfflineMinerGraph {
    constructor() {
        this.chart = new LineChart([OfflineMinerGraph.onlineQuery, OfflineMinerGraph.offlineQuery], "#offlineBusy");
        this.chart.elementSelector = "offlineChart";
        this.chart.title = "Online Status";
        this.chart.extraOptions.formatter = null;
        this.chart.extraOptions.export = {
            csv: {
                filename: "Online Status",
                headerCategory: "Time",
                headerValue: "Count",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        graphData.forEach((resp) => {
            try {
                serieData.push({
                    name: (resp.internalName === "offlineMiners" ? "Offline" : "Online"),
                    data: resp.data.result[0].values
                });
            }
            catch (_a) {
                serieData.push({
                    name: (resp.internalName === "offlineMiners" ? "Offline" : "Online"),
                    data: []
                });
            }
        });
        this.chart.extraOptions.formatter = this.formatter;
        this.chart.series = serieData;
        $(".offline-chart").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return `${val.toFixed(0)}`;
    }
}
OfflineMinerGraph.onlineQuery = "/OnlineMiners";
OfflineMinerGraph.offlineQuery = "/OfflineMiners";

class BulkEditTagsModal extends OpModalBase {
    constructor(page, Id) {
        super(Id);
        this.tagsUrl = "/Miner/Tags";
        this.modalId = "BulkEditTagsModal";
        this.preExistingTags = {};
        this.page = page;
        this.newTagElem = $("#createTag");
        this.tagListElem = $(`#${this.modalId}`).find(`#tagList`);
        this.errorMessage = $(`#${this.modalId}`).find("#errorMessage");
        this.message = $(`#${this.modalId}Message`);
        this.alert = $(`#${this.modalId}`).find("#errorAlert");
        this.title = $("#BulkEditTagsModal_HEADING");
        this.alert.hide();
    }
    beforeOpen(initData) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            this.selectedMinerIds = initData.minerIds;
            this.siteId = initData.siteId;
            this.action = initData.action;
            this.message.text(BulkEditTagsModal.MESSAGING[this.action].message);
            this.title.text(BulkEditTagsModal.MESSAGING[this.action].title);
            this.selectedMinerIds.forEach(id => {
                this.preExistingTags[id] = [];
            });
            yield this.loadTagList();
        });
    }
    preSubmitHandler() {
        return __awaiter(this, void 0, void 0, function* () {
            this.page.confirm(BulkEditTagsModal.MESSAGING[this.action].title, BulkEditTagsModal.MESSAGING[this.action].confirm, () => {
                this.toggleModalBusy(true);
                this.updateTags().then(() => {
                    this.clearError();
                    this.toggleModalBusy(false);
                    this.close(null, true);
                    this.page.showSuccessMessage("Successfully edited tags.");
                });
            });
        });
    }
    beforeClose() {
        this.reset;
    }
    reset() {
        this.errorMessage.empty();
        this.tagListElem.empty();
    }
    updateTags() {
        return __awaiter(this, void 0, void 0, function* () {
            switch (this.action) {
                case "overwrite":
                    yield this.overWrite();
                    break;
                case "add":
                    yield this.addTags();
                    break;
                case "remove":
                    yield this.removeTags();
                    break;
            }
        });
    }
    addTags() {
        return __awaiter(this, void 0, void 0, function* () {
            const promises = this.tags.map(tag => {
                if ($(`#tag-${tag.id}`).is(":checked")) {
                    const minerIds = this.selectedMinerIds.filter(id => {
                        return !this.preExistingTags[id].includes(tag.id);
                    });
                    return this.page.post(`/Tags/${tag.id}/Miners`, { minerIds });
                }
            });
            yield Promise.all(promises);
        });
    }
    removeTags() {
        return __awaiter(this, void 0, void 0, function* () {
            const tagsToDelete = this.tags.map(tag => {
                if ($(`#tag-${tag.id}`).is(":checked"))
                    return tag.id;
            });
            yield this.page.delete("/Tags/Miners", { minerIds: this.selectedMinerIds, tagIds: tagsToDelete });
        });
    }
    overWrite() {
        return __awaiter(this, void 0, void 0, function* () {
            const tagsToDelete = [];
            try {
                const promises = this.tags.map(tag => {
                    if ($(`#tag-${tag.id}`).is(":checked")) {
                        // filter out miners that already have this tag
                        const minerIds = this.selectedMinerIds.filter(id => {
                            return !this.preExistingTags[id].includes(tag.id);
                        });
                        return this.page.post(`/Tags/${tag.id}/Miners`, { minerIds });
                    }
                    tagsToDelete.push(tag.id.toString());
                    return;
                });
                yield Promise.all(promises);
                if (tagsToDelete.length == 0)
                    return;
                yield this.page.delete("/Tags/Miners", { minerIds: this.selectedMinerIds, tagIds: tagsToDelete });
            }
            catch (e) {
                this.toggleModalBusy(false);
                this.showErrorMessage(`An error occurred while adding/removing tags from selected miners`);
            }
        });
    }
    createTag() {
        return __awaiter(this, void 0, void 0, function* () {
            event.preventDefault();
            this.clearError();
            const newTag = this.newTagElem.val().trim();
            if (newTag == "") {
                this.showErrorMessage("Tag name cannot be empty.");
                return;
            }
            if (newTag.includes(",")) {
                this.showErrorMessage("Tags cannot contain commas.");
            }
            const tagExists = this.tags.some(tag => tag.name === newTag);
            if (tagExists) {
                this.showErrorMessage("Tag with this name already exists.");
                return;
            }
            this.toggleModalBusy(true);
            this.page.post("/Tags", {
                TagNames: [newTag],
                SiteId: this.siteId
            }).then(res => {
                this.newTagElem.val("");
                this.loadTagList();
                this.toggleModalBusy(false);
            });
        });
    }
    showErrorMessage(message) {
        this.errorMessage.text(message);
        this.alert.show();
    }
    clearError() {
        this.errorMessage.empty();
        this.alert.hide();
    }
    loadTagList() {
        return __awaiter(this, void 0, void 0, function* () {
            this.tagListElem.empty();
            const tags = {};
            const tagPromises = this.selectedMinerIds.map(id => {
                return this.page.get(`${this.tagsUrl}?MinerId=${id}`).then((resp) => {
                    resp.tags.forEach(tag => {
                        this.preExistingTags[id].push(tag.id);
                        tags[tag.name] ? tags[tag.name]++ : tags[tag.name] = 1;
                    });
                });
            });
            yield Promise.all(tagPromises);
            const siteTags = yield this.page.get(`/Tags?siteId=${this.siteId}`);
            this.tags = siteTags.tags;
            if (this.tags.length == 0) {
                this.message.hide();
                this.tagListElem.append("<p class=\"m-text\">This site does not have any active or visible tags.</p>");
                return;
            }
            this.message.show();
            this.tags.forEach(tag => {
                const checked = tags[tag.name] && tags[tag.name] == this.selectedMinerIds.length ? "checked" : "";
                const template = self.Mustache.to_html(BulkEditTagsModal.CHECKBOX, { id: tag.id, name: tag.name, checked });
                this.tagListElem.append(template);
            });
        });
    }
    navToSiteSetup() {
        window.location.assign(`/Content/Administration/SiteDetails?siteId=${this.siteId}&tab=Tags`);
    }
}
BulkEditTagsModal.CHECKBOX = `
        <div class="m-checkbox">
            <input type="checkbox" id="tag-{{id}}" {{{checked}}} />
            <label class="m-label" for="tag-{{id}}">{{name}}</label>
        </div>
    `;
BulkEditTagsModal.MESSAGING = {
    overwrite: {
        title: "Overwrite Tags",
        message: "Select tags to be applied and unselect tags to be removed.",
        confirm: "Are you sure you want to replace the tags on the selected miner(s) with the selected tag(s)?",
    },
    add: {
        title: "Add Tags",
        message: "Select tags to add to selected miner(s).",
        confirm: "Are you sure you want to add these tag(s) to the selected miner(s)?",
    },
    remove: {
        title: "Remove Tags",
        message: "Select tags to be removed from selected miner(s).",
        confirm: "Are you sure you want to remove these tag(s) from the selected miner(s)?",
    },
};

class MinerAdmin extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: true, elemId: "ddlSites" });
        this.minersUrl = "/MinerInfo";
        this.deleteUrl = "/DeleteMiners";
        this.rebootMinersUrl = "/RebootMiners";
        this.hashingInventoryUrl = "/HashingInventory";
        this.siteDetailsUrl = "/siteDetails";
        this.updateMinersUrl = "/BulkUpdateMiners";
        this.gridLoaded = false;
        this.isInitialLoad = true;
        this.editPanel = new MinerAdminBulkEdit();
        this.sheetEditor = new MinerAdminSheetEdit();
        this.minerFilters = new MinerFilters(this);
        this.rebootMinersModal = new OpRebootMinersModal(this, "RebootMinersModal", this.handleRebootResponse.bind(this));
        this.logFetchModal = new LogFetchModal(this, "LogFetchModal");
        this.bulkMinerMapModal = new BulkMinerMapModal(this, "BulkMinerMapModal");
        this.bulkMinerRenameModal = new BulkMinerRenameModal(this, "BulkMinerRenameModal");
        this.bulkEditTagsModal = new BulkEditTagsModal(this, "BulkEditTagsModal");
        this.deleteMinersModal = new OpConfirmationModal("DeleteModal", this.bulkDelete.bind(this));
        this.poolConfigModal = new OpPoolConfigModal(this, "PoolConfigModal");
        this.minerEditor = new OpMinerEditorModal(this, "MinerEditorModal", this.refresh.bind(this));
        this.assignMinersModal = new OpMinerOwnerAssignmentModal(this, "MinerAssignmentModal", this.refresh.bind(this));
        this.notesSearchPanel = new MinerNotesSearchPanel();
        this.bulkSearch = new MinerBulkSearch();
        this.bulkSearch.onMinersFiltered = this.filterMiners.bind(this);
        this.notesSearchPanel.onMinersFiltered = this.filterMinersFromNotesFilter.bind(this);
        this.editPanel.onBulkEditSaved = this.getMiners.bind(this);
        this.sheetEditor.onMinersEdited = this.getMiners.bind(this);
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.rebootMinersModal.afterClose = this.onModalClose.bind(this);
        this.deleteMinersModal.afterClose = this.onModalClose.bind(this);
        this.poolConfigModal.afterClose = this.onModalClose.bind(this);
        this.minerEditor.afterClose = this.onModalClose.bind(this);
        this.bulkMinerMapModal.afterClose = this.refresh.bind(this);
        this.bulkMinerRenameModal.afterClose = this.refresh.bind(this);
        this.bulkEditTagsModal.afterClose = this.refresh.bind(this);
        this.initGrid();
        this.initZoneDropDown();
        this.restrictModifyActions();
        this.onSiteFilterChanged = this.handleSiteChange.bind(this);
        this.toggleBusy(true);
        this.loadGridSources().then(() => {
            this.toggleBusy(false);
            this.refreshDisabled = false;
            this.refreshFunction = this.refresh.bind(this);
            this.refreshCountdownDisabled = true;
        });
    }
    getMiner(minerId) {
        return this.miners.filter((miner) => {
            return miner.id === minerId;
        })[0];
    }
    onContextMenuSelect(e) {
        const targetMinerId = MinerAdmin.INDIVIDUAL_MINER_SELECTION;
        const minerSite = this.miners.find(m => m.id == parseInt(targetMinerId)).siteId;
        const item = $(e.item);
        const action = item.attr("action");
        if (typeof action === "undefined" || !targetMinerId) {
            return;
        }
        switchMap(action, {
            "MINER_VIEW": () => OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${targetMinerId}`),
            "EDIT_MINER": () => this.minerEditor.open(this.miners.find(m => m.id == parseInt(targetMinerId))),
            "EDIT_TAGS": () => this.bulkEditTagsModal.open({ siteId: minerSite, minerIds: [targetMinerId], action: "overwrite" }),
            "MINER_COMMENTS": () => OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${targetMinerId}&active_tab=Comments`),
            "UNASSIGN_MINER": () => this.updateMinerLocation(targetMinerId, "unassigned"),
            "MINER_REBOOT": () => this.openRebootModal(parseInt(targetMinerId)),
            "FETCH_LOGS": () => this.logFetchModal.open(this.miners.find(m => m.id == parseInt(targetMinerId)).id),
            "UPDATE_LOCATION": () => { },
            "DELETE_MINER": () => this.openDeleteModal(),
            "CONFIGURE_POOLS": () => this.openPoolConfigModal(),
        });
    }
    onModalClose() {
        MinerAdmin.INDIVIDUAL_MINER_SELECTION = undefined;
    }
    handleSiteChange() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteId = parseInt(yield this.siteCache.getSiteId());
            siteId == -1 ? $("#ContentPlaceHolder1_tagsMenuWrapper").hide() : $("#ContentPlaceHolder1_tagsMenuWrapper").show();
            this.restrictModifyActions();
            if (!this.isInitialLoad) {
                this.minerFilters.refresh();
                this.isInitialLoad = true;
            }
            this.isInitialLoad = false;
            this.toggleBusy(true);
            this.loadZones(siteId)
                .then(() => {
                this.getMiners(siteId);
                this.toggleBusy(false);
            });
        });
    }
    restrictModifyActions() {
        const siteId = parseInt(localStorage.getItem("selectedSite"));
        if (siteId == -1) {
            $("#ConfigurePools").removeClass("active");
        }
        else
            $("#ConfigurePools").addClass("active");
    }
    loadGridSources() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteId = parseInt(yield this.siteCache.getSiteId());
            this.toggleBusy(true);
            this.loadZones(siteId)
                .then(() => {
                this.getMiners(siteId);
                this.toggleBusy(false);
            });
        });
    }
    handleCompanyFilterChanged() {
        if (this.getSelectedCompanyId() <= 0) {
            this.toggleSelectCompany(true);
            return;
        }
        else {
            this.toggleSelectCompany(false);
        }
        this.siteCache.loadSites();
    }
    loadZones(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const zoneListDDL = document.getElementById("ddlZones");
            const url = `${this.siteDetailsUrl}?siteId=${siteId}`;
            const zonesRes = yield this.get(url);
            const zoneFilterOptions = zonesRes.zones.map((zone) => {
                return { label: zone.zoneName, value: zone.zoneId.toString() };
            });
            zoneFilterOptions.unshift({ label: "Unassigned", value: "-2" });
            zoneFilterOptions.unshift({ label: "All Zones", value: "-1" });
            zoneListDDL.options = zoneFilterOptions;
            const unassigned = this.getQueryStringValue("zone");
            if (unassigned == "unassigned") {
                zoneListDDL.selected = "-2";
                return;
            }
            const selectedZone = this.getZone();
            const zone = this.getQueryStringValue("zoneId");
            zoneListDDL.selected = derive(() => {
                if (zone) {
                    return zone;
                }
                for (let option of zoneFilterOptions) {
                    if (option.value === selectedZone.id) {
                        return selectedZone.id;
                    }
                }
                localStorage.setItem("selectedZone", "-1");
                return "-1";
            });
            let zoneName = selectedZone.name;
            if (zoneName.toLowerCase() !== "all zones" && zoneName.toLowerCase() !== "unassigned") {
                this.bulkMinerMapModal.zoneName = zoneName;
            }
            yield this.handleZoneChange();
            return Promise.resolve();
        });
    }
    handleZoneChange() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteId = yield this.siteCache.getSiteId();
            const zone = this.getZone();
            if (siteId !== "-1" && zone.name.toLowerCase() !== "unassigned") {
                this.bulkMinerMapModal.zoneName = zone.name;
                $(".actions-dropdown-import-section").show();
            }
            else {
                $(".actions-dropdown-import-section").hide();
            }
        });
    }
    loadHashingInventory(siteId, zoneId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.getHashingInventoryUrl(siteId, zoneId);
            const hashingInventory = yield this.get(url);
            const totalMinerSlots = hashingInventory.positionCount;
            const minersHashing = hashingInventory.hashingCount;
            const minersWithLocations = hashingInventory.minerCountWithLocations;
            const reservedLocationCount = hashingInventory.reservedLocationCount;
            const lowHashingMiners = hashingInventory.lowHashingCount;
            const notHashingMiners = hashingInventory.notHashingCount;
            const totalMiners = hashingInventory.totalCount;
            const emptySlots = totalMinerSlots - minersWithLocations - reservedLocationCount;
            $("#totalMinersCount").text(totalMiners);
            $("#hashingMinersCount").text(minersHashing);
            $("#lowHashingMinersCount").text(lowHashingMiners);
            $("#notHashingMinersCount").text(notHashingMiners);
            $("#emptySlotsCount").text(emptySlots);
            $("#reservedSlotsCount").text("NaN");
        });
    }
    getHashingInventoryUrl(siteId, zoneId) {
        if (siteId < 0) {
            return this.hashingInventoryUrl;
        }
        if (zoneId < 0) {
            return `${this.hashingInventoryUrl}?siteId=${siteId}`;
        }
        return `${this.hashingInventoryUrl}?siteId=${siteId}&zoneId=${zoneId}`;
    }
    navToSiteMap() {
        localStorage.setItem("minerPreference", "map");
        window.location.assign("/Content/Dashboard/Miners/Map.aspx");
    }
    refresh() {
        return __awaiter(this, void 0, void 0, function* () {
            this.toggleBusy(true);
            MinerAdmin.INDIVIDUAL_MINER_SELECTION = undefined;
            const zoneFilter = document.getElementById("ddlZones");
            const siteId = parseInt(localStorage.getItem("selectedSite"));
            let zoneName = zoneFilter.options.find((z) => zoneFilter.selected === z.value).label || "";
            this.bulkMinerMapModal.zoneName = zoneName;
            yield this.handleZoneChange();
            const minersReq = yield this.getMiners(siteId);
            this.toggleBusy(false);
            return minersReq;
        });
    }
    initZoneDropDown() {
        let zoneFilter = document.getElementById("ddlZones");
        zoneFilter.addEventListener("on-change", (e) => {
            localStorage.setItem("selectedZone", e.detail.value);
            this.refresh();
        });
    }
    initGrid() {
        let grid = $("#minerGrid").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 100
            },
            height: "100%",
            pageable: {
                pageSizes: [10, 100, 500, 1000, 5000],
                buttonCount: 5
            },
            sortable: true,
            mobile: true,
            persistSelection: true,
            resizable: true,
            filterable: false,
            columnMenu: false,
            scrollable: true,
            editable: false,
            reorderable: true,
            columnReorder: (e) => {
                setTimeout(() => { this.setColumnOrder(e.sender.columns); }, 200);
            },
            change: this.handleMinerSelection.bind(this),
            excel: {
                allPages: true
            },
            noRecords: {
                template: () => this.NO_MINERS_HTML()
            },
            columns: [
                { selectable: true, width: "60px", },
                { field: "serialNumber", title: "Serial Number", width: "200px", template: MinerGridColumnTemplates.getSerialNumberTemplate.bind(this) },
                { field: "modelName", title: "Model", width: "190px" },
                { field: "tags", title: "Tags", width: "150px" },
                { field: "ipAddress", title: "IP Address", width: "120px", template: (miner) => MinerGridColumnTemplates.getIpAddressColumnTemplate(miner), minResizableWidth: 100 },
                { field: "locationName", title: "Slot ID", width: "200px" },
                { field: "statusName", title: "Status", width: "125px" },
                {
                    field: "minerName", title: "Miner Name", width: "170px", sortable: {
                        compare: function (a, b) {
                            return SortUtil.alphaNumericSort(a.hashRatePercent, b.hashRatePercent);
                        }
                    }
                },
                {
                    field: "hashRatePercent", title: "Hash Rate Efficiency", width: "100px", template: MinerGridColumnTemplates.getEfficiencyTemplate.bind(this),
                    sortable: {
                        compare: function (a, b) {
                            return SortUtil.alphaNumericSort(a.hashRatePercent, b.hashRatePercent);
                        }
                    }
                },
                {
                    field: "hashrate", title: "Hash Rate (20m)", width: "150px", template: MinerGridColumnTemplates.getHashrateTemplate.bind(this),
                },
                { field: "temperature", title: "Temp.", width: "115px", template: MinerGridColumnTemplates.getChipTempListTemplate.bind(this) },
                { field: "fans", title: "Fan Speed", width: "160px", template: MinerGridColumnTemplates.getFanSpeedTemplate.bind(this) },
                { field: "powerModeName", title: "Power Mode", width: "120px" },
                { field: "watts", title: "Power", width: "90px", template: MinerGridColumnTemplates.getPowerTemplate.bind(this) },
                {
                    field: "uptime", title: "Uptime", width: "120px", template: MinerGridColumnTemplates.getUptimeTemplate.bind(this),
                    sortable: {
                        compare: function (a, b) {
                            return SortUtil.variedTimeSort(a.uptime, b.uptime);
                        }
                    }
                },
                { field: "errors", title: "Error Code", width: "150px", template: MinerGridColumnTemplates.getErrorTemplate.bind(this) },
                { field: "combinedErrors", title: "Errors", width: "150px", hidden: true },
                { field: "siteName", title: "Site", width: "200px" },
                { field: "zoneName", title: "Zone", width: "120px" },
                { field: "macAddress", title: "MAC Address", width: "180px" },
                { field: "firmwareVersion", title: "Firmware", width: "210px" },
                { field: "pool1", title: "Pool 1", width: "320px" },
                { field: "account1", title: "Account 1", width: "120px" },
                { field: "worker1", title: "Worker 1", width: "120px" },
                { field: "pool2", title: "Pool 2", width: "320px" },
                { field: "account2", title: "Account 2", width: "120px" },
                { field: "worker2", title: "Worker 2", width: "120px" },
                { field: "pool3", title: "Pool 3", width: "320px" },
                { field: "account3", title: "Account 3", width: "120px" },
                { field: "worker3", title: "Worker 3", width: "120px" },
                { field: "autoPool", title: "AutoPool", width: "120px" },
                { field: "subcustomerName", title: "Customer", width: "120px" },
                { field: "slotNote", title: "Slot Note", width: "120px" },
                { field: "onlineDate", title: "Online Date", width: "120px", template: MinerGridColumnTemplates.getOnlineDateTemplate.bind(this) },
                { title: "", width: "55px", locked: true, template: MinerGridColumnTemplates.getElipsisTemplate() }
            ]
        }).data("kendoGrid");
        grid.one("dataBound", (e) => {
            const grid = e.sender;
            const pageSizesDdl = $(grid.pager.element).find("[data-role='dropdownlist']").data("kendoDropDownList");
            pageSizesDdl.bind("change", (ev) => {
                this.pageSize = ev.sender.value();
                grid._selectedIds = {}; // clears selection on all pages
                grid.clearSelection();
            });
        });
        $("#minerSlotMenu").kendoContextMenu({
            target: "#minerGrid",
            filter: ".menu-wrapper",
            animation: {
                open: { effects: "fadeIn" },
            },
            showOn: "click",
            open: this.onMinerContextMenuOpen.bind(this),
            select: this.onContextMenuSelect.bind(this),
        });
        const columnSort = JSON.parse(localStorage.getItem("miner-list-columns"));
        if (!columnSort) {
            return;
        }
        grid = $("#minerGrid").data("kendoGrid");
        this.sortGridColumns(columnSort, grid);
    }
    sortGridColumns(columnSort, grid) {
        const columnsToSort = this.removeOldColumns(columnSort);
        columnsToSort.forEach((column, index) => {
            if (!column.field) {
                return;
            }
            const gridColumn = grid.columns.filter((col) => {
                return col.field === column.field;
            })[0];
            if (!gridColumn) {
                return;
            }
            grid.reorderColumn(index, gridColumn);
        });
    }
    removeOldColumns(columns) {
        return columns.filter((column) => {
            return column.field !== "connectivity";
        });
    }
    setColumnOrder(columns) {
        localStorage.setItem("miner-list-columns", JSON.stringify(columns));
    }
    onMinerContextMenuOpen(e) {
        const minerId = parseInt($(e.target).attr("data-miner-id"));
        if (isNaN(minerId) || !minerId) {
            e.preventDefault();
            return;
        }
        const miner = this.getMiner(minerId);
        if (!miner) {
            e.preventDefault();
            return;
        }
        MinerAdmin.INDIVIDUAL_MINER_SELECTION = String(minerId);
        $("#slotMenuMinerName").text(miner.minerName);
        $("#slotMenuIp").text(miner.ipAddress);
        $("#slotMenuStatus").text(miner.statusName);
        if (miner.errorList.length > 0) {
            $("#slotMenuErrorCodeText").show();
            $("#slotMenuErrorCode").text(miner.errors);
        }
        else {
            $("#slotMenuErrorCodeText").hide();
        }
    }
    handleMinerSelection() {
        const grid = $("#minerGrid").data("kendoGrid");
        const selectedItems = grid.selectedKeyNames();
        MinerAdmin.SELECTED_MINER_IDS = selectedItems;
        $("#minerSelectedCount").text(selectedItems.length);
        if (MinerAdmin.SELECTED_MINER_IDS.length === 0) {
            this.editPanel.close();
            this.toggleEditButtonVisible(false);
            return;
        }
        this.toggleEditButtonVisible(true);
    }
    toggleEditButtonVisible(isVisible) {
        if (!isVisible) {
            $("#modifyMenu").removeClass("active");
            return;
        }
        $("#modifyMenu").addClass("active");
        if (this.pageSize === "1000") {
            $(".sheet-edit-button").addClass("hide");
            return;
        }
        $(".sheet-edit-button").removeClass("hide");
        return;
    }
    getZone() {
        var _a;
        const zone = localStorage.getItem("selectedZone");
        if (zone === null || zone === "-1") {
            return {
                id: "-1",
                name: "All Zones",
            };
        }
        const zoneListDDL = document.getElementById("ddlZones");
        const zoneName = ((_a = zoneListDDL.options.find((z) => {
            return zone === z.value;
        })) === null || _a === void 0 ? void 0 : _a.label) || "All Zones";
        return {
            id: zone,
            name: zoneName
        };
    }
    getMiners(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const zone = this.getZone();
            this.loadHashingInventory(siteId, parseInt(zone.id));
            return this.get(`${this.minersUrl}?siteId=${siteId}&zoneId=${zone.id}&zoneName=${zone.name}`)
                .then((resp) => {
                resp.miners.filter(miner => miner.ipAddress == null).forEach(miner => miner.ipAddress = "Lease Expired");
                this.miners = resp.miners;
                this.minerFilters.miners = resp.miners;
                this.applyMinerFilters();
                this.setErrorCount();
                this.handleMinerSelection();
                this.gridLoaded = true;
                this.handleNoMiners();
            });
        });
    }
    applyMinerFilters() {
        if (!this.gridLoaded) {
            // filter by miner status
            const statuses = this.getQueryStringValues("status");
            statuses.forEach(status => this.minerFilters.statusNameFilter.setFilter(status));
        }
        this.minerFilters.applyFilters();
    }
    setErrorCount() {
        const errorCount = this.miners.filter((miner) => {
            return !!miner.errors;
        }).length;
        $("#errorsCount").text(errorCount);
    }
    bulkSearchMiners() {
        this.toggleDropdownMenu("minerListActionsDropdown");
        this.bulkSearch.open();
    }
    filterMiners() {
        this.minerFilters.applyFilters();
    }
    filterMinersFromNotesFilter() {
        this.minerFilters.applyFilters();
    }
    clearNotesSearch(sender) {
        $(sender).parent().remove();
        this.notesSearchPanel.clear();
        this.minerFilters.applyFilters();
    }
    clearBulkSearch(sender) {
        $(sender).parent().remove();
        this.bulkSearch.clear();
        this.minerFilters.applyFilters();
    }
    populateMinerGrid(filteredMiners) {
        const bulkSearchMiners = this.bulkSearch.bulkSearchMiners(filteredMiners);
        const allFilteredMiners = this.notesSearchPanel.searchMiners(bulkSearchMiners);
        this.populateSearchPanelItems();
        const grid = $("#minerGrid").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: allFilteredMiners,
            pageSize: 100,
            schema: {
                model: {
                    id: "id"
                }
            }
        });
        grid.setDataSource(dataSource);
        grid._selectedIds = {}; // clears selection on all pages
        grid.clearSelection();
    }
    populateSearchPanelItems() {
        $(".search-panel-items").children().remove();
        if (this.bulkSearch.isSearching) {
            const searchCount = this.bulkSearch.getSearchItems().length;
            const template = MinerAdminSearchFields.BULK_SEARCH_PANEL_ITEM;
            const searchItem = self.Mustache.to_html(template, { value: `${searchCount} item(s)` });
            $(".search-panel-items").append(searchItem);
        }
        if (this.notesSearchPanel.isSearching) {
            const searchCount = this.notesSearchPanel.selectedMiners.length;
            const template = MinerAdminSearchFields.NOTES_SEARCH_PANEL_ITEM;
            const searchItem = self.Mustache.to_html(template, { value: `${searchCount} item(s)` });
            $(".search-panel-items").append(searchItem);
        }
    }
    assignMinersToOwner() {
        // open modal and pass in
        const modalInitData = { selectedMinerIds: MinerAdmin.SELECTED_MINER_IDS };
        this.assignMinersModal.open(modalInitData);
    }
    sheetEdit() {
        this.toggleDropdownMenu("minerListActionsDropdown");
        const miners = this.miners.filter((miner) => {
            return MinerAdmin.SELECTED_MINER_IDS.indexOf(miner.id.toString()) > -1;
        });
        this.sheetEditor.open(miners);
    }
    bulkEdit() {
        this.toggleDropdownMenu("minerListActionsDropdown");
        this.editPanel.open();
    }
    openDeleteModal() {
        const numMiners = this.getTargetMinerIds().length;
        const initData = OpConfirmationModal.getDeleteModalInitData(numMiners);
        this.deleteMinersModal.open(initData);
    }
    bulkDelete() {
        this.toggleDropdownMenu("minerListActionsDropdown");
        this.post(this.deleteUrl, { minerIds: this.getTargetMinerIds() })
            .then((resp) => __awaiter(this, void 0, void 0, function* () {
            if (!resp.success) {
                this.showErrorMessage("Something went wrong deleting the selected miners.");
                return;
            }
            this.showSuccessMessage("Miners deleted!");
            const siteId = yield this.siteCache.getSiteId();
            this.getMiners(parseInt(siteId));
            this.deleteMinersModal.close();
        }));
    }
    openRebootModal(contextMenuMinerId) {
        let initData = MinerAdmin.SELECTED_MINER_IDS.map(id => parseInt(id));
        if (contextMenuMinerId && !isNaN(contextMenuMinerId)) {
            initData = [contextMenuMinerId];
        }
        this.rebootMinersModal.open(initData);
    }
    handleRebootResponse(resp) {
        this.rebootMinersModal.close();
        if (!resp.success) {
            this.showErrorMessage("Something went wrong sending the request to reboot the selected miners.");
            return;
        }
        this.showSuccessMessage("Miner reboot command sent!");
        this.siteCache.getSiteId().then(siteId => {
            this.getMiners(parseInt(siteId));
            this.rebootMinersModal.close();
        });
    }
    updateMinerLocation(minerId, locationId) {
        const saveData = {
            miners: [minerId],
            values: [["location", locationId]],
        };
        this.post(this.updateMinersUrl, saveData).then(() => {
            this.refresh();
        });
    }
    openPoolConfigModal() {
        // if only one selected we want to show the configs
        const targetMinerIds = this.getTargetMinerIds();
        if (targetMinerIds.length == 1) {
            const minerId = targetMinerIds[0];
            this.poolConfigModal.open(this.miners.find(m => m.id == parseInt(minerId)));
        }
        else {
            this.poolConfigModal.open(MinerAdmin.SELECTED_MINER_IDS);
        }
    }
    getTargetMinerIds() {
        return MinerAdmin.INDIVIDUAL_MINER_SELECTION ?
            [MinerAdmin.INDIVIDUAL_MINER_SELECTION]
            :
                MinerAdmin.SELECTED_MINER_IDS;
    }
    saveSheetEditMiners() {
        this.sheetEditor.save();
    }
    export() {
        if (this.getTargetMinerIds().length == 0) {
            $("#minerGrid").data("kendoGrid").saveAsExcel();
            return;
        }
        var rows = [{
                cells: []
            }];
        $("#minerGrid").data("kendoGrid").columns.forEach((column) => {
            if (column["title"])
                rows[0].cells.push({ value: column["title"], background: "#808080", color: "#FFFFFF" });
        });
        var grid = $("#minerGrid").data("kendoGrid");
        var trs = $("#minerGrid").find('tr');
        for (var i = 0; i < trs.length; i++) {
            if ($(trs[i]).find(":checkbox").is(":checked")) {
                var dataItem = grid.dataItem(trs[i]);
                rows.push({
                    cells: [
                        { value: dataItem.get("serialNumber") },
                        { value: dataItem.get("modelName") },
                        { value: dataItem.get("ipAddress") },
                        { value: dataItem.get("locationName") },
                        { value: dataItem.get("statusName") },
                        { value: dataItem.get("minerName") },
                        { value: dataItem.get("hashRatePercent") },
                        { value: dataItem.get("hashrate") },
                        { value: dataItem.get("temperature") },
                        { value: dataItem.get("fans") },
                        { value: dataItem.get("powerModeName") },
                        { value: dataItem.get("watts") },
                        { value: dataItem.get("uptime") },
                        { value: dataItem.get("errors") },
                        { value: dataItem.get("combinedErrors") },
                        { value: dataItem.get("siteName") },
                        { value: dataItem.get("zoneName") },
                        { value: dataItem.get("macAddress") },
                        { value: dataItem.get("firmwareVersion") },
                        { value: dataItem.get("pool1") },
                        { value: dataItem.get("account1") },
                        { value: dataItem.get("worker1") },
                        { value: dataItem.get("pool2") },
                        { value: dataItem.get("account2") },
                        { value: dataItem.get("worker2") },
                        { value: dataItem.get("pool3") },
                        { value: dataItem.get("account3") },
                        { value: dataItem.get("worker3") },
                        { value: dataItem.get("autoPool") },
                        { value: dataItem.get("subcustomerName") },
                        { value: dataItem.get("slotNote") },
                        { value: dataItem.get("onlineDate") },
                    ]
                });
            }
        }
        this.excelExport(rows);
    }
    excelExport(rows) {
        var columns = [];
        rows[0].cells.forEach(() => {
            columns.push({ autoWidth: true });
        });
        var workbook = new kendo.ooxml.Workbook({
            sheets: [
                {
                    columns: columns,
                    title: "Miners",
                    rows: rows
                }
            ]
        });
        kendo.saveAs({ dataURI: workbook.toDataURL(), fileName: "Export.xlsx" });
    }
    openBulkMinerMappingModal() {
        this.siteCache.getSiteId().then(siteId => {
            this.bulkMinerMapModal.open(parseInt(siteId));
        });
    }
    openBulkMinerRenameModal() {
        const numMiners = MinerAdmin.SELECTED_MINER_IDS.length > 0 ? MinerAdmin.SELECTED_MINER_IDS.length : this.miners.length;
        this.siteCache.getSiteId().then(siteId => {
            this.bulkMinerRenameModal.open({ siteId: parseInt(siteId), numMiners, minerIds: MinerAdmin.SELECTED_MINER_IDS });
        });
    }
    openBulkEditTagsModal(action) {
        this.siteCache.getSiteId().then(siteId => {
            this.bulkEditTagsModal.open({ siteId: parseInt(siteId), minerIds: MinerAdmin.SELECTED_MINER_IDS, action });
        });
    }
    handleNoMiners() {
        let link = $("#installAgentLink");
        if (!link)
            return;
        link.off('click');
        link.on('click', () => __awaiter(this, void 0, void 0, function* () { return OptiFleetMaster.goTo(`/Administration/SiteDetails.aspx?siteId=${yield this.siteCache.getSiteId()}&tab=Agents`); }));
    }
    NO_MINERS_HTML() {
        return `
            <div id="noMinersMsg" class="no-miners-msg m-stack is-horizontal m-gap-m">
                <m-icon name="empty" size="xl" class="no-miners-icon"></m-icon>
                <span class="m-text is-tertiary is-size-l">
                    <p>There are no miners discovered yet...</p>
                    <a id="installAgentLink" class="install-agent-link">Install your agent to get started</a>
                </span>
            </div>
            `;
    }
}
MinerAdmin.SELECTED_MINER_IDS = [];
MinerAdmin.INDIVIDUAL_MINER_SELECTION = undefined;

class MinerFilters extends OptiFleetPage {
    constructor(minerAdmin) {
        super();
        this.minerAdmin = minerAdmin;
        this.storedFiltersSelector = "minerAdminSelectedFilters";
        this.miners = [];
        this.minerNameFilter;
        this.modelNameFilter;
        this.serialNumberFilter;
        this.siteNameFilter;
        this.locationIdFilter;
        this.ipAddressFilter;
        this.statusNameFilter;
        this.customerFilter;
        this.connectivityFilter;
        this.slotNoteFilter;
        this.macAddressFilter;
        this.firmwareFilter;
        this.autoPoolFilter;
        this.errorCodeFilter;
        this.tagFilter;
        // show means the filter is visible in the filter section
        this.filters = [
            { label: "Miner Name", id: "minerName", show: true, options: [] },
            { label: "Model", id: "modelName", show: false, options: [] },
            { label: "Serial Number", id: "serialNumber", show: false, options: [] },
            { label: "Slot ID", id: "locationName", show: false, options: [] },
            { label: "IP Address", id: "ipAddress", show: false, options: [] },
            {
                label: "Status",
                id: "statusName",
                show: true,
                options: [],
                externalUrl: "/Statuses",
            },
            { label: "Customer", id: "subcustomerName", show: false, options: [] },
            { label: "Error", id: "combinedErrors", show: false, options: [] },
            { label: "Tags", id: "tags", show: false, options: [], externalUrl: "/Tags" },
            { label: "Pool 1", id: "pool1", show: false, options: [] },
            { label: "Account 1", id: "account1", show: false, options: [] },
            { label: "Worker 1", id: "worker1", show: false, options: [] },
            { label: "Pool 2", id: "pool2", show: false, options: [] },
            { label: "Account 2", id: "account2", show: false, options: [] },
            { label: "Worker 2", id: "worker2", show: false, options: [] },
            { label: "Pool 3", id: "pool3", show: false, options: [] },
            { label: "Account 3", id: "account3", show: false, options: [] },
            { label: "Worker 3", id: "worker3", show: false, options: [] },
            { label: "Slot Note", id: "slotNote", show: false, options: [] },
            { label: "MAC Address", id: "macAddress", show: false, options: [] },
            { label: "Firmware", id: "firmwareVersion", show: false, options: [] },
            {
                label: "AutoPool",
                id: "autoPool",
                show: false,
                options: [
                    { label: "On", id: "on" },
                    { label: "Off", id: "off" },
                ]
            },
        ];
        this.activeFilters = {
            minerName: "",
            modelName: "",
            serialNumber: "",
            siteName: "",
            locationId: "",
            ipAddress: "",
            statusName: "",
            autoPool: "",
            customer: "",
        };
        this.init();
    }
    // isRefresh is used when new data needs to be fetched for one
    // of the filters (ie tags)
    init(isRefresh) {
        this.initFilters();
        let opFilters = [];
        this.filters.forEach(filter => {
            const filterName = `${filter.id}Filter`;
            this[filterName] = new OpFilter(filter.id, this.filterMiners.bind(this), this.clearFilter.bind(this), filter.options, filter.externalUrl, isRefresh);
            const filterItem = this[filterName];
            opFilters.push(filterItem);
            if (!filter.show) {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
            if (filter.externalUrl && filter.label == "Status") {
                this.getDataForStatusFilter(filterItem);
            }
            else if (filter.externalUrl && filter.label == "Tags") {
                this.getDataForTagsFilter(filterItem);
            }
        });
        new SelectFilters("moreFilters", this.filters, this.changeActiveFilters.bind(this));
        new ClearFilters("clearFilters", opFilters);
    }
    refresh() {
        this.init(true);
    }
    getDataForStatusFilter(filter) {
        this.get(filter.externalUrl).then((data) => {
            filter.populateStatusResult(data.statuses, filter.id);
        });
    }
    getDataForTagsFilter(filter) {
        const siteId = this.getSelectedSiteId();
        this.get(`${filter.externalUrl}?siteId=${siteId}`).then((data) => {
            const uniqueTags = data.tags.filter((tag, index, self) => index === self.findIndex((t) => t.name === tag.name));
            filter.populateTagsResult(uniqueTags, filter.id);
        });
    }
    initFilters() {
        const storedFiltersStr = localStorage.getItem(this.storedFiltersSelector);
        let storedFilters;
        try {
            storedFilters = JSON.parse(storedFiltersStr);
        }
        catch (e) {
            return;
        }
        if (!storedFilters) {
            return;
        }
        storedFilters.forEach(storedFilter => {
            // if is filter
            if (storedFilter.hasOwnProperty("id") && storedFilter.hasOwnProperty("label") && storedFilter.hasOwnProperty("show")) {
                var filter = this.filters.find((filter) => filter.id === storedFilter.id);
                if (filter) {
                    filter.show = storedFilter.show;
                }
            }
        });
    }
    filterMiners(formVal, propertyVal) {
        this.activeFilters[propertyVal] = formVal;
        let filteredMiners = this.miners;
        if (!filteredMiners) {
            return;
        }
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (!formVal || formVal === "" || formVal.length === 0) {
                return;
            }
            if (isTextInput) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (filter.id == "tags") {
                            const tags = property.split(",").map(t => t.toLowerCase().trim());
                            console.log({ tags });
                            if (tags.includes(option.label.toLowerCase())) {
                                isMatch = true;
                            }
                        }
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        this.minerAdmin.populateMinerGrid(filteredMiners);
    }
    applyFilters() {
        let filteredMiners = this.miners;
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (isTextInput) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (filter.id == "tags") {
                            const tags = property.split(",").map(t => t.toLowerCase().trim());
                            console.log({ tags });
                            if (tags.includes(option.label.toLowerCase())) {
                                isMatch = true;
                            }
                        }
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        this.minerAdmin.populateMinerGrid(filteredMiners);
    }
    clearFilter(id) {
        this.activeFilters[id] = "";
        this.filterMiners(id, "");
    }
    changeActiveFilters(newFilters) {
        this.filters = newFilters;
        this.filters.forEach(filter => {
            let filterRemoved = false;
            // If the filter is active and it's being remove
            if ($(`[c-id=${filter.id}]`).hasClass("active") && filter.show === false) {
                // Then clear the active state and remove the filting on the miner grid
                this[`${filter.id}Filter`].deactivateFilter();
                this.activeFilters[filter.id] = "";
                filterRemoved = true;
            }
            if (filter.show) {
                $(`[c-id=${filter.id}]`).removeClass("hide");
            }
            else {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
            if (filterRemoved) {
                this.filterMiners("", "");
            }
        });
        localStorage.setItem(this.storedFiltersSelector, JSON.stringify(this.filters));
    }
}

class MinerAdminBulkEdit extends OptiFleetPage {
    constructor() {
        super();
        this.bulkSaveUrl = "/BulkUpdateMiners";
        this.editProperties = new MinerBulkEditProperties();
        this.init();
    }
    init() {
        $("#bulkEditOptions").kendoMultiSelect({
            dataSource: {
                data: this.editProperties.properties.map((val) => val.name),
            },
            change: this.onBulkEditOptionsChanged.bind(this),
            placeholder: "Select columns to edit",
        });
    }
    onBulkEditOptionsChanged(e) {
        const bulkOptions = $("#bulkEditOptions").data("kendoMultiSelect");
        const values = bulkOptions.value();
        this.cleanupRemovedControls(values);
        this.buildOutBulkEditProperties(values);
    }
    cleanupRemovedControls(values) {
        const properties = this.editProperties.properties.filter((property) => {
            if (property.control) {
                return property;
            }
        });
        properties.forEach((property) => {
            if (values.indexOf(property.name) == -1) {
                $(property.controlContainer).remove();
                property.control = null;
            }
        });
    }
    buildOutBulkEditProperties(values) {
        const container = $(".bulk-edit-properties").get(0);
        values.forEach((item) => {
            this.editProperties.getPropertyControl(item, container);
        });
        const controls = this.editProperties.properties.filter((property) => {
            return property.control;
        });
        if (controls.length === 0) {
            $(".bulk-edit-save-wrapper").removeClass("active");
            return;
        }
        $(".bulk-edit-save-wrapper").addClass("active");
    }
    close() {
        $(".bulk-edit-panel").removeClass("active");
    }
    open() {
        this.reset();
        $(".bulk-edit-panel").addClass("active");
    }
    reset() {
        $(".bulk-edit-properties").children().remove();
        $(".bulk-edit-save-wrapper").removeClass("active");
        const multiselect = $("#bulkEditOptions").data("kendoMultiSelect");
        multiselect.value([]);
    }
    save() {
        const properties = this.editProperties.properties.filter((property) => {
            if (property.control) {
                return property;
            }
        });
        let hasValidationErrors = false;
        const values = [];
        properties.forEach((property) => {
            var _a;
            $(property.controlContainer).find(".required-error").removeClass("active");
            const value = this.editProperties.getPropertyValue(property);
            if (!value && property.required) {
                hasValidationErrors = true;
                $(property.controlContainer).find(".m-input").addClass("is-error");
                (_a = $(property.controlContainer).find(".required-error")) === null || _a === void 0 ? void 0 : _a.addClass("active");
            }
            if (property.field == "location" && String(value).toLowerCase() !== "unassigned") {
                hasValidationErrors = true;
                $(property.controlContainer).find(".m-input").addClass("is-error");
                $(property.controlContainer).find(".m-help-text").addClass("is-error");
            }
            values.push([property.field, value]);
        });
        if (!hasValidationErrors) {
            properties.forEach((property) => {
                $(property.controlContainer).find(".m-input").removeClass("is-error");
                $(property.controlContainer).find(".m-help-text").removeClass("is-error");
            });
            this.toggleBusy(true);
            const saveData = {
                miners: MinerAdmin.SELECTED_MINER_IDS,
                values: values
            };
            this.post(this.bulkSaveUrl, saveData)
                .then((resp) => {
                if (!resp.success) {
                    this.showErrorMessage("Failed to update miners!");
                    this.toggleBusy(false);
                    return;
                }
                this.close();
                this.showSuccessMessage("Miners Saved!");
                this.onBulkEditSaved();
                this.toggleBusy(false);
            });
        }
    }
}

class MinerBulkEditProperties extends OptiFleetPage {
    constructor() {
        super(...arguments);
        this.sourceUrl = "/MinerPropertyList";
        this.properties = [
            {
                name: "Status",
                field: "statusName",
                type: "dropdown",
                required: true
            },
            {
                name: "Location",
                field: "location",
                type: "string",
                required: false,
                message: "Enter \"Unassigned\" (no quotes) to clear the Location"
            },
            {
                name: "Comment",
                field: "comment",
                type: "string",
                required: false
            }
        ];
    }
    getPropertyControl(field, container) {
        const property = this.properties.filter((val) => {
            return val.name === field;
        })[0];
        if (!property) {
            return;
        }
        if ($(container).find(`#${property.field}`).get(0)) {
            return;
        }
        const controlContainer = this.getControlContainer(container, property);
        this.applyControlForProperty(property, controlContainer);
        if (property.message) {
            this.appendMessageToPropertyControl(controlContainer, property);
        }
    }
    getControlContainer(container, property) {
        const wrapper = document.createElement("div");
        wrapper.className = "m-form-control";
        const label = document.createElement("div");
        label.className = "m-label";
        label.innerText = property.name;
        wrapper.appendChild(label);
        const requiredError = document.createElement("span");
        requiredError.className = "required-error";
        requiredError.innerText = "This value is required";
        label.append(requiredError);
        container.append(wrapper);
        property.controlContainer = wrapper;
        return wrapper;
    }
    appendMessageToPropertyControl(container, property) {
        const msgContainer = document.createElement("div");
        msgContainer.className = "m-help-text";
        msgContainer.innerText = property.message;
        container.append(msgContainer);
    }
    applyControlForProperty(property, container) {
        switch (property.type) {
            case "dropdown":
                this.getDropDownControl(property, container);
                break;
            case "string":
                this.getTextInputControl(property, container);
                break;
            case "number":
                this.getNumericInputControl(property, container);
                break;
            case "date":
                this.getDateControl(property, container);
                break;
        }
    }
    getDropDownControl(property, container) {
        const input = document.createElement("input");
        input.id = property.field;
        input.style.width = "100%";
        container.append(input);
        const control = $(input).kendoDropDownList({
            dataTextField: "text",
            dataValueField: "value",
            height: 200
        });
        property.control = control;
        this.get(`${this.sourceUrl}?type=${property.name}`)
            .then((data) => {
            const dropdown = $(input).data("kendoDropDownList");
            var dataSource = new self.kendo.data.DataSource({
                data: data.list
            });
            dropdown.setDataSource(dataSource);
        });
    }
    getTextInputControl(property, container) {
        const input = document.createElement("input");
        input.className = "m-input";
        input.id = property.field;
        container.append(input);
        property.control = input;
    }
    getNumericInputControl(property, container) {
        const input = document.createElement("input");
        input.id = property.field;
        container.append(input);
        const control = $(input).kendoNumericTextBox({
            format: property.format || "n",
            decimals: property.decimals || 0,
            round: false
        });
        property.control = control;
    }
    getDateControl(property, container) {
        const input = document.createElement("input");
        input.style.width = "100%";
        input.id = property.field;
        container.append(input);
        const control = $(input).kendoDatePicker();
        property.control = control;
    }
    getPropertyValue(property) {
        switch (property.type) {
            case "dropdown":
                const dropdown = $(property.control).data("kendoDropDownList");
                return dropdown.value();
            case "string":
                return property.control.value;
            case "number":
                const numeric = $(property.control).data("kendoNumericTextBox");
                return numeric.value();
            case "date":
                const datepicker = $(property.control).data("kendoDatePicker");
                return datepicker.value();
        }
    }
}

class MinerBulkSearch {
    constructor() {
        this.isSearching = false;
    }
    open() {
        $("#bulkSearch").val("");
        $(".bulk-search-panel").addClass("active");
    }
    cancel() {
        $(".bulk-search-panel").removeClass("active");
    }
    clear() {
        $("#bulkSearch").val("");
    }
    search() {
        this.onMinersFiltered();
        const searchItems = this.getSearchItems();
        if (searchItems.length === 0 || (searchItems.length === 1 && searchItems[0].trim() === "")) {
            this.cancel();
            return;
        }
    }
    getSearchItems() {
        const searchVal = $("#bulkSearch").val();
        return searchVal.split("\n").filter((val) => {
            return val.trim() !== "";
        }).map((item) => {
            return item.toLowerCase().trim();
        });
    }
    bulkSearchMiners(miners) {
        const searchVal = $("#bulkSearch").val();
        const searchItems = searchVal.split("\n").filter((val) => {
            return val !== "";
        }).map((item) => {
            return item.toLowerCase().trim();
        });
        if (searchItems.length === 0 || (searchItems.length === 1 && searchItems[0].trim() === "")) {
            this.isSearching = false;
            return miners;
        }
        this.isSearching = true;
        return this.filterMiners(miners, searchItems);
    }
    filterMiners(miners, searchItems) {
        const filteredMiners = miners.filter((miner) => {
            var _a, _b;
            return searchItems.indexOf(miner.ipAddress) > -1
                || searchItems.indexOf((_a = miner.minerName) === null || _a === void 0 ? void 0 : _a.toLowerCase()) > -1
                || searchItems.indexOf((_b = miner.serialNumber) === null || _b === void 0 ? void 0 : _b.toLowerCase()) > -1;
        });
        this.cancel();
        return filteredMiners;
    }
}

class MinerGridColumnTemplates {
    constructor() {
        //noop
    }
    static getErrorTemplate(miner) {
        if (!miner || !miner.errors) {
            return "---";
        }
        return `<span class="metric-text">${miner.errors}</span>`;
    }
    static getEfficiencyTemplate(miner) {
        if (!miner || !miner.hashRatePercent) {
            return "---";
        }
        const hashrate = `${Math.round(miner.hashRatePercent * 100)}%`;
        return `<span class="metric-text">${hashrate}</span>`;
    }
    static getHashrateTemplate(miner) {
        if (!miner || !miner.formattedHashrate) {
            return "---";
        }
        return `<span class="metric-text">${miner.formattedHashrate}</span>`;
    }
    static getTemperatureTemplate(miner) {
        if (!miner || !miner.temperature) {
            return "---";
        }
        return `<span class="metric-text">${Math.round(miner.temperature)}&deg;C</span>`;
    }
    static getChipTempListTemplate(miner) {
        if (!miner || !miner.chipTempList) {
            return "---";
        }
        return `<span class="metric-text">${miner.chipTempList}</span>`;
    }
    static getFanSpeedTemplate(miner) {
        if (!miner || !miner.fans) {
            return "---";
        }
        return `<span class="metric-text">${miner.fans}</span>`;
    }
    static getPowerTemplate(miner) {
        if (!miner || !miner.watts) {
            return "---";
        }
        return `<span class="metric-text">${Math.round(miner.watts)}W</span>`;
    }
    static getUptimeTemplate(miner) {
        if (!miner || !miner.uptime) {
            return "---";
        }
        return `<span class="metric-text">${miner.uptime}</span>`;
    }
    static getIpAddressColumnTemplate(miner) {
        if (miner.ipAddress == "Lease Expired") {
            return miner.ipAddress;
        }
        if (miner.username && miner.passwd) {
            return `<a class=\"m-link is-size-s\" href=\"http://${miner.username}:${miner.passwd}@${miner.ipAddress}\" target=\"_blank\">${miner.ipAddress}</a>`;
        }
        return `<a class=\"m-link is-size-s\" href=\"http://${miner.ipAddress}\" target=\"_blank\">${miner.ipAddress}</a>`;
    }
    static getSerialNumberTemplate(miner) {
        if (!miner.isDiscoveredSerialNumber) {
            return miner.serialNumber;
        }
        return `<div title="This serial number was pulled from this miners API.  Edit this miner to update the serial number.">${miner.serialNumber}</div>`;
    }
    static getElipsisTemplate() {
        return `<div class="menu-wrapper" data-miner-id="#=id#">
                <m-icon size="xl" name="more-vertical"></m-icon>
            </div>`;
    }
    static getOnlineDateTemplate(miner) {
        if (!miner || !miner.onlineDate) {
            return "---";
        }
        return window.moment.utc(miner.onlineDate).local().format("M/D/YYYY");
    }
}

class MinerNotesSearchPanel extends OptiFleetPage {
    constructor() {
        super();
        this.searchNotesUrl = "/SearchMinerNotes?Search=";
        this.selectedMiners = [];
        this.isSearching = false;
        this.init();
    }
    init() {
        $("#searchNotesGrid").kendoGrid({
            dataSource: {
                data: []
            },
            height: "100%",
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            change: this.handleMinerSelection.bind(this),
            noRecords: {
                template: `<div class="no-records">No Results. Enter a search term to find notes.</div>`
            },
            columns: [
                { selectable: true, width: "60px" },
                { field: "minerName", title: "Miner", width: "200px" },
                { field: "note", title: "Note", }
            ]
        });
    }
    handleMinerSelection() {
        const grid = $("#searchNotesGrid").data("kendoGrid");
        this.selectedMiners = grid.selectedKeyNames();
        if (this.selectedMiners.length === 0) {
            $("#btnFilterMiners").attr("disabled", "disabled");
            return;
        }
        $("#btnFilterMiners").removeAttr("disabled");
    }
    open() {
        $(".notes-search-panel").addClass("active");
    }
    close() {
        $(".notes-search-panel").removeClass("active");
    }
    clear() {
        $("#notesSearch").val("");
        this.selectedMiners = [];
        this.populateNotes([]);
    }
    search() {
        const searchTerm = $("#notesSearch").val().trim();
        if (searchTerm.length === 0) {
            return;
        }
        this.toggleBusy(true);
        this.get(this.searchNotesUrl + searchTerm)
            .then((resp) => {
            this.populateNotes(resp.notes);
            this.toggleBusy(false);
        });
    }
    populateNotes(notes) {
        const grid = $("#searchNotesGrid").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: notes,
            schema: {
                model: {
                    id: "minerName",
                }
            }
        });
        grid.setDataSource(dataSource);
    }
    filterMiners() {
        this.onMinersFiltered(this.selectedMiners);
        this.close();
    }
    searchMiners(miners) {
        if (this.selectedMiners.length === 0) {
            this.isSearching = false;
            return miners;
        }
        this.isSearching = true;
        return this.filterSelectedMiners(miners);
    }
    filterSelectedMiners(miners) {
        const filteredMiners = miners.filter((miner) => {
            return this.selectedMiners.indexOf(miner.minerName) > -1;
        });
        return filteredMiners;
    }
}

class MinerAdminSheetEdit extends OptiFleetPage {
    constructor() {
        super();
        this.sheedEditUrl = "/MinerBulkSheetEdit";
        this.header_row = [{
                height: 25,
                cells: [
                    {
                        value: "ID", background: "rgb(167,214,255)", textAlign: "center", color: "rgb(0,62,117)", enable: false
                    },
                    {
                        value: "Name*", background: "rgb(167,214,255)", textAlign: "center", color: "rgb(0,62,117)", enable: false
                    },
                    {
                        value: "Serial Number*", background: "rgb(167,214,255)", textAlign: "center", color: "rgb(0,62,117)", enable: false
                    },
                    {
                        value: "IP", background: "rgb(167,214,255)", textAlign: "center", color: "rgb(0,62,117)", enable: false
                    },
                    {
                        value: "Model", background: "rgb(167,214,255)", textAlign: "center", color: "rgb(0,62,117)", enable: false
                    },
                    {
                        value: "Location", background: "rgb(167,214,255)", textAlign: "center", color: "rgb(0,62,117)", enable: false
                    }
                ]
            }
        ];
    }
    open(miners) {
        $(".sheet-edit-panel").addClass("active");
        $("#editCompany").text(this.getSelectedCompanyName());
        if (!this.initialized) {
            this.initSheet();
            this.initialized = true;
        }
        this.reset();
        this.populateSheet(miners);
    }
    reset() {
        //todo
    }
    close() {
        $(".sheet-edit-panel").removeClass("active");
    }
    populateSheet(miners) {
        const sheet = $("#minerSheetEdit").data("kendoSpreadsheet");
        const headerRow = this.header_row;
        const rows = this.getRows(miners);
        const sheetRows = headerRow.concat(rows);
        sheet.fromJSON({
            sheetsbar: false,
            toolbar: false,
            rows: miners.length,
            sheets: [{
                    name: "Miners",
                    rows: sheetRows,
                    filter: {
                        ref: `A1:H${sheetRows.length}`,
                        columns: []
                    },
                    columns: [
                        {
                            width: 100
                        },
                        {
                            width: 200
                        },
                        {
                            width: 300
                        },
                        {
                            width: 200
                        },
                        {
                            width: 220
                        },
                        {
                            width: 130
                        },
                        {
                            width: 200
                        },
                        {
                            width: 120
                        },
                    ]
                }]
        });
    }
    getRows(miners) {
        return miners.map((miner) => {
            return {
                height: 25,
                cells: [
                    { value: miner.id, textAlign: "center", enable: false },
                    { value: miner.minerName || "" },
                    { value: miner.serialNumber || "" },
                    { value: miner.ipAddress || "", enable: false },
                    { value: miner.modelName || "", enable: false },
                    { value: miner.locationName || "" },
                ]
            };
        });
    }
    initSheet() {
        $("#minerSheetEdit").kendoSpreadsheet({
            sheetsbar: false,
            toolbar: false,
            rows: 1000
        });
    }
    save() {
        const spreadsheet = $("#minerSheetEdit").data("kendoSpreadsheet");
        const data = spreadsheet.toJSON();
        const saveData = data.sheets[0].rows.filter((row) => {
            return row.cells[0].value != "ID";
        }).map((row, index) => {
            return {
                id: this.getCellValue(row, 0),
                name: this.getCellValue(row, 1),
                serialNumber: this.getCellValue(row, 2),
                ip: this.getCellValue(row, 3),
                model: this.getCellValue(row, 4),
                location: this.getCellValue(row, 5),
                index: index + 2 // skip 0 and skip the header row
            };
        });
        this.toggleBusy(true);
        this.post(this.sheedEditUrl, { miners: saveData })
            .then((resp) => {
            this.toggleBusy(false);
            if (!resp.successful) {
                this.exportErrorsToUser(resp);
                this.showErrorMessage("There are too many errors to display.  Please check the errors csv.", 10);
                return;
            }
            this.showSuccessMessage(`${saveData.length} Miners updated.`);
            this.onMinersEdited();
            this.close();
        });
    }
    getErrorExportHeader() {
        const headers = [];
        const rangeHeader = document.createElement("td");
        rangeHeader.innerText = "Range";
        const errorHeader = document.createElement("td");
        errorHeader.innerText = "Error";
        headers.push(rangeHeader);
        headers.push(errorHeader);
        return headers;
    }
    exportErrorsToUser(resp) {
        const headers = this.getErrorExportHeader();
        const rows = [];
        resp.validationErrors.forEach((validationError) => {
            validationError.cellErrors.forEach((rangeError) => {
                const row = document.createElement("tr");
                const rangeCell = document.createElement("td");
                const errorCell = document.createElement("td");
                rangeCell.innerText = rangeError.range;
                errorCell.innerText = rangeError.message;
                row.appendChild(rangeCell);
                row.appendChild(errorCell);
                rows.push(row);
            });
        });
        ExcelUtility.exportToCSV(headers, rows, `SheetEditErrors_${Date.now()}`);
    }
    getCellValue(row, index) {
        const cell = row.cells.filter((cell) => {
            return cell.index === index;
        })[0];
        if (!cell) {
            return null;
        }
        return cell.value;
    }
}

class DataEvent {
    constructor() {
        this.listeners = [];
    }
    add(listener) {
        this.listeners.push(listener);
    }
    invoke(...args) {
        this.listeners.forEach((listener) => {
            listener(...args);
        });
    }
}
class SiteMapData {
    constructor(siteMap) {
        this.siteMap = siteMap;
        this.layout = [];
        this.currentDataType = "hashrate_rt";
        this.hashingInventory = null;
        this.selectedSlots = [];
        /* /PAGE GLOBAL STATE */
        // EVENTS
        this.onPageRefresh = new DataEvent();
        this.onPageLoad = new DataEvent();
        this.onDataTypeChange = new DataEvent();
        this.initData();
    }
    initData() {
        return __awaiter(this, void 0, void 0, function* () {
            const storedCurrentDataType = localStorage.getItem(SiteMapData.currentDataTypeStorageKey);
            if (storedCurrentDataType && !!STAT_LIST_OPTIONS.find((source) => source.value === storedCurrentDataType)) {
                this.currentDataType = storedCurrentDataType;
            }
            yield this.refreshLocations();
            this.currentZoneId = parseInt(this.siteMap.getQueryStringValue("zoneId"));
            const zoneIds = this.layout.map((z) => z.zoneId);
            const isCurrentZoneValid = zoneIds.indexOf(this.currentZoneId) !== -1;
            if (!isCurrentZoneValid) {
                let selectedZone = parseInt(localStorage.getItem("selectedZone"));
                if (zoneIds.includes(selectedZone)) {
                    this.currentZoneId = selectedZone;
                }
                else {
                    this.currentZoneId = zoneIds[0];
                }
            }
            this.updateLayout();
            this.onPageLoad.invoke(this.layout.find(zone => zone.zoneId == this.currentZoneId));
        });
    }
    refreshAll() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.refreshLocations();
            //await this.refreshSiteDetails();
            const zoneIds = this.layout.map((z) => z.zoneId);
            const isCurrentZoneValid = zoneIds.indexOf(this.currentZoneId) !== -1;
            if (!isCurrentZoneValid) {
                this.currentZoneId = zoneIds[0];
            }
            this.updateLayout();
            this.onPageRefresh.invoke(this.layout.find(zone => zone.zoneId == this.currentZoneId));
        });
    }
    refreshLocations() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.fetchSiteLayout(yield this.siteMap.siteCache.getSiteId());
        });
    }
    fetchSiteLayout(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.siteMap.get(`/Layout?siteId=${siteId}`);
            resp.zones.forEach(zone => {
                if (zone.invertedRows) {
                    zone.racks.forEach(rack => rack.rows.reverse());
                }
            });
            this.layout = resp.zones;
        });
    }
    fetchActiveLocations() {
        return this.siteMap.get(`/MinerPropertyList?type=AvailableCompanyLocation`);
    }
    fetchHashingInventory(siteId, zoneId) {
        return this.siteMap.get(`/HashingInventory?siteId=${siteId}&zoneId=${zoneId}`);
    }
    fetchMiners(siteId) {
        return this.siteMap.get(`/Miners?siteId=${siteId}&excludeAssigned=true`);
    }
    updateLayout() {
        let zoneIndex = this.layout.findIndex(zone => Number(zone.zoneId) === this.currentZoneId);
        if (zoneIndex < 0)
            return;
        this.layout[zoneIndex].racks.forEach(rack => {
            rack.rows.forEach(row => {
                row.slotData.forEach(slot => {
                    slot.pending = false; // TODO
                    slot.errorCodes = slot.minerErrors.map(e => e.code);
                });
            });
        });
    }
}
SiteMapData.currentDataTypeStorageKey = "SiteMapData_currentDataType";

const STAT_LIST_OPTIONS = [
    {
        label: "Real Time Hash Rate",
        value: "hashrate_rt",
    },
    {
        label: "Average Hash Rate",
        value: "hashrateAgg_30m",
    },
    {
        label: "Avg Hashboard Temp",
        value: "hashboard_temp_avg",
    },
    {
        label: "Max Hashboard Temp",
        value: "hashboard_temp_max",
    },
    {
        label: "Avg Chip Temp",
        value: "chip_temp_avg",
    },
    {
        label: "Max Chip Temp",
        value: "chip_temp_max",
    },
];
class SiteMapFilters {
    get siteMapData() {
        return this.siteMap.siteMapData;
    }
    get siteMapRacks() {
        return this.siteMap.siteMapRacks;
    }
    get siteMapStats() {
        return this.siteMap.siteMapStats;
    }
    constructor(siteMap) {
        this.siteMap = siteMap;
        this.zoneListFilter = document.getElementById("zoneList");
        this.statListFilter = document.getElementById("statList");
        console.log("this.siteMapData", this.siteMapData);
        this.siteMapData.onPageLoad.add(this.onPageLoad.bind(this));
        this.siteMapData.onPageRefresh.add(this.onPageRefresh.bind(this));
    }
    onPageLoad() {
        $(document).on("siteFilterChanged", (siteId) => {
            this.siteMap.refreshButton.refresh();
        });
        this.setZonesList(this.siteMapData.layout);
        this.zoneListFilter.addEventListener("on-change", (e) => __awaiter(this, void 0, void 0, function* () {
            let zoneId = e.detail.value;
            this.siteMapData.currentZoneId = parseInt(zoneId);
            localStorage.setItem("selectedZone", zoneId);
            yield this.siteMap.refreshButton.refresh();
        }));
        this.statListFilter.options = STAT_LIST_OPTIONS;
        this.statListFilter.addEventListener("on-change", (e) => {
            const dataType = e.detail.value;
            localStorage.setItem(SiteMapData.currentDataTypeStorageKey, dataType);
            this.siteMapData.currentDataType = dataType;
            this.siteMapData.onDataTypeChange.invoke(dataType);
            const zone = this.siteMapData.layout.find(x => x.zoneId === this.siteMapData.currentZoneId);
            this.siteMapRacks.onPageRefresh(zone);
            this.siteMapStats.onPageRefresh(zone);
        });
    }
    onPageRefresh() {
        this.setZonesList(this.siteMapData.layout);
    }
    setZonesList(zones) {
        this.zoneListFilter.options = this.siteMapData.layout.map((zone) => {
            return {
                label: zone.zoneName,
                value: zone.zoneId.toString(),
            };
        });
        const zoneId = this.siteMapData.currentZoneId;
        this.zoneListFilter.selected = typeof zoneId === "undefined" ? "" : zoneId.toString();
    }
}

class SiteMapLegend {
    get siteMapData() {
        return this.siteMap.siteMapData;
    }
    constructor(siteMap) {
        this.siteMap = siteMap;
        this.successKeyLabel = $("#successKeyLabel");
        this.warningKeyLabel = $("#warningKeyLabel");
        this.dangerKeyLabel = $("#dangerKeyLabel");
        this.updateLegend.call(this, "hashrate_rt");
        this.siteMapData.onDataTypeChange.add(this.updateLegend.bind(this));
    }
    updateLegend(dataType) {
        switchMap(dataType, {
            "hashrate_rt": this.updateLegendHashrate.bind(this),
            "hashrateAgg_30m": this.updateLegendHashrate.bind(this),
            "hashboard_temp_avg": this.updateLegendTemperature.bind(this),
            "hashboard_temp_max": this.updateLegendTemperature.bind(this),
            "chip_temp_avg": this.updateLegendTemperature.bind(this),
            "chip_temp_max": this.updateLegendTemperature.bind(this),
        });
    }
    updateLegendHashrate() {
        this.successKeyLabel.text("â‰¥95%");
        this.warningKeyLabel.text("75-94%");
        this.dangerKeyLabel.text("â‰¤74%");
    }
    updateLegendTemperature() {
        this.successKeyLabel.text("<80Â°C");
        this.warningKeyLabel.text("80-89Â°C");
        this.dangerKeyLabel.text("â‰¥90Â°C");
    }
}

function switchMap(value, actionMap) {
    return actionMap[value]();
}
let siteMapInteractionMode = "SingleSelect";
class SiteMapMenus {
    get siteMapData() {
        return this.siteMap.siteMapData;
    }
    constructor(siteMap) {
        this.siteMap = siteMap;
        this.rebootMinersUrl = "/rebootMiners";
        this.updateMinersUrl = "/BulkUpdateMiners";
        this.reservedMinersUrl = "/ReservedLocations";
        this.locationsUrl = "/Locations";
        this.mustache = window.Mustache;
        // prevent context menu from closing on slot note click
        $(`li[action="ADD_SLOT_NOTE"]`).on("click", (e) => {
            e.stopPropagation();
            this.addSlotNote(this.siteMapData.selectedSlot);
        });
        this.minerEditor = new OpMinerEditorModal(this.siteMap, "MinerEditorModal");
        this.rebootModal = new OpRebootMinersModal(this.siteMap, "RebootMinersModal", this.handleRebootResponse.bind(this));
        this.logFetchModal = new LogFetchModal(this.siteMap, "LogFetchModal");
        this.unassignMinerModal = new UnAssignMinerModal(this.siteMap, "UnAssignMinerModal", this.updateMinerLocation.bind(this));
        this.init();
    }
    init() {
        $("#emptySlotMenu").kendoContextMenu({
            target: "#racks",
            filter: ".emptySlot",
            animation: {
                open: { effects: "fadeIn" },
            },
            open: this.onEmptyContextMenuOpen.bind(this),
            select: this.onContextMenuSelect.bind(this),
        });
        $("#minerSlotMenu").kendoContextMenu({
            target: "#racks",
            filter: ".minerSlot",
            animation: {
                open: { effects: "fadeIn" },
            },
            open: this.onMinerContextMenuOpen.bind(this),
            select: this.onContextMenuSelect.bind(this),
        });
        $("#reboot-dialog").kendoDialog({
            width: "450px",
            title: "Miner Reboot",
            closable: true,
            modal: true,
            visible: false,
            actions: [
                {
                    text: "Cancel"
                },
                {
                    text: "Reboot",
                    primary: true,
                    action: () => {
                        this.siteMap.showNullState("Rebooting");
                        const selectedMinerIds = $(".minerSlot.selected")
                            .get()
                            .map((elem) => $(elem).attr("minerId"));
                        const minerIds = selectedMinerIds.length > 0 ? selectedMinerIds : [this.siteMapData.selectedSlot.minerId];
                        this.rebootModal.open(minerIds.map(id => parseInt(id)));
                    }
                }
            ],
        });
        $("#location-dialog").kendoDialog({
            width: "450px",
            title: "Select a new location",
            closable: true,
            modal: true,
            visible: false,
            actions: [
                {
                    text: "Cancel"
                },
                {
                    text: "Update",
                    primary: true,
                    action: () => {
                        const locationDDL = $("#locationList").data("kendoDropDownList");
                        const minerId = this.siteMapData.selectedSlot.minerId;
                        if (!minerId) {
                            return;
                        }
                        this.updateMinerLocation(minerId.toString(), locationDDL.value());
                    }
                },
            ],
        });
        $("#miner-dialog").kendoDialog({
            width: "450px",
            title: "Select a miner",
            closable: true,
            modal: true,
            visible: false,
            actions: [
                {
                    text: "Cancel"
                },
                {
                    text: "Update",
                    primary: true,
                    action: () => {
                        const minerDDL = $("#minerList").data("kendoDropDownList");
                        const stdLocationId = this.siteMapData.selectedSlot.standardizedLocationId;
                        if (minerDDL.value() === "-1") {
                            return;
                        }
                        this.updateMinerLocation(minerDDL.value(), stdLocationId);
                    }
                },
            ],
        });
    }
    handleRebootResponse(resp) {
        this.rebootModal.close();
        this.siteMap.toggleBusy(false);
        this.siteMap.hideNullState();
        if (!resp.success) {
            this.siteMap.showErrorMessage("Something went wrong sending the request to reboot the selected miners.");
            return;
        }
        this.siteMap.showSuccessMessage("Miner reboot command sent!");
        //this.ui.disableMultiSelectMode(); <- TODO
    }
    onEmptyContextMenuOpen(e) {
        const slotData = this.siteMapData.selectedSlot;
        const titleText = slotData.reserved ? "Reserved Slot" : "Empty Slot";
        const emptySlotActionElem = $("#emptySlotAction").hide();
        const reserveSlotActionElem = $("#reserveSlotAction").hide();
        slotData.reserved
            ? emptySlotActionElem.show()
            : reserveSlotActionElem.show();
        const slotNote = slotData.note === null ? "Add a slot note ..." : slotData.note;
        $("#emptySlotNote").text(slotNote);
        $("#emptySlotMenuTitle").text(titleText);
    }
    onMinerContextMenuOpen(e) {
        const slotData = this.siteMapData.selectedSlot;
        const slotStatus = slotData.minerStatus;
        const slotNote = slotData.note === null ? "Add a slot note ..." : slotData.note;
        $("#slotMenuMinerName").text(slotData.minerName);
        $("#slotMenuIp").text((slotData === null || slotData === void 0 ? void 0 : slotData.ip) || "No Ip Found");
        $("#slotMenuStatus").text(slotStatus);
        $("#minerSlotNote").text(slotNote);
        this.setSlotErrorCode(slotData);
        this.minerEditor.preloadMiner(slotData.minerId);
    }
    setSlotErrorCode(slotData) {
        if (slotData.minerErrors.length > 0) {
            $("#slotMenuErrorCodeText").show();
            $("#slotMenuErrorCode").text(slotData.minerErrors.map(x => x.code).join("-"));
        }
        else {
            $("#slotMenuErrorCodeText").hide();
        }
    }
    onContextMenuSelect(e) {
        const slotData = this.siteMapData.selectedSlot;
        const item = $(e.item);
        const action = item.attr("action");
        if (typeof action === "undefined") {
            return;
        }
        slotData.minerId
            ? this.onMinerContextMenuSelect(action, slotData)
            : this.onEmptyContextMenuSelect(action, slotData);
    }
    onEmptyContextMenuSelect(action, data) {
        switchMap(action, {
            "ASSIGN_MINER": () => this.assignMiner(data),
            "RESERVE_SLOT": () => this.updateReservation(data, true),
            "EMPTY_SLOT": () => this.updateReservation(data, false),
        });
    }
    addSlotNote(data) {
        const elemId = !data.minerId ? "emptySlotNote" : "minerSlotNote";
        const elemClassName = "slot-menu-item m-text is-tertiary slot-note";
        const slotNote = $("#" + elemId);
        const isEditing = slotNote.hasClass(".k-state-focused");
        if (isEditing) {
            // ignore clicks in text area
            return;
        }
        let text = data.note === null ? "" : slotNote.text();
        slotNote.replaceWith($("<textarea>")
            .attr("id", elemId)
            .attr("placeholder", "Add a slot note ...")
            .addClass(elemClassName)
            .css("box-sizing", "border-box")
            .css("width", "100%")
            .val(text)
            .on("change", (e) => text = e.target.value)
            .on("blur", (e) => {
            // RESET TO DEFAULT
            $(e.target)
                .replaceWith($("<span>")
                .attr("id", elemId)
                .addClass(elemClassName));
            // no update required
            if (!data.note && !text) {
                return;
            }
            const postData = {
                minerLocationIds: [data.minerLocationId.toString()],
                note: text
            };
            this.siteMap.post(this.locationsUrl, postData)
                .then((resp) => {
                if (resp.success) {
                    this.siteMap.showSuccessMessage("Updated the location note");
                    data.note = text;
                }
                else {
                    this.siteMap.showErrorMessage("There was an issue saving note");
                }
                this.siteMap.refreshButton.refresh();
            });
        }));
        requestAnimationFrame(() => $("#" + elemId).focus());
    }
    assignMiner(data) {
        const dataPointDataSource = new kendo.data.DataSource({
            data: [
                {
                    label: "Ip Address",
                    id: 1,
                },
                {
                    label: "MAC Address",
                    id: 2,
                }
            ]
        });
        function initMinerDDL() {
            $("#minerList")
                .kendoDropDownList({
                autoBind: false,
                dataTextField: "label",
                dataValueField: "id",
                dataSource: new kendo.data.DataSource({
                    transport: {
                        read: (options) => __awaiter(this, void 0, void 0, function* () {
                            const siteId = yield this.siteMap.siteCache.getSiteId();
                            const resp = yield this.siteMapData.fetchMiners(siteId);
                            const isIp = $("#minerDataPoint").data("kendoDropDownList").value() === "1";
                            options.success(resp.miners.map((r) => {
                                return {
                                    id: r.id,
                                    label: isIp ? r.ipAddress : r.macAddress,
                                };
                            }).filter((r) => r.label));
                        }),
                    },
                    schema: {
                        data: (response) => response,
                    },
                }),
                filter: "contains",
                value: "-1",
            })
                .data("kendoDropDownList")
                .ul.width(300);
        }
        $("#miner-dialog")
            .data("kendoDialog")
            .content(this.mustache.to_html(SiteMapTemplatesNew.SELECT_MINER_MODAL, data))
            .open();
        const dataPointDDL = $("#minerDataPoint");
        dataPointDDL
            .kendoDropDownList({
            autoBind: false,
            dataTextField: "label",
            dataValueField: "id",
            dataSource: dataPointDataSource,
            value: "1",
            change: (e) => {
                initMinerDDL.call(this);
            }
        });
        dataPointDDL.data("kendoDropDownList").value("1");
        initMinerDDL.call(this);
    }
    onMinerContextMenuSelect(action, data) {
        switchMap(action, {
            "MINER_VIEW": () => this.minerView(data),
            "EDIT_MINER": () => this.editMiner(data),
            "MINER_COMMENTS": () => this.minerComments(data),
            "UNASSIGN_MINER": () => this.unassignMiner(data),
            "MINER_REBOOT": () => this.minerReboot([data]),
            "FETCH_LOGS": () => this.fetchLogs(data),
            "UPDATE_LOCATION": () => this.updateLocation(data),
            "SELECT_MULTIPLE": () => this.selectMultiple(data),
        });
    }
    minerComments(data) {
        const url = `Miners/IndividualMiner?id=${data.minerId}&active_tab=Comments`;
        OptiFleetMaster.openTab(url);
    }
    selectMultiple(data) {
        siteMapInteractionMode = "MultiSelect";
        this.siteMapData.selectedSlots.push(data);
        $(`td[ip="${data.ip}"]`).addClass("selected");
        const bulkActionsPanel = $("#bulkActionsPanel");
        bulkActionsPanel.show();
        $(`td[ip="undefined"]`).removeClass("selectable");
        $("#bulkActionsPanelRebootBtn").on("click", (e) => {
            this.minerReboot(this.siteMapData.selectedSlots);
        });
        $("#bulkActionsPanelCancelBtn").on("click", (e) => {
            bulkActionsPanel.hide();
            siteMapInteractionMode = "SingleSelect";
            // Reset selected slots
            this.siteMapData.selectedSlots = [];
            $(`td[ip="undefined"]`).addClass("selectable");
            $(`td.selected`).removeClass("selected");
        });
    }
    updateLocation(data) {
        $("#location-dialog")
            .data("kendoDialog")
            .content(this.mustache.to_html(SiteMapTemplates.UPDATE_LOCATION_MODAL, data))
            .open();
        const ds = new kendo.data.DataSource({
            transport: {
                read: (options) => __awaiter(this, void 0, void 0, function* () {
                    const activeLocations = yield this.siteMapData.fetchActiveLocations()
                        .then((resp) => {
                        const zoneNames = this.siteMapData.layout.map((z) => z.zoneName);
                        return resp.list.filter((property) => {
                            for (const zoneName of zoneNames) {
                                if (property.text.startsWith(zoneName + "-")) {
                                    return true;
                                }
                            }
                            return property.text === "Unassigned";
                        });
                    });
                    options.success(activeLocations);
                }),
            },
            schema: {
                data: (activeLocations) => activeLocations,
            },
        });
        $("#locationList")
            .kendoDropDownList({
            autoBind: false,
            dataTextField: "text",
            dataValueField: "text",
            dataSource: ds,
            filter: "contains",
            value: "Unassigned",
            text: "Unassigned",
        })
            .data("kendoDropDownList")
            .ul.width(300);
    }
    minerReboot(data) {
        const selectedIds = data.map((slot) => slot.minerId);
        this.rebootModal.open(selectedIds);
    }
    fetchLogs(data) {
        this.logFetchModal.open(data.minerId);
    }
    unassignMiner(data) {
        const initData = UnAssignMinerModal.getUnAssignMinerModalInitData(data.minerId.toString());
        this.unassignMinerModal.open(initData);
    }
    editMiner(data) {
        this.minerEditor.open();
    }
    minerView(data) {
        OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${data.minerId}`);
    }
    updateReservation(data, reserved) {
        const postData = {
            minerLocationIds: [data.minerLocationId.toString()],
            reserved: reserved,
        };
        this.siteMap.post(this.locationsUrl, postData).then((resp) => {
            this.siteMap.hideNullState();
            if (!resp.success) {
                this.siteMap.showErrorMessage("Something went wrong updating the reservation for the location.");
                return;
            }
            this.siteMap.showSuccessMessage("Location Reservation updated!");
            this.siteMap.refreshButton.refresh();
        });
    }
    updateMinerLocation(minerId, locationId) {
        this.siteMap.showNullState("Updating Location");
        this.siteMap.toggleBusy(true);
        const saveData = {
            miners: [minerId],
            values: [["location", locationId]],
        };
        this.siteMap.post(this.updateMinersUrl, saveData).then(() => {
            this.siteMap.showSuccessMessage("Location Updated!");
            this.siteMap.refreshButton.refresh();
        });
        this.siteMap.toggleBusy(false);
        this.siteMap.hideNullState();
    }
}

function derive(cb) {
    return cb();
}
function formatHashrate(value) {
    return Intl.NumberFormat("default", { style: "percent" }).format(value);
}
function formatTemperature(value) {
    return Math.ceil(value) + "Â°C";
}
class SiteMapRacks {
    get siteMapData() {
        return this.siteMap.siteMapData;
    }
    constructor(siteMap) {
        this.siteMap = siteMap;
        this.siteMapData.onPageLoad.add(this.onPageLoad.bind(this));
        this.siteMapData.onPageRefresh.add(this.onPageRefresh.bind(this));
    }
    onPageLoad(zoneLayout) {
        $("#zonesLoadingSpinner").hide();
        $("#racks").append(this.renderRacks(zoneLayout));
    }
    onPageRefresh(zoneLayout) {
        $("#racks").empty().append(this.renderRacks(zoneLayout));
    }
    toggleNoMapMessage(zoneLayout) {
        if (this.siteMapData.layout.length == 0 || !(zoneLayout === null || zoneLayout === void 0 ? void 0 : zoneLayout.racks) || zoneLayout.racks.length === 0) {
            $('#noMapMsg').css("display", "flex");
            return true;
        }
        else {
            $('#noMapMsg').hide();
            return false;
        }
    }
    renderRacks(zoneLayout) {
        if (this.toggleNoMapMessage(zoneLayout)) {
            return $();
        }
        const companyId = parseInt(localStorage.getItem("selectedCompany"));
        if (companyId == -1) {
            return $(`<div>`)
                .addClass(`has-space-m`)
                .text("Please select a company and site");
        }
        let racks = zoneLayout.racks.sort(alphaNumRackSortFn);
        return racks.map(rack => {
            let rows = rack.rows;
            const rackRows = rows.map(row => {
                const rackRowSlots = row.slotData.map(slot => {
                    this.updateSlotType(slot);
                    const slotType = slot.slotType;
                    const slotText = this.deriveSlotText(slot, slotType);
                    const hasNote = slot.note !== null;
                    const isSelected = this.siteMapData.selectedSlots.filter((s) => s.ip === slot.ip).length === 1;
                    const slotClassName = ClassNames.createClassName({
                        "m-table-cell selectable m-text is-size-xs": true,
                        "selected": isSelected,
                        "empty": slotType === "EMPTY",
                        "pending": slotType === "PENDING",
                        "reserve": slotType === "RESERVED",
                        "success": slotType === "EXPECTED",
                        "warning": slotType === "BAD",
                        "danger": slotType === "VERY BAD",
                        "error": slotType === "ERROR",
                        "not-hashing": slotType === "OFF",
                    });
                    const noteBadge = $("<span>")
                        .addClass("badge");
                    function handleSlotClick(e) {
                        const elem = $(e.target);
                        if (!elem.hasClass("selectable")) {
                            return;
                        }
                        switchMap(siteMapInteractionMode, {
                            "MultiSelect": () => {
                                if (this.siteMapData.selectedSlots.length === 15) {
                                    return;
                                }
                                this.siteMapData.selectedSlots.push(slot);
                                elem.hasClass("selected")
                                    ? elem.removeClass("selected")
                                    : elem.addClass("selected");
                            },
                            "SingleSelect": () => {
                                this.siteMapData.selectedSlot = slot;
                                slot.minerId
                                    ? $("#minerSlotMenu").data("kendoContextMenu").open(e.clientX, e.clientY)
                                    : $("#emptySlotMenu").data("kendoContextMenu").open(e.clientX, e.clientY);
                            }
                        });
                    }
                    return $("<td>")
                        .text(slotText)
                        .addClass(slotClassName)
                        .attr("id", slot.minerId ? "minerSlot" : "emptySlot")
                        .attr("location", slot === null || slot === void 0 ? void 0 : slot.standardizedLocationId)
                        .attr("miner-id", slot === null || slot === void 0 ? void 0 : slot.minerId)
                        .attr("miner-name", slot === null || slot === void 0 ? void 0 : slot.minerName)
                        .attr("position", slot === null || slot === void 0 ? void 0 : slot.slotIndex)
                        .attr("slot-type", slotType)
                        .attr("ip", slot === null || slot === void 0 ? void 0 : slot.ip)
                        .on("click", handleSlotClick.bind(this))
                        .append(hasNote ? noteBadge : "")
                        .addClass(slot.minerId ? "minerSlot" : "emptySlot");
                });
                const numberCell = $(`<td>`)
                    .addClass("numberCell m-table-cell m-text")
                    .text(row.name);
                return $(`<tr>`)
                    .addClass(`m-table-row`)
                    .append(numberCell)
                    .append(rackRowSlots);
            });
            const boxHeading = $(`<h3>`)
                .addClass(`m-heading is-tertiary`)
                .text(`${rack.name}`);
            const rackTableBody = $(`<tbody>`)
                .addClass(`m-table-body`)
                .append(rackRows);
            const rackTable = $(`<table>`)
                .addClass(`m-table`)
                .append(rackTableBody);
            return $(`<div>`)
                .addClass(`rack`)
                .append(boxHeading)
                .append(rackTable);
        });
    }
    deriveSlotText(slot, slotType) {
        const value = this.getSlotValue(slot);
        const isHashRate = this.siteMapData.currentDataType === "hashrate_rt" || this.siteMapData.currentDataType === "hashrateAgg_30m";
        const isTemperature = !isHashRate;
        if (slotType === "RESERVED") {
            return "RES";
        }
        if (slotType === "PENDING") {
            return "PEND";
        }
        if (slotType === "EMPTY") {
            return "MTY";
        }
        if (isHashRate) {
            return formatHashrate(value);
        }
        if (isTemperature) {
            return formatTemperature(value);
        }
    }
    updateSlotType(slot) {
        slot.slotType = derive(() => {
            var _a;
            const value = this.getSlotValue(slot);
            const isHashrate = this.siteMapData.currentDataType === "hashrate_rt" || this.siteMapData.currentDataType === "hashrateAgg_30m";
            if (((_a = slot.errorCodes) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                return "ERROR";
            }
            if (slot.reserved && !slot.minerId) {
                return "RESERVED";
            }
            if (slot.pending && !slot.minerId) {
                return "PENDING";
            }
            if (!slot.minerId) {
                return "EMPTY";
            }
            if (typeof value === "undefined") {
                return "OFF";
            }
            if (value == 0) {
                return "OFF";
            }
            if (isHashrate) {
                if (value >= 0.945) {
                    return "EXPECTED";
                }
                if (value >= 0.745) {
                    return "BAD";
                }
                return "VERY BAD";
            }
            if (value > 89) {
                return "VERY BAD";
            }
            if (value > 79) {
                return "BAD";
            }
            return "EXPECTED";
        });
    }
    getSlotValue(slot) {
        // only set stale metrics in production
        const env = window.env;
        if (env == "prod") {
            const STALE_THRESHOLD_SECS = 10 * 60;
            const tenMinutesAgo = (Date.now() / 1000) - STALE_THRESHOLD_SECS; // Convert current time to Unix timestamp and subtract 10 minutes
            if (!(slot === null || slot === void 0 ? void 0 : slot.lastUpdatedUnix) || slot.lastUpdatedUnix < tenMinutesAgo) {
                return 0; // Return 0 if the slot's last update was more than 10 minutes ago or undefined
            }
        }
        switch (this.siteMapData.currentDataType) {
            case "hashrate_rt":
                if (slot.hashrate === null || slot.expectedHashrate === null) {
                    return 0;
                }
                return slot.hashrate / slot.expectedHashrate;
            case "hashrateAgg_30m":
                return slot.avgHashrateEfficiency;
            case "hashboard_temp_avg":
                return slot.avgHashboardTemp;
            case "hashboard_temp_max":
                return slot.maxHashboardTemp;
            case "chip_temp_avg":
                return slot.avgChipTemp;
            case "chip_temp_max":
                return slot.maxChipTemp;
        }
    }
}

class SiteMapStats {
    get siteMapData() {
        return this.siteMap.siteMapData;
    }
    constructor(siteMap) {
        this.siteMap = siteMap;
        this.siteMap.siteMapData.onPageLoad.add(this.onPageLoad.bind(this));
        this.siteMap.siteMapData.onPageRefresh.add(this.onPageRefresh.bind(this));
    }
    onPageLoad(zoneLayout) {
        this.populateData(zoneLayout);
    }
    onPageRefresh(zoneLayout) {
        this.populateData(zoneLayout);
    }
    populateData(zoneLayout) {
        let totalMinersHashing = 0;
        let totalLowHashingMiners = 0;
        let totalNotHashingMiners = 0;
        let totalMiners = 0;
        let totalReservedSlots = 0;
        let totalEmptySlots = 0;
        let totalErrorSlots = 0;
        (zoneLayout === null || zoneLayout === void 0 ? void 0 : zoneLayout.racks) && zoneLayout.racks.forEach((rack) => rack.rows.forEach((row) => row.slotData.forEach((slot) => {
            var _a;
            const isEmpty = slot.slotType === "EMPTY";
            const isReserved = slot.slotType === "RESERVED";
            const hasMiner = !isEmpty && !isReserved;
            const hashrateValue = this.siteMapData.currentDataType === "hashrateAgg_30m"
                ? slot.avgHashrateEfficiency : slot.hashrate / slot.expectedHashrate;
            const isHashing = hasMiner && hashrateValue > 0;
            const isNotHashing = hasMiner && hashrateValue !== null && hashrateValue === 0;
            const isLowHashing = hasMiner && hashrateValue !== null && hashrateValue > 0 && hashrateValue < 0.74;
            const hasError = (slot === null || slot === void 0 ? void 0 : slot.errorCodes) && ((_a = slot.errorCodes) === null || _a === void 0 ? void 0 : _a.length) > 0;
            if (isEmpty) {
                totalEmptySlots++;
            }
            if (hasMiner) {
                totalMiners++;
            }
            if (isHashing) {
                totalMinersHashing++;
            }
            if (isNotHashing) {
                totalNotHashingMiners++;
            }
            if (isReserved) {
                totalReservedSlots++;
            }
            if (isLowHashing) {
                totalLowHashingMiners++;
            }
            if (hasError) {
                totalErrorSlots++;
            }
        })));
        $("#totalMinersCount").text(totalMiners);
        $("#hashingMinersCount").text(totalMinersHashing);
        $("#lowHashingMinersCount").text(totalLowHashingMiners);
        $("#notHashingMinersCount").text(totalNotHashingMiners);
        $("#errorsCount").text(totalErrorSlots);
        $("#emptySlotsCount").text(totalEmptySlots);
        $("#reservedSlotsCount").text(totalReservedSlots);
    }
}

class SiteMapTemplatesNew {
}
SiteMapTemplatesNew.REBOOT_MODAL = `
            <div class="reboot-modal">
                Are you sure you want to reboot the following miner(s)?
                <br/>
                <ul>
            {{#miners}}
            <li>
                <div class="miner-name-modal">
                    {{minerName}}
                </div>
                <div class="miner-details-modal">
                    IP: {{ip}}
                    <br/>
                    Location: Rack {{rackNum}}, Row {{row}}, Position {{column}}
                </div>
                <br/>
            </li>
            {{/miners}}
            </ul>
            </div>
        `;
SiteMapTemplatesNew.UPDATE_LOCATION_MODAL = `
            <div class="stat-panel {{state}}">
                Please select a new location for the following miner:
                <br/>
                <div class="miner-name-modal">
                    {{minerName}}
                </div>
                <div class="miner-details-modal">
                    IP: {{ip}}
                    <br/>
                    Current Location: Rack {{rackNum}}, Row {{row}}, Position {{column}}
                </div>

                <div class="new-location-selection">
                    <input id="locationList" />
                </div>

            </div>
        `;
SiteMapTemplatesNew.SELECT_MINER_MODAL = `
            <div class="stat-panel {{state}}">
                <h3 class="m-text">Please select a miner to populate this location:</h3>
                <div class="miner-name-modal">
                    <span class="m-text">Rack {{rackNum}}, Row {{row}}, Position {{column}}</span>
                </div>

                <div class="m-form-group">
                    <label class="m-label m-stack has-space-s">
                        Data Point: 
                        <input id="minerDataPoint" />
                    </label>
                    <label class="m-label m-stack has-space-s">
                        Miner:
                        <input id="minerList" />
                    </label>
                </div>
            </div>
        `;
SiteMapTemplatesNew.SELECTED_MINERS_PANEL = `
            {{#miners}}
                <b>{{name}}</b>
            {{/miners}}
        `;
SiteMapTemplatesNew.RESERVE_LOCATION_MODAL = `
            <div class="reboot-modal">
                Are you sure you want to reserve the following location?
                <br/>
                <ul>
            <li>
                Rack {{rack}}, Row {{row}}, Position {{column}}
            </li>
            </ul>
            </div>
        `;

class ComputeNorthCurrentHashrate {
    constructor() {
        this.chart = new LineChart([ComputeNorthCurrentHashrate.cnPoolHashrateQuery], "#poolHashrateBusy");
        this.chart.elementSelector = "poolHashrateChart";
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.extraOptions.autoColor = true;
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        try {
            graphData.forEach((resp) => {
                resp.data.result.forEach((result) => {
                    serieData.push({
                        name: "Pool Hash Rate",
                        data: this.filterOutNaN(result.values)
                    });
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.series = serieData;
        this.chart.render();
    }
    filterOutNaN(values) {
        return values.filter((value) => {
            return !isNaN(value[1]); // +Inf & NaN;
        });
    }
    formatter(val, index) {
        return HashrateUtil.parseHashrate(val, 3);
    }
}
ComputeNorthCurrentHashrate.cnPoolHashrateQuery = "/ComputeNorthPoolHashrate";

class DailyRevenueStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/DailyRevenueStat";
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        setInterval(() => {
            this.loadStat();
        }, 120000);
    }
    handleCompanyFilterChanged(companyId) {
        this.loadStat();
    }
    loadStat() {
        this.toggleStatBusy(true);
        this.get(this.url)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            $("#revenueStat").text(parseFloat((resp.data.result[0].value[1] * 100).toString()).toFixed(8) + " BTC");
        }
        catch (_a) {
            $("#revenueStat").text("0 BTC");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#revenueBusy").removeClass("active");
            return;
        }
        $("#revenueBusy").addClass("active");
    }
}

class ComputeNorthHashrate {
    constructor() {
        this.chart = new LineChart([ComputeNorthHashrate.cnHashrateQuery, ComputeNorthHashrate.cnPoolHashrateQuery], "#hashrateBusy");
        this.chart.elementSelector = "hashrateChart";
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.extraOptions.autoColor = true;
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        try {
            graphData.forEach((resp) => {
                resp.data.result.forEach((result) => {
                    serieData.push({
                        name: (resp.internalName === "overallHashrate" ? "Miner Hash Rate" : "Pool Hash Rate"),
                        data: this.filterOutNaN(result.values)
                    });
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.series = serieData;
        this.chart.render();
    }
    filterOutNaN(values) {
        return values.filter((value) => {
            return !isNaN(value[1]); // +Inf & NaN;
        });
    }
    formatter(val, index) {
        return HashrateUtil.parseHashrate(val, 3);
    }
}
ComputeNorthHashrate.cnHashrateQuery = "/ComputeNorthHashrate";
ComputeNorthHashrate.cnPoolHashrateQuery = "/ComputeNorthPoolHashrate";

class HashrateVarianceGrid extends OptiFleetPage {
    constructor() {
        super();
        this.varianceUrl = "/PoolVariance?Interval=";
        this.init();
    }
    init() {
        $("#varianceGrid").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20,
            },
            scrollable: {
                virtual: true
            },
            height: "100%",
            filterable: false,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            noRecords: {
                template: "<div class=\"no-records\">There aren't any workers reporting yet.</div>"
            },
            columns: [
                { title: "Miner", width: "130px", template: this.getMinerTemplate.bind(this) },
                { field: "minerHashrateFormatted", title: "Miner Hash Rate", width: "150px" },
                { field: "poolHashrateFormatted", title: "Pool Hash Rate", width: "150px" },
                { field: "varianceFormatted", title: "Hash Rate Variance", width: "150px" },
                { field: "variancePercentFormatted", title: "Variance", width: "150px" },
            ]
        });
    }
    getMinerTemplate(data) {
        return `<div class="worker-title">${data.model}</div><div class="worker-desc">${data.ipAddress}</div>`;
    }
    load() {
        const ddlInterval = $("#intervalList").data("kendoDropDownList");
        const interval = ddlInterval.value();
        this.get(this.varianceUrl + interval)
            .then((data) => {
            const grid = $("#varianceGrid").data("kendoGrid");
            const dataSource = new self.kendo.data.DataSource({
                data: data.poolVariances,
                pageSize: 20
            });
            grid.setDataSource(dataSource);
        });
    }
}

class HistoricalHashrateStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/HistoricalHashrateStat?interval=";
    }
    load() {
        const ddlInterval = $("#intervalList").data("kendoDropDownList");
        const interval = ddlInterval.value();
        this.toggleStatBusy(true);
        this.get(this.url + interval)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            $("#avgHashrateStat").text(HashrateUtil.parseHashrate(resp.data.result[0].value[1], 3));
        }
        catch (_a) {
            $("#avgHashrateStat").text("0 H/s");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#avgHashrateStatBusy").removeClass("active");
            return;
        }
        $("#avgHashrateStatBusy").addClass("active");
    }
}

class HistoricalPoolHashrateStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/HistoricalPoolHashrateStat?interval=";
    }
    load() {
        const ddlInterval = $("#intervalList").data("kendoDropDownList");
        const interval = ddlInterval.value();
        this.toggleStatBusy(true);
        this.get(this.url + interval)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            $("#avgPoolHashrateStat").text(HashrateUtil.parseHashrate(resp.data.result[0].value[1], 3));
        }
        catch (_a) {
            $("#avgPoolHashrateStat").text("0 H/s");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#avgPoolHashrateBusy").removeClass("active");
            return;
        }
        $("#avgPoolHashrateBusy").addClass("active");
    }
}

class HistoricalPoolStats extends OptiFleetPage {
    constructor() {
        super();
        this.hashrateStat = new HistoricalHashrateStat();
        this.poolHashrateStat = new HistoricalPoolHashrateStat();
        this.varianceStat = new HistoricalVarianceStat();
    }
    load() {
        this.hashrateStat.load();
        this.poolHashrateStat.load();
        this.varianceStat.load();
    }
}

class HistoricalVarianceStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/HistoricalVarianceStat?interval=";
    }
    load() {
        const ddlInterval = $("#intervalList").data("kendoDropDownList");
        const interval = ddlInterval.value();
        this.toggleStatBusy(true);
        this.get(this.url + interval)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            $("#avgVarianceStat").text(resp.stat.toFixed(3) + "%");
        }
        catch (_a) {
            $("#avgVarianceStat").text("0 %");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#avgVarianceBusy").removeClass("active");
            return;
        }
        $("#avgVarianceBusy").addClass("active");
    }
}

class OverallEfficiencyStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/OverallEfficiencyStat";
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        setInterval(() => {
            this.loadStat();
        }, 120000);
    }
    handleCompanyFilterChanged(companyId) {
        this.loadStat();
    }
    loadStat() {
        this.toggleStatBusy(true);
        this.get(this.url)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            $("#efficiencyStat").text((resp.acceptedShares * 100).toFixed(2) + "%");
        }
        catch (ex) {
            $("#efficiencyStat").text("0 %");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#efficiencyBusy").removeClass("active");
            return;
        }
        $("#efficiencyBusy").addClass("active");
    }
}

class PendingBalanceStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/PendingBalanceStat";
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        setInterval(() => {
            this.loadStat();
        }, 120000);
    }
    handleCompanyFilterChanged(companyId) {
        this.loadStat();
    }
    loadStat() {
        this.toggleStatBusy(true);
        this.get(this.url)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            $("#pendingBalanceStat").text(parseFloat(resp.data.result[0].value[1]).toFixed(8) + " BTC");
        }
        catch (_a) {
            $("#pendingBalanceStat").text("0 BTC");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#pendingBalanceBusy").removeClass("active");
            return;
        }
        $("#pendingBalanceBusy").addClass("active");
    }
}

class TotalHashrateStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/TotalHashrateStat";
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        setInterval(() => {
            this.loadStat();
        }, 120000);
    }
    handleCompanyFilterChanged(companyId) {
        this.loadStat();
    }
    loadStat() {
        this.toggleStatBusy(true);
        this.get(this.url)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            $("#hashrateStat").text(HashrateUtil.parseHashrate(resp.data.result[0].value[1] * 1000000000, 3));
        }
        catch (_a) {
            $("#hashrateStat").text("0 H/s");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#hashRateStatBusy").removeClass("active");
            return;
        }
        $("#hashRateStatBusy").addClass("active");
    }
}

class TotalRevenueStat extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/TotalRevenueStat";
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        setInterval(() => {
            this.loadStat();
        }, 120000);
    }
    handleCompanyFilterChanged(companyId) {
        this.loadStat();
    }
    loadStat() {
        this.toggleStatBusy(true);
        this.get(this.url)
            .then((resp) => {
            this.populateStat(resp);
            this.toggleStatBusy(false);
        });
    }
    populateStat(resp) {
        try {
            $("#totalRevenueStat").text((parseFloat(resp.data.result[0].value[1])).toFixed(8) + " BTC");
        }
        catch (e) {
            $("#totalRevenueStat").text("0 BTC");
        }
    }
    toggleStatBusy(isBusy) {
        if (!isBusy) {
            $("#totalRevenueBusy").removeClass("active");
            return;
        }
        $("#totalRevenueBusy").addClass("active");
    }
}

class WorkerPayoutsGrid extends OptiFleetPage {
    constructor() {
        super();
        this.workerUrl = "/PoolWorkers";
        this.payoutUrl = "/PoolPayouts";
        this.init();
    }
    load() {
        this.loadWorkers();
        this.loadPayouts();
    }
    init() {
        $("#workerGrid").kendoGrid({
            dataSource: {
                data: []
            },
            scrollable: true,
            height: "100%",
            filterable: false,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            noRecords: {
                template: "<div class=\"no-records\">There aren't any workers reporting yet.</div>"
            },
            columns: [
                { title: "Worker", width: "100px", template: this.getWorkerTemplate.bind(this) },
                { title: "Miner", width: "130px", template: this.getMinerTemplate.bind(this) },
                { field: "status", title: "Status", width: "140px" },
                { field: "hashrate", title: "Hash Rate", width: "150px" }
            ]
        });
        $("#payoutGrid").kendoGrid({
            dataSource: {
                data: []
            },
            scrollable: true,
            height: "100%",
            filterable: false,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            noRecords: {
                template: "<div class=\"no-records\">There hasn't been any payouts yet.</div>"
            },
            columns: [
                { field: "payoutTime", title: "Time", width: "180px" },
                { field: "account", title: "Account", width: "150px" },
                { field: "payoutType", title: "Type", width: "120px" },
                { field: "address", title: "Address", width: "350px" },
                { title: "Amount", template: this.getAmountTemplate.bind(this), width: "180px" },
                { title: "Transaction ID", template: this.getTransactionTemplate.bind(this) },
            ]
        });
    }
    getWorkerTemplate(data) {
        return `<div class="worker-title">${data.name}</div>`;
    }
    getMinerTemplate(data) {
        return `<div class="worker-title">${data.model}</div><div class="worker-desc">${data.ipAddress}</div><div class="worker-desc">${data.serialNumber}</div>`;
    }
    getAmountTemplate(data) {
        return `${data.amount} BTC`;
    }
    getTransactionTemplate(data) {
        if (!data.transactionId) {
            return "";
        }
        return `<a href="https://www.blockchain.com/btc/tx/${data.transactionId}" target="_blank">
                        <i class="icon-arrow-up-right-square open-in-new"></i>
                        <span class="transaction">${data.transactionId}</span>
                    </a>`;
    }
    loadWorkers() {
        this.toggleWorkersStatBusy(true);
        this.get(this.workerUrl)
            .then((data) => {
            const grid = $("#workerGrid").data("kendoGrid");
            const dataSource = new self.kendo.data.DataSource({
                data: data.poolWorkers,
            });
            grid.setDataSource(dataSource);
            $("#workersStat").text(data.poolWorkers.length);
            this.toggleWorkersStatBusy(false);
        });
    }
    toggleWorkersStatBusy(isBusy) {
        if (!isBusy) {
            $("#workersBusy").removeClass("active");
            return;
        }
        $("#workersBusy").addClass("active");
    }
    loadPayouts() {
        this.get(this.payoutUrl)
            .then((data) => {
            const grid = $("#payoutGrid").data("kendoGrid");
            const dataSource = new self.kendo.data.DataSource({
                data: data.poolPayouts,
            });
            grid.setDataSource(dataSource);
        });
    }
}

class SiteMapBuilder extends OptiFleetPage {
    constructor(siteMap) {
        super();
        this.siteMap = siteMap;
        this.zoneHashrateUrl = "/zoneHashrate";
        this.zoneTemperatureUrl = "/zoneTemperature";
        this.aggregationInterval = null;
        this.hashrateFormatter = Intl.NumberFormat("default", { style: "percent" });
        this.temperatureFormatter = Intl.NumberFormat("default", { maximumSignificantDigits: 2 });
    }
    buildRackData(metrics) {
        const data = new Map();
        metrics.data.result.forEach((result) => {
            let rack = +result.metric["rowOrSection"];
            // Handle Alphabetic racks
            if (isNaN(rack)) {
                rack = result.metric["rowOrSection"].charCodeAt(0) - 64;
            }
            const row = +result.metric["rackOrShelf"];
            const column = +result.metric["position"];
            const location = result.metric["locationId"];
            data.set(location, {
                minerId: +result.metric["minerId"],
                minerName: result.metric["minerName"],
                location: location,
                ip: result.metric["ip"],
                rack: rack,
                row: row,
                column: column,
                value: +result.value[1],
            });
        });
        return data;
    }
    populateHashrateData() {
        return __awaiter(this, void 0, void 0, function* () {
            let url = `${this.zoneHashrateUrl}?siteId=${yield this.siteMap.getSiteId()}&zoneId=${this.siteMap.getZoneId()}`;
            if (this.aggregationInterval) {
                url += `&aggregationInterval=${this.aggregationInterval}`;
            }
            return this.get(url).then((resp) => {
                const hashrateData = this.buildRackData(resp.metrics);
                $(".miner-position-cell")
                    .removeClass("hr-green hr-orange hr-red location-inactive")
                    .removeAttr("minerId minerName ip")
                    .html("")
                    .each((index, elem) => {
                    const currentCell = $(elem);
                    const location = currentCell.attr("location");
                    if (hashrateData.has(location)) {
                        const data = hashrateData.get(location);
                        if (data.ip === null) {
                            currentCell.addClass("hr-noip");
                        }
                        else if (data.value > 0.98) {
                            currentCell.addClass("hr-green");
                        }
                        else if (data.value > 0.8) {
                            currentCell.addClass("hr-orange");
                        }
                        else {
                            currentCell.addClass("hr-red");
                        }
                        currentCell.html(`${this.hashrateFormatter.format(data.value)}`);
                        currentCell.attr("minerId", data.minerId);
                        currentCell.attr("minerName", data.minerName);
                        currentCell.attr("ip", data.ip);
                        return;
                    }
                    if (!this.siteMap.IsActiveLocation(location)) {
                        $(elem).attr("disabled", "disabled").addClass("location-inactive");
                        return;
                    }
                });
                this.clearEmptySpaces();
            });
        });
    }
    populateTemperatureData() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.zoneTemperatureUrl}?siteId=${yield this.siteMap.getSiteId()}&zoneId=${this.siteMap.getZoneId()}`;
            return this.get(url).then((resp) => {
                const temperatureMap = this.buildRackData(resp.metrics);
                $(".miner-position-cell")
                    .removeClass("hr-green hr-orange hr-red location-inactive")
                    .removeAttr("minerId minerName ip")
                    .html("")
                    .each((index, elem) => {
                    const currentCell = $(elem);
                    const location = currentCell.attr("location");
                    if (temperatureMap.has(location)) {
                        const data = temperatureMap.get(location);
                        if (data.ip === null) {
                            currentCell.addClass("hr-noip");
                        }
                        else if (data.value > 90) {
                            currentCell.addClass("hr-red");
                        }
                        else if (data.value > 80) {
                            currentCell.addClass("hr-orange");
                        }
                        else {
                            currentCell.addClass("hr-green");
                        }
                        currentCell.html(`${this.hashrateFormatter.format(data.value)}`);
                        currentCell.html(`${this.temperatureFormatter.format(data.value)}Â°C`);
                        currentCell.attr("minerId", data.minerId);
                        currentCell.attr("minerName", data.minerName);
                        currentCell.attr("ip", data.ip);
                        return;
                    }
                    if (!this.siteMap.IsActiveLocation(location)) {
                        $(elem).attr("disabled", "disabled").addClass("location-inactive");
                        return;
                    }
                });
                this.clearEmptySpaces();
            });
        });
    }
    clearEmptySpaces() {
        $("table.miner-rack").each((i, elem) => {
            if ($(elem).find("td.miner-position-cell:not(.location-inactive)").length === 0) {
                $(elem).remove();
                return;
            }
            $(elem).children("tr").each((i, row) => {
                if ($(row).find("td.miner-position-cell:not(.location-inactive)").length === 0) {
                    $(row).remove();
                }
            });
        });
    }
    rebuildLayout() {
        const zone = this.siteMap.getZones().filter((zone) => zone.zoneId === this.siteMap.getZoneId())[0];
        const zoneLayout = LayoutBuilder.BuildZone(zone);
        $("#zones").hide().empty().append(zoneLayout);
    }
    setAggregationInterval(interval) {
        this.aggregationInterval = interval;
    }
}

class SiteMapTemplates {
}
SiteMapTemplates.REBOOT_MODAL = `
            <div class="reboot-modal">
                Are you sure you want to reboot the following miner{{pluralMiners}}?
                <br/>
                <ul>
            {{#miners}}
            <li>
                <div class="miner-name-modal">
                    {{minerName}}
                </div>
                <div class="miner-details-modal">
                    IP: {{ip}}
                    <br/>
                    Location: Rack {{rack}}, Row {{row}}, Position {{column}}
                </div>
                <br/>
            </li>
            {{/miners}}
            </ul>
            </div>
        `;
SiteMapTemplates.UPDATE_LOCATION_MODAL = `
            <div class="stat-panel {{state}}">
                Please select a new location for the following miner:
                <br/>
                <div class="miner-name-modal">
                    {{minerName}}
                </div>
                <div class="miner-details-modal">
                    IP: {{ip}}
                    <br/>
                    Current Location: Rack {{rack}}, Row {{row}}, Position {{column}}
                </div>

                <div class="new-location-selection">
                    <input id="locationList" />
                </div>

            </div>
        `;
SiteMapTemplates.SELECT_MINER_MODAL = `
            <div class="stat-panel {{state}}">
                Please select a miner to populate this location:
                <br/>

                <div class="miner-name-modal">
                    <span>Location:</span>Rack {{rack}}, Row {{row}}, Position {{column}}
                </div>

                <div class="new-miner-selection">
                    <input id="minerList" />
                </div>

            </div>
        `;
SiteMapTemplates.SELECTED_MINERS_PANEL = `
            {{#miners}}
                <b>{{name}}</b>
            {{/miners}}
        `;

class SiteMapUI extends OptiFleetPage {
    constructor(siteMap) {
        super();
        this.siteMap = siteMap;
        this.sitesUrl = "/sites";
        this.siteDetailsUrl = "/siteDetails";
        this.availableLocationsUrl = "/MinerPropertyList?type=AvailableCompanyLocation";
        this.maxSelected = 15;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadSiteDetails();
        });
    }
    loadSiteDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.get(`${this.siteDetailsUrl}?siteId=${yield this.siteMap.getSiteId()}`).then((resp) => {
                    $(".site-map-wrapper .grid-busy").hide();
                    const zones = this.siteMap.setZones(resp.zones);
                    const zoneIds = zones.map((z) => z.zoneId);
                    if (zoneIds.indexOf(this.siteMap.getZoneId()) === -1) {
                        this.siteMap.setZoneId(zones[0].zoneId);
                    }
                    const zoneListDDL = $("#zoneList").data("kendoDropDownList");
                    zoneListDDL.setDataSource(kendo.data.DataSource.create({
                        data: resp.zones.map((zone) => {
                            return { name: zone.zoneName, value: zone.zoneId };
                        }),
                    }));
                    zoneListDDL.value(this.siteMap.getZoneId().toString());
                    $(".zone-picker").removeClass("invisible");
                    this.siteMap.refresh();
                });
            }
            catch (error) {
                //eat
                //console.error(error);
            }
        });
    }
    contextOpen(e) {
        const target = $(e.target);
        if (target.hasClass("selectable")) {
            this.toggleSelected(target);
        }
        if (target.hasClass("location-inactive") || this.multiSelectMode === true) {
            e.preventDefault();
            return;
        }
        const minerId = target.attr("minerId");
        if (typeof minerId === "undefined") {
            $("#menu .unpopulated").show();
            $("#menu .populated").hide();
        }
        else {
            $("#menu .unpopulated").hide();
            $("#menu .populated").show();
        }
        const name = target.attr("minerName");
        $("#menu span.miner-name").html(name ? name : "Empty Cell");
        const ip = target.attr("ip");
        $("#menu span.ip").html(ip ? ip : "N/A");
    }
    contextSelection(e) {
        const item = $(e.item);
        const action = item.attr("action");
        if (action === undefined) {
            return;
        }
        this.targetCell = $(e.target);
        const position = this.targetCell.attr("position");
        const minerId = parseInt(this.targetCell.attr("minerId"));
        const [rack, row, column] = position.split("-");
        if (action === "miner-view") {
            OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${minerId}`);
            return;
        }
        this.targetMinerId = minerId;
        const selectedMiner = {
            rack: rack,
            row: row,
            column: column,
            minerId: minerId,
            minerName: this.targetCell.attr("minerName"),
            ip: this.targetCell.attr("ip"),
        };
        const modalData = {
            pluralMiners: "",
            miners: [selectedMiner],
        };
        if (action === "miner-reboot") {
            const rebootModalContent = self.Mustache.to_html(SiteMapTemplates.REBOOT_MODAL, modalData);
            const dlg = $("#reboot-dialog").data("kendoDialog");
            dlg.content(rebootModalContent);
            dlg.open();
            return;
        }
        if (action === "miner-update-location") {
            const content = self.Mustache.to_html(SiteMapTemplates.UPDATE_LOCATION_MODAL, selectedMiner);
            const dlg = $("#location-dialog").data("kendoDialog");
            dlg.content(content);
            let locationDDL = $("locationList").data("kendoDropDownList");
            const ds = new kendo.data.DataSource({
                transport: {
                    read: this.loadAvailableLocations.bind(this),
                },
                schema: {
                    data: (response) => response.list,
                },
            });
            if (!locationDDL) {
                locationDDL = $("#locationList")
                    .kendoDropDownList({
                    autoBind: false,
                    dataTextField: "text",
                    dataValueField: "text",
                    dataSource: ds,
                    filter: "contains",
                    value: "Unassigned",
                    text: "Unassigned",
                })
                    .data("kendoDropDownList");
                locationDDL.ul.width(300);
            }
            dlg.open();
            return;
        }
        if (action === "select-miner") {
            const content = self.Mustache.to_html(SiteMapTemplates.SELECT_MINER_MODAL, selectedMiner);
            const dlg = $("#miner-dialog").data("kendoDialog");
            dlg.content(content);
            let minerDDL = $("#minerList").data("kendoDropDownList");
            const ds = new kendo.data.DataSource({
                transport: {
                    read: this.loadMiners.bind(this),
                },
                schema: {
                    data: (response) => response.miners,
                },
            });
            if (!minerDDL) {
                minerDDL = $("#minerList")
                    .kendoDropDownList({
                    autoBind: false,
                    dataTextField: "name",
                    dataValueField: "id",
                    dataSource: ds,
                    filter: "contains",
                    value: "-1",
                })
                    .data("kendoDropDownList");
                minerDDL.ul.width(300);
            }
            dlg.open();
            return;
        }
        if (action === "miner-start-multiselect") {
            this.enableMultiSelectMode();
            this.toggleSelected(this.targetCell);
            return;
        }
    }
    loadMiners(options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.get(`${this.siteMap.minersUrl}?siteId=${yield this.siteMap.getSiteId()}`).then((resp) => {
                options.success(resp);
            });
        });
    }
    loadAvailableLocations(options) {
        this.get(this.availableLocationsUrl).then((resp) => {
            const zoneNames = this.siteMap.getZones().map((z) => z.zoneName);
            resp.list = resp.list.filter((property) => {
                for (const zoneName of zoneNames) {
                    if (property.text.startsWith(zoneName + "-")) {
                        return true;
                    }
                }
                return property.text === "Unassigned";
            });
            options.success(resp);
        });
    }
    updateSelectedMiner() {
        const locationDDL = $("#locationList").data("kendoDropDownList");
        const minerId = this.targetCell.attr("minerId");
        if (minerId !== undefined) {
            this.siteMap.updateMinerLocation(minerId, locationDDL.value());
        }
    }
    promptRebootMiners() {
        const miners = $(".miner-position-cell[minerId].selected").map((i, e) => {
            const targetCell = $(e);
            const position = targetCell.attr("position");
            const minerId = parseInt(this.targetCell.attr("minerId"));
            const [rack, row, column] = position.split("-");
            return {
                rack: rack,
                row: row,
                column: column,
                minerId: minerId,
                minerName: targetCell.attr("minerName"),
                ip: targetCell.attr("ip"),
            };
        });
        if (miners.length === 0) {
            this.showErrorMessage("No Miners selected");
            return;
        }
        const modalData = {
            pluralMiners: miners.length > 1 ? "s" : "",
            miners: miners.get(),
        };
        const rebootModalContent = self.Mustache.to_html(SiteMapTemplates.REBOOT_MODAL, modalData);
        const dlg = $("#reboot-dialog").data("kendoDialog");
        dlg.content(rebootModalContent);
        dlg.open();
    }
    enableMultiSelectMode() {
        $(".miner-position-cell[minerId]").addClass("selectable");
        $("#btnExport").removeAttr("disabled");
        $(".site-map-helptext").addClass("active");
        this.multiSelectMode = true;
    }
    disableMultiSelectMode() {
        $(".miner-position-cell.selectable").removeClass("selectable selected");
        $("#btnExport").attr("disabled", "disabled");
        $(".site-map-helptext").removeClass("active");
        this.multiSelectMode = false;
    }
    toggleSelected(element) {
        if (element.hasClass("selected") === false &&
            $(".miner-position-cell[minerId].selected").length >= this.maxSelected) {
            return;
        }
        element.toggleClass("selected");
    }
}

class SiteOverview extends OptiFleetPage {
    constructor() {
        let showWeather = true;
        super(showWeather, {
            includeAllSites: true,
            elemId: "siteOverviewSiteSelect"
        });
        this.hashingInventoryUrl = "/HashingInventory";
        this.minute = 60 * 1000;
        this.nonHashingUrl = "../../Content/Issues/Issues.aspx?view=Non Hashing&siteId=";
        this.lowHashingUrl = "../../Content/Issues/Issues.aspx?view=Low Hashing&siteId=";
        this.AgentsUrl = "/Agents";
        this.overallHashrateQuery = "/OverallHashrate";
        this.theoreticalHashrateQuery = "/TheoreticalHashrate";
        this.hashingType = 1;
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        this.zonePerformance = new ZonePerformance();
        this.zoneHashrate = new ZoneHashrate();
        this.zoneUptime = new ZoneUptime();
        this.hashrateChart = new StyledLineChart("HashrateChart", "Hash Rate", { height: "235px", withLegend: true, useNoLegendColors: true }, "#hashrateBusy");
        this.hashrateChart.formatter = (val) => HashrateUtil.parseHashrate(val, 1);
        this.datePicker = new DatePicker("#datePicker", this.loadChart.bind(this));
        this.refreshDisabled = false;
        this.refreshFunction = this.reload.bind(this);
        $("#siteUtilizationUnassignedMiners").on("click", () => OptiFleetMaster.navigateTo(`Dashboard/Miners/List?zone=unassigned&status=active&status=unreachable`));
        $("#uptimeOfflineMiners").on("click", () => OptiFleetMaster.navigateTo(`Dashboard/Miners/List?connection=offline&status=active&status=unreachable`));
        this.loadStatuses();
    }
    toggleFullscreen() {
        const isFullscreen = document.fullscreenElement !== null;
        if (isFullscreen) {
            document.exitFullscreen();
            return;
        }
        const elem = $("#mainContent").get(0);
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        }
    }
    loadStatuses() {
        this.get("/statuses")
            .then((resp) => {
            const online = resp.statuses.find(x => x.displayName === "Online");
            const offline = resp.statuses.find(x => x.displayName === "Offline");
            $("#siteUtilizationUnassignedMiners").on("click", () => OptiFleetMaster.navigateTo(`Dashboard/Miners/List?zone=unassigned&status=${online.statusId}&status=${offline.statusId}`));
            $("#uptimeOfflineMiners").on("click", () => OptiFleetMaster.navigateTo(`Dashboard/Miners/List?status=${offline.statusId}`));
        });
    }
    viewZoneOnClick(siteId) {
        localStorage.setItem("selectedSite", siteId);
        localStorage.setItem("selectedSiteName", this.siteCache.getSiteName());
    }
    handleCompanyFilterChanged(companyId) {
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(siteId) {
        this.reload();
    }
    loadChart(params) {
        return __awaiter(this, void 0, void 0, function* () {
            params.siteId = parseInt(yield this.siteCache.getSiteId());
            this.hashrateChart.toggleGraphBusy(true);
            const expected = this.post(this.theoreticalHashrateQuery, params);
            const actual = this.post(this.overallHashrateQuery, params);
            Promise.all([actual, expected]).then((res) => {
                this.hashrateChart.populateChartData(res);
                this.hashrateChart.toggleGraphBusy(false);
            });
        });
    }
    reload() {
        return __awaiter(this, void 0, void 0, function* () {
            let datePickerPromise = null;
            if (!this.datePicker.isAbsoluteRange) {
                this.datePicker.refreshParams();
                const queryParams = this.datePicker.getParams();
                datePickerPromise = this.loadChart(queryParams);
            }
            const siteId = parseInt(yield this.siteCache.getSiteId());
            this.setupLinks(siteId);
            yield Promise.all([
                this.loadHashingInventory(siteId),
                datePickerPromise,
                this.zonePerformance.load(siteId),
                this.zoneHashrate.load(siteId),
                this.zoneUptime.load(siteId)
            ]);
        });
    }
    setupLinks(siteId) {
        $("#lowHashingLink").attr("href", `${this.lowHashingUrl}${siteId}`);
        $("#nonHashingLink").attr("href", `${this.nonHashingUrl}${siteId}`);
    }
    loadHashingInventory(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = siteId !== -1 ? `${this.hashingInventoryUrl}?siteId=${siteId}` : this.hashingInventoryUrl;
            yield this.get(url)
                .then((resp) => {
                const totalMinerSlots = resp.positionCount;
                resp.totalCount;
                const totalActiveOrUnreachableCount = resp.totalActiveOrUnreachableCount;
                const minersWithLocations = resp.minerCountWithLocations;
                const reservedLocationCount = resp.reservedLocationCount;
                const unreachableMinersCount = resp.unreachableMinersCount;
                const minersHashing = resp.hashingCount;
                const lowHashingMiners = resp.lowHashingCount;
                const nonHashingMiners = resp.notHashingCount;
                // formats a floating point number to a readable percentage
                // e.g. formatPercentage(0.06) -> 6.1%
                function formatPercentage(num, decimalPlaces = 1) {
                    const rounded = MathUtil.round(num * 100, decimalPlaces);
                    // fix all nums to one decimal point e.g. 9 -> "9.0"
                    const formatted = rounded.toFixed(decimalPlaces);
                    return `${formatted}%`;
                }
                // formats a floating point number to a capped percentage
                // e.g. fomatBarWidth(1.2) -> 100.0%
                function formatPercentageCapped(num) {
                    // ensure num is not greater than 1
                    const capped = Math.min(num, 1);
                    return formatPercentage(capped);
                }
                /* SITE UTILIZATION */
                {
                    const filledCount = minersWithLocations + reservedLocationCount;
                    const filledPercentage = MathUtil.divide(filledCount, totalMinerSlots);
                    const barWidth = formatPercentageCapped(filledPercentage);
                    const spacesFilledPercentage = formatPercentage(filledPercentage);
                    $("#siteUtilizationBar").css("width", barWidth);
                    $("#siteUtilizationBarVal").text(filledCount + " Assigned");
                    $("#siteUtilizationTotalSpaces").text(totalMinerSlots);
                    $("#siteUtilizationAssignedMinersPercent").text(spacesFilledPercentage);
                    $("#siteUtilizationUnassignedMiners").text(resp.unassignedCount + " Unassigned");
                }
                /* SITE UTILIZATION */
                /* UPTIME */
                {
                    const filledPercentage = MathUtil.divide(minersHashing, totalActiveOrUnreachableCount);
                    const barWidth = formatPercentageCapped(filledPercentage);
                    const uptimePercentage = formatPercentage(filledPercentage);
                    $("#uptimeBar").css("width", barWidth);
                    $("#uptimeBarVal").text(minersHashing + " Hashing");
                    $("#uptimeTotalMiners").text(totalActiveOrUnreachableCount);
                    $("#uptimePercentage").text(uptimePercentage);
                    $("#uptimeOfflineMiners").text(unreachableMinersCount + " Offline");
                }
                /* UPTIME */
                /* HASH RATE */
                {
                    const normalizedSiteHashrate = HashrateUtil.normalizeHashrate(resp.siteHashrate, resp.siteHashrateUnit, resp.siteExpectedHashrateUnit);
                    const normalizedExpectedHashrate = HashrateUtil.normalizeHashrate(resp.siteExpectedHashrate, resp.siteExpectedHashrateUnit, resp.siteExpectedHashrateUnit);
                    const filledPercentage = MathUtil.divide(normalizedSiteHashrate.hashesPerSecond, normalizedExpectedHashrate.hashesPerSecond);
                    const barWidth = formatPercentageCapped(filledPercentage);
                    const efficiencyPercentage = formatPercentage(filledPercentage);
                    $("#hashRateBar").css("width", barWidth);
                    $("#hashRateBarVal").text(`${normalizedSiteHashrate.value} ${normalizedSiteHashrate.unit}`);
                    $("#hashRatePotential").text(normalizedExpectedHashrate.value);
                    $("#hashRatePotentialUnits").text(normalizedExpectedHashrate.unit);
                    $("#hashRateEfficiency").text(efficiencyPercentage);
                }
                /* HASH RATE */
                /* HASHING IMPACT */
                const lowHashingFraction = `${lowHashingMiners}/${totalActiveOrUnreachableCount}`;
                const nonHashingFraction = `${nonHashingMiners}/${totalActiveOrUnreachableCount}`;
                const normLowHashingImpact = HashrateUtil.normalizeHashrate(resp.lowHashingImpactValue, resp.lowHashingImpactUnit, resp.siteExpectedHashrateUnit);
                const normNonHashingImpact = HashrateUtil.normalizeHashrate(resp.notHashingImpactValue, resp.notHashingImpactUnit, resp.siteExpectedHashrateUnit);
                const lowHashingImpactFormatted = `${normLowHashingImpact.value} ${normLowHashingImpact.unit.replace("Hs", "H/s")}`;
                const nonHashingImpactFormatted = `${normNonHashingImpact.value} ${normNonHashingImpact.unit.replace("Hs", "H/s")}`;
                $("#lowHashingFraction").text(lowHashingFraction);
                $("#nonHashingFraction").text(nonHashingFraction);
                $("#lowHashingImpact").text(lowHashingImpactFormatted);
                $("#nonHashingImpact").text(nonHashingImpactFormatted);
                /* HASHING IMPACT */
            });
        });
    }
}

class SiteOverviewTemplates {
}
SiteOverviewTemplates.ZONE = `
            <a class="stat-panel {{state}}" onclick="pageScript.viewZoneOnClick({{siteId}})" href="{{navUrl}}" target="_blank">
                <div class="m-stack has-space-xs">
                    <div class="m-stack is-horizontal has-space-between">
                        <p class="m-heading is-size-m">{{zoneName}}</p>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--color-text-default)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square-arrow-out-up-right"><path d="M21 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h6"/><path d="m21 3-9 9"/><path d="M15 3h6v6"/></svg>
                    </div>
                    <h5 class="stat m-heading">{{performance}}%</h5>
                </div>
            </a>
        `;
SiteOverviewTemplates.ZONE_HASHRATE = `
            <a class="stat-panel {{state}}" onclick="pageScript.viewZoneOnClick({{siteId}})" href="{{navUrl}}" target="_blank">
                <div class="m-stack has-space-xs">
                    <div class="m-stack is-horizontal has-space-between">
                        <p class="m-heading is-size-m">{{zoneName}}</p>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--color-text-default)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square-arrow-out-up-right"><path d="M21 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h6"/><path d="m21 3-9 9"/><path d="M15 3h6v6"/></svg>
                    </div>
                    <h5 class="stat m-heading">
                        {{hashrate}}
                        <span class="m-text is-size-m">/ {{expectedHashrate}} {{unit}}</span>
                    </h5>
                </div>
            </a>
        `;

class ZoneHashrate extends OptiFleetPage {
    constructor() {
        super();
        this.zonePerformanceUrl = "/zonePerformance";
    }
    load(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = siteId !== -1 ? `${this.zonePerformanceUrl}?siteId=${siteId}` : this.zonePerformanceUrl;
            yield this.get(url)
                .then((resp) => {
                this.populateZoneHashrateCards(resp.zonePerformances);
            });
        });
    }
    populateZoneHashrateCards(zones) {
        $("#zoneHashrateGrid").empty();
        zones.forEach((zone) => {
            let performance = zone.expectedHashrate > 0 ? zone.hashrate / zone.expectedHashrate * 100 : 0;
            var expectedHashrateData = HashrateUtil.normalizeHashrate(zone.expectedHashrate, "Hs", HashrateUtil.getHashrateUnit(zone.expectedHashrate, 1));
            var hashrateData = HashrateUtil.normalizeHashrate(zone.hashrate, "Hs", expectedHashrateData.unit);
            const zoneItem = {
                zoneName: zone.zoneName,
                siteId: zone.siteId,
                unit: expectedHashrateData.unit,
                hashrate: hashrateData.value.toFixed(1),
                expectedHashrate: expectedHashrateData.value.toFixed(1),
                navUrl: `/Content/Dashboard/Miners/Map.aspx?SiteId=${zone.siteId}&ZoneId=${zone.zoneId}`,
                state: this.getPerformanceState(performance)
            };
            const zonePerf = self.Mustache.to_html(SiteOverviewTemplates.ZONE_HASHRATE, zoneItem);
            $("#zoneHashrateGrid").append(zonePerf);
        });
    }
    viewZoneOnClick(siteId) {
        localStorage.setItem("siteCache", siteId);
    }
    getPerformanceState(performance) {
        var perfPercent = performance * 100;
        if (perfPercent > 98) {
            return "good";
        }
        if (perfPercent > 80) {
            return "warn";
        }
        if (perfPercent > 0) {
            return "bad";
        }
        return "";
    }
}

class ZonePerformance extends OptiFleetPage {
    constructor() {
        super();
        this.zonePerformanceUrl = "/zonePerformance";
    }
    load(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = siteId !== -1 ? `${this.zonePerformanceUrl}?siteId=${siteId}` : this.zonePerformanceUrl;
            yield this.get(url)
                .then((resp) => {
                this.populateZonePerformance(resp.zonePerformances);
            });
        });
    }
    populateZonePerformance(zones) {
        $("#zone-stats").children().remove();
        $("#zoneStatsGrid").empty();
        zones.forEach((zone) => {
            let performance = zone.expectedHashrate > 0 ? zone.hashrate / zone.expectedHashrate * 100 : 0;
            const zoneItem = {
                zoneName: zone.zoneName,
                siteId: zone.siteId,
                unit: "%",
                performance: parseFloat((performance).toString()).toFixed(1),
                navUrl: `/Content/Dashboard/Miners/Map.aspx?SiteId=${zone.siteId}&ZoneId=${zone.zoneId}`,
                state: this.getPerformanceState(performance)
            };
            const zonePerf = self.Mustache.to_html(SiteOverviewTemplates.ZONE, zoneItem);
            $("#zoneStatsGrid").append(zonePerf);
        });
    }
    viewZoneOnClick(siteId) {
        localStorage.setItem("siteCache", siteId);
    }
    getPerformanceState(performance) {
        var perfPercent = performance * 100;
        if (perfPercent > 98) {
            return "good";
        }
        if (perfPercent > 80) {
            return "warn";
        }
        if (perfPercent > 0) {
            return "bad";
        }
        return "";
    }
}

class ZoneUptime extends OptiFleetPage {
    constructor() {
        super();
        this.zoneUptimeUrl = "/zoneUptime";
    }
    load(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = siteId !== -1 ? `${this.zoneUptimeUrl}?siteId=${siteId}` : this.zoneUptimeUrl;
            yield this.get(url)
                .then((resp) => {
                this.populateZoneUptime(resp.zoneUptimes);
            });
        });
    }
    populateZoneUptime(zones) {
        $("#zoneUptimeGrid").empty();
        zones.forEach((zone) => {
            const uptime = zone.assigned === 0 ? 0 : Number(zone.hashing) / Number(zone.assigned);
            const performance = parseFloat((uptime * 100).toString()).toFixed(1);
            const zoneItem = {
                zoneName: zone.zoneName,
                siteId: zone.siteId,
                unit: "%",
                performance: performance,
                navUrl: `/Content/Dashboard/Miners/Map.aspx?SiteId=${zone.siteId}&ZoneId=${zone.zoneId}`,
                state: this.getPerformanceState(Number(performance))
            };
            const zonePerf = self.Mustache.to_html(SiteOverviewTemplates.ZONE, zoneItem);
            $("#zoneUptimeGrid").append(zonePerf);
        });
    }
    getPerformanceState(performance) {
        var perfPercent = performance * 100;
        if (perfPercent > 98) {
            return "good";
        }
        if (perfPercent > 80) {
            return "warn";
        }
        if (perfPercent > 0) {
            return "bad";
        }
        return "";
    }
}

class ReleaseNotes extends OptiFleetPage {
    constructor() {
        super();
        this.populateReleaseNotes();
    }
    populateReleaseNotes() {
        const releaseNotes = self.window.ReleaseNotes.sort((a, b) => {
            var bDate = new Date(b.releaseDate);
            var aDate = new Date(a.releaseDate);
            return bDate.getTime() - aDate.getTime();
        });
        releaseNotes.forEach((rn) => {
            const item = self.Mustache.to_html(ReleaseNotes.TEMPLATE, rn);
            $(".release-notes-container").append(item);
        });
        const topRelease = $(".release").get(0);
        $(topRelease).addClass("expanded");
    }
    toggleReleaseNotes(sender) {
        if (!$(sender).parents(".release").hasClass("expanded")) {
            $(sender).parents(".release").addClass("expanded");
            return;
        }
        $(sender).parents(".release").removeClass("expanded");
    }
}
ReleaseNotes.TEMPLATE = `
            <div class="release">
                <div class="release-header" onclick="cr.releaseNotes.toggleReleaseNotes(this);">
                    <i class="icon-chevron-right caret-icon"></i>
                    <div class="release-date">{{release}}</div>
                </div>
                <div class="notes-section">
                    {{#notes}}
                    <div class="note">
                        &bull;&nbsp;
                        {{note}}
                    </div>
                    {{/notes}}
                </div>
            </div>`;

var IssuesLabel;
(function (IssuesLabel) {
    IssuesLabel["OFFLINE"] = "Offline";
    IssuesLabel["NON_HASHING"] = "Non Hashing";
    IssuesLabel["LOW_HASHING"] = "Low Hashing";
    IssuesLabel["ERROR"] = "Error";
})(IssuesLabel || (IssuesLabel = {}));
var IssuesPanelId;
(function (IssuesPanelId) {
    IssuesPanelId["OFFLINE"] = "#offlineCount";
    IssuesPanelId["NON_HASHING"] = "#nonHashingCount";
    IssuesPanelId["LOW_HASHING"] = "#lowHashingCount";
    IssuesPanelId["ERROR"] = "#errorCount";
})(IssuesPanelId || (IssuesPanelId = {}));
class Issues extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: false, elemId: "issuesSiteSelect" });
        this.rebootMinersUrl = "/RebootMiners";
        this.issuesUrl = "/Issues";
        this.siteDetailsUrl = "/siteDetails";
        this.initialLoad = true;
        this.issueTypeFilter = "all";
        this.GRID_INFO = {
            pageable: {
                pageSizes: [10, 100, 500, 1000, 5000],
                buttonCount: 5
            },
            sortable: true,
            height: "100%",
            mobile: true,
            persistSelection: true,
            reorderable: true,
            filterable: false,
            columnMenu: false,
            resizable: true,
            columnReorder: (e) => {
                setTimeout(() => { this.setColumnOrder(e.sender.element.attr("id"), e.sender.columns); });
            },
            scrollable: true,
            editable: false,
            noRecords: {
                template: "<div>No data is available</div>"
            },
            change: this.handleMinerSelection.bind(this),
            filter: this.onFilterChange.bind(this),
            selectable: "multiple",
            columns: [
                { title: "", width: "55px", template: MinerGridColumnTemplates.getElipsisTemplate() },
                { selectable: true, width: "70px" },
                { field: "serialNumber", title: "Serial Number", width: "250px" },
                { field: "modelName", title: "Model", width: "190px" },
                { field: "ipAddress", title: "IP Address", width: "120px", template: (miner) => MinerGridColumnTemplates.getIpAddressColumnTemplate(miner), minResizableWidth: 100 },
                { field: "locationName", title: "Slot ID", width: "200px" },
                { field: "issueType", title: "Issue", width: "130px" },
                { field: "errors", title: "Error Code", width: "150px", template: MinerGridColumnTemplates.getErrorTemplate.bind(this) },
                { field: "category", title: "Error", width: "150px", hidden: true },
                { field: "combinedErrors", title: "Errors", width: "150px", hidden: true },
                { field: "minerName", title: "Miner Name", width: "170px" },
                { field: "statusName", title: "Status", width: "125px" },
                { field: "ticketCount", title: "Open Tickets", width: "135px" },
                { field: "totalTicketCount", title: "Total Tickets", width: "135px" },
                {
                    field: "hashRatePercent", title: "Hash Rate Efficiency", width: "150px", template: MinerGridColumnTemplates.getEfficiencyTemplate.bind(this),
                    sortable: {
                        compare: function (a, b) {
                            return SortUtil.alphaNumericSort(a.hashRatePercent, b.hashRatePercent);
                        }
                    }
                },
                {
                    field: "hashrate", title: "Hash Rate (10m)", width: "150px", template: MinerGridColumnTemplates.getHashrateTemplate.bind(this),
                },
                { field: "chipTempList", title: "Temp.", width: "115px", template: MinerGridColumnTemplates.getChipTempListTemplate.bind(this) },
                { field: "fans", title: "Fan Speed", width: "160px", template: MinerGridColumnTemplates.getFanSpeedTemplate.bind(this) },
                { field: "powerModeName", title: "Power Mode", width: "120px" },
                { field: "watts", title: "Power", width: "90px", template: MinerGridColumnTemplates.getPowerTemplate.bind(this) },
                {
                    field: "uptime", title: "Uptime", width: "120px", template: MinerGridColumnTemplates.getUptimeTemplate.bind(this),
                    sortable: {
                        compare: function (a, b) {
                            return SortUtil.variedTimeSort(a.uptime, b.uptime);
                        }
                    }
                },
                { field: "siteName", title: "Site", width: "200px" },
                { field: "zoneName", title: "Zone", width: "120px" },
                { field: "macAddress", title: "MAC Address", width: "180px" },
                { field: "firmwareVersion", title: "Firmware", width: "210px" },
                { field: "pool1", title: "Pool 1", width: "320px" },
                { field: "account1", title: "Account 1", width: "120px" },
                { field: "worker1", title: "Worker 1", width: "120px" },
                { field: "pool2", title: "Pool 2", width: "320px" },
                { field: "account2", title: "Account 2", width: "120px" },
                { field: "worker2", title: "Worker 2", width: "120px" },
                { field: "pool3", title: "Pool 3", width: "320px" },
                { field: "account3", title: "Account 3", width: "120px" },
                { field: "worker3", title: "Worker 3", width: "120px" },
                { field: "slotNote", title: "Slot Note", width: "120px" },
                { field: "onlineDate", title: "Online Date", width: "120px", template: MinerGridColumnTemplates.getOnlineDateTemplate.bind(this) },
            ]
        };
        this.view = this.getQueryStringValue("view");
        this.initGrid();
        this.activeGrid = $("#minerList").data("kendoGrid");
        this.initErrorsGrid();
        this.issueFilters = new IssuesFilter(this);
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        this.initialLoad = true;
        this.refreshDisabled = false;
        this.refreshFunction = this.refresh.bind(this);
        this.refreshCountdownDisabled = true;
        this.initZoneDropDown();
        this.logFetchModal = new LogFetchModal(this, "LogFetchModal");
        this.rebootModal = new OpRebootMinersModal(this, "RebootMinersModal", this.handleRebootCommand.bind(this));
        this.zoneId = document.getElementById("issuesZoneSelect").selected;
        if (this.view === "Low Hashing") {
            this.issueTypeFilter = "low hashing";
            $("#allTab").removeClass("selected");
            $("#lowHashingTab").addClass("selected");
        }
        else if (this.view === "Non Hashing") {
            $("#allTab").removeClass("selected");
            $("#nonHashingTab").addClass("selected");
            this.issueTypeFilter = "non hashing";
        }
        $("#issueMenu").kendoContextMenu({
            target: "#minerList",
            filter: ".menu-wrapper",
            animation: {
                open: { effects: "fadeIn" },
            },
            showOn: "click",
            open: this.onMinerContextMenuOpen.bind(this),
            select: this.onContextMenuSelect.bind(this),
        });
        $("#issueMenu").kendoContextMenu({
            target: "#errorList",
            filter: ".menu-wrapper",
            animation: {
                open: { effects: "fadeIn" },
            },
            showOn: "click",
            open: this.onMinerContextMenuOpen.bind(this),
            select: this.onContextMenuSelect.bind(this),
        });
    }
    initZoneDropDown() {
        return __awaiter(this, void 0, void 0, function* () {
            const zoneSelect = document.getElementById("issuesZoneSelect");
            const siteId = yield this.siteCache.getSiteId();
            this.loadZones(parseInt(siteId));
            zoneSelect.addEventListener("on-change", (e) => {
                this.zoneId = e.detail.value.split("_")[1];
                localStorage.setItem("selectedZone", this.zoneId);
                this.refresh();
                Promise.resolve();
            });
        });
    }
    reload() {
        return __awaiter(this, arguments, void 0, function* (withInitialFilter = false) {
            const siteId = yield this.siteCache.getSiteId();
            this.loadZones(parseInt(siteId));
            if (withInitialFilter && this.view) {
                yield this.loadMiners(this.view);
            }
            else {
                yield this.loadMiners("");
            }
        });
    }
    loadZones(siteId) {
        const zoneSelect = document.getElementById("issuesZoneSelect");
        this.get(`${this.siteDetailsUrl}?siteId=${siteId}`)
            .then((res) => {
            const zoneList = res.zones.map((zone) => {
                return { label: zone.zoneName, value: `zone_${zone.zoneId}` };
            });
            zoneList.unshift({ label: "All Zones", value: `zoneId_-1` });
            zoneSelect.options = zoneList;
        });
        zoneSelect.selected = 'zoneId_-1';
    }
    handleCompanyFilterChanged(companyId) {
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(siteId) {
        this.initialLoad = true;
        this.reload(true).then(() => {
            this.clearSelectedMiners();
            this.initialLoad = false;
        });
    }
    loadMiners(view) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initialLoad)
                this.toggleBusy(true);
            return this.get(this.issuesUrl + `?siteId=${yield this.siteCache.getSiteId()}&zoneId=${this.zoneId}`).then(res => {
                res.miners.filter(miner => miner.ipAddress == null).forEach(miner => miner.ipAddress = "Lease Expired");
                this.hashingFilterMiners = res.miners;
                Issues.miners = res.miners;
                this.applyFilters(view);
                const nonhashers = res.miners.filter(miner => miner.issueType === "Non Hashing" && miner.ipAddress !== null).length;
                const lowhashers = res.miners.filter(miner => miner.issueType === "Low Hashing").length;
                const errors = res.miners.filter(miner => miner.errorList.length > 0).length;
                $(".non-hashing-count-value").text(nonhashers);
                $(".low-hashing-count-value").text(lowhashers);
                $(".error-count-value").text(errors);
                this.toggleBusy(false);
            });
        });
    }
    refresh() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            yield this.reload(true);
            resolve();
        }));
    }
    populateMinersGrid(miners, view) {
        let data = {
            data: miners,
            pageSize: 100,
            schema: {
                model: {
                    id: "id"
                }
            }
        };
        // add category if on error tab
        if (this.issueTypeFilter == "errors") {
            data["group"] = { field: "category" };
        }
        const dataSource = new self.kendo.data.DataSource(data);
        this.activeGrid.setDataSource(dataSource);
    }
    initErrorsGrid() {
        $("#errorList").kendoGrid(Object.assign(Object.assign({}, this.GRID_INFO), { dataSource: {
                data: [],
                group: {
                    field: "category"
                },
                pageSize: 100,
            } }));
        const grid = $("#errorList").data("kendoGrid");
        const columnSort = JSON.parse(localStorage.getItem("issues-error-list-columns"));
        if (!columnSort) {
            return;
        }
        this.sortGridColumns(columnSort, grid);
    }
    initGrid() {
        $("#minerList").kendoGrid(Object.assign(Object.assign({}, this.GRID_INFO), { dataSource: {
                data: [],
                pageSize: 100
            } }));
        const grid = $("#minerList").data("kendoGrid");
        const columnSort = JSON.parse(localStorage.getItem("issues-list-columns"));
        if (!columnSort) {
            return;
        }
        this.sortGridColumns(columnSort, grid);
    }
    sortGridColumns(columnSort, grid) {
        columnSort.forEach((column, index) => {
            if (!column.field) {
                return;
            }
            const gridColumn = grid.columns.filter((col) => {
                return col.field === column.field;
            })[0];
            if (!gridColumn) {
                return;
            }
            grid.reorderColumn(index, gridColumn);
        });
    }
    setColumnOrder(gridId, columns) {
        if (gridId === "minerList") {
            localStorage.setItem("issues-list-columns", JSON.stringify(columns));
            return;
        }
        localStorage.setItem("issues-error-list-columns", JSON.stringify(columns));
    }
    // if none selected all should be toggled
    handleMinerSelection() {
        const grid = this.activeGrid;
        const selectedItems = grid.selectedKeyNames();
        Issues.SELECTED_MINER_IDS = selectedItems;
        $("#minerSelectedCount").text(selectedItems.length);
        if (Issues.SELECTED_MINER_IDS.length === 0) {
            return;
        }
    }
    clearSelectedMiners() {
        Issues.SELECTED_MINER_IDS = [];
        const grid = this.activeGrid;
        grid.clearSelection();
    }
    applyIssueFilters() {
        this.issueFilters.applyFilters();
    }
    applyFilters(view) {
        let filteredMiners = this.hashingFilterMiners;
        if (this.issueTypeFilter == "errors") {
            const miners = filteredMiners.filter((miner) => {
                return miner.errors != "";
            });
            filteredMiners = this.categorizeMiners(miners);
        }
        else if (this.issueTypeFilter == "non hashing") {
            filteredMiners = filteredMiners.filter((miner) => {
                return miner.issueType.toLowerCase() === this.issueTypeFilter && miner.ipAddress !== null;
            });
        }
        else if (this.issueTypeFilter == "low hashing") {
            filteredMiners = filteredMiners.filter((miner) => {
                return miner.issueType.toLowerCase() === this.issueTypeFilter;
            });
        }
        this.hashingFilterMiners = filteredMiners;
        this.applyIssueFilters();
    }
    handleRebootCommand(resp) {
        this.rebootModal.close();
        if (!resp.success) {
            this.showErrorMessage("Something went wrong sending the request to reboot the selected miners.");
            return;
        }
        this.showSuccessMessage("Miner reboot command sent!");
        this.reload();
    }
    rebootMiners() {
        this.toggleDropdownMenu("#issuesActionsDropdown");
        this.rebootModal.open(Issues.SELECTED_MINER_IDS);
    }
    createTicket() {
        const url = window.location.href.split("/Issues/Issues")[0];
        // save miners to local storage
        window.sessionStorage.setItem("ticket_cache", JSON.stringify(Issues.SELECTED_MINER_IDS));
        // redirect to create ticket with "ticket_cache=true" param
        window.open(`${url}/Administration/Tickets?ticket_cache=true`);
    }
    toggleFilterPanel(e) {
        this.issuesPanelStyler.toggleFilterPanel(e);
    }
    exportToExcel() {
        this.toggleDropdownMenu("issuesActionsDropdown");
        event.preventDefault();
        const grid = this.activeGrid;
        grid.saveAsExcel();
    }
    toggleFullscreen() {
        if (document.fullscreenElement) {
            document.exitFullscreen();
            return;
        }
        else {
            const elem = $(".main-body").get(0);
            elem.requestFullscreen();
        }
    }
    onFilterChange(e) {
        this.issuesPanelStyler.onFilterChange(e);
    }
    toggleTab(tab) {
        $(tab).addClass("selected");
        $(tab).siblings(".tab").removeClass("selected");
        $(".all-panel, .error-panel").removeClass("active");
        const filter = tab.children[0].innerHTML;
        if (filter == "All" ||
            filter == "Low Hashing" ||
            filter == "Non Hashing") {
            $(".all-panel").addClass("active");
            this.activeGrid = $("#minerList").data("kendoGrid");
        }
        else {
            $(".error-panel").addClass("active");
            this.activeGrid = $("#errorList").data("kendoGrid");
        }
        this.issueTypeFilter = filter.toLowerCase();
        this.clearSelectedMiners();
        this.hashingFilterMiners = Issues.miners;
        this.applyFilters();
    }
    // CONTEXT MENU //
    onMinerContextMenuOpen(e) {
        const minerId = parseInt($(e.target).attr("data-miner-id"));
        if (isNaN(minerId) || !minerId) {
            //todo don't show menu
            return;
        }
        const miner = this.getMiner(minerId);
        if (!miner) {
            //todo don't show menu
            return;
        }
        MinerAdmin.INDIVIDUAL_MINER_SELECTION = String(minerId);
        $("#slotMenuMinerName").text(miner.minerName);
        $("#slotMenuIp").text(miner.ipAddress);
        $("#slotMenuStatus").text(miner.statusName);
        if (miner.errorList.length > 0) {
            $("#slotMenuErrorCodeText").show();
            $("#slotMenuErrorCode").text(miner.errors);
        }
        else {
            $("#slotMenuErrorCodeText").hide();
        }
    }
    onContextMenuSelect(e) {
        const targetMinerId = MinerAdmin.INDIVIDUAL_MINER_SELECTION;
        const item = $(e.item);
        const action = item.attr("action");
        if (typeof action === "undefined" || !targetMinerId) {
            return;
        }
        switchMap(action, {
            "MINER_VIEW": () => OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${targetMinerId}`),
            "MINER_COMMENTS": () => OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${targetMinerId}&active_tab=Comments`),
            "MINER_REBOOT": () => this.openRebootModal(targetMinerId),
            "FETCH_LOGS": () => {
                this.logFetchModal.open(Issues.miners.find(m => m.id == parseInt(targetMinerId)).id);
            },
            "CREATE_TICKET": () => {
                Issues.SELECTED_MINER_IDS.push(targetMinerId);
                this.createTicket();
            },
        });
    }
    getMiner(minerId) {
        return this.hashingFilterMiners.filter((miner) => {
            return miner.id === minerId;
        })[0];
    }
    openRebootModal(targetMinerId) {
        const id = parseInt(targetMinerId);
        this.rebootModal.open([id]);
    }
    openLogModal(targetMinerId) {
        //this.logFetchModal.open(id);
    }
    // for error view, adds categories and duplicates miners to show in each category they fall in
    categorizeMiners(miners) {
        var categorizedMiners = [];
        miners.forEach(m => {
            m.errorList.forEach(e => {
                const newMiner = Object.assign(Object.assign({}, m), { category: `${e.code} - ${e.errorMsg}` });
                categorizedMiners.push(newMiner);
            });
        });
        return categorizedMiners;
    }
}
Issues.SELECTED_MINER_IDS = [];

class IssuesFilter extends OptiFleetPage {
    constructor(issues) {
        super();
        this.issues = issues;
        this.storedFiltersSelector = "issuesSelectedFilters";
        this.miners;
        this.minerNameFilter;
        this.modelNameFilter;
        this.serialNumberFilter;
        this.siteNameFilter;
        this.locationIdFilter;
        this.ipAddressFilter;
        this.firmwareFilter;
        this.slotNoteFilter;
        this.macAddressFilter;
        this.errorCodeFilter;
        // show means the filter is visible in the filter section
        this.filters = [
            { label: "Miner Name", id: "minerName", show: true, options: [] },
            { label: "Model", id: "modelName", show: false, options: [] },
            { label: "Serial Number", id: "serialNumber", show: false, options: [] },
            { label: "Slot ID", id: "locationName", show: false, options: [] },
            { label: "IP Address", id: "ipAddress", show: false, options: [] },
            { label: "Error", id: "combinedErrors", show: false, options: [] },
            { label: "Firmware", id: "firmwareVersion", show: false, options: [] },
            { label: "Pool 1", id: "pool1", show: false, options: [] },
            { label: "Account 1", id: "account1", show: false, options: [] },
            { label: "Worker 1", id: "worker1", show: false, options: [] },
            { label: "Pool 2", id: "pool2", show: false, options: [] },
            { label: "Account 2", id: "account2", show: false, options: [] },
            { label: "Worker 2", id: "worker2", show: false, options: [] },
            { label: "Pool 3", id: "pool3", show: false, options: [] },
            { label: "Account 3", id: "account3", show: false, options: [] },
            { label: "Worker 3", id: "worker3", show: false, options: [] },
            { label: "Slot Note", id: "slotNote", show: false, options: [] },
            { label: "MAC Address", id: "macAddress", show: false, options: [] }
        ];
        this.activeFilters = {
            minerName: "",
            modelName: "",
            serialNumber: "",
            siteName: "",
            locationId: "",
            ipAddress: "",
            status: ""
        };
        this.init();
    }
    init() {
        this.initFilters();
        let opFilters = [];
        this.filters.forEach(filter => {
            const filterName = `${filter.id}Filter`;
            this[filterName] = new OpFilter(filter.id, this.filterMiners.bind(this), this.clearFilter.bind(this), filter.options);
            opFilters.push(this[filterName]);
            if (!filter.show) {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
        });
        new SelectFilters("moreFilters", this.filters, this.changeActiveFilters.bind(this));
        new ClearFilters("clearFilters", opFilters);
    }
    initFilters() {
        const storedFiltersStr = localStorage.getItem(this.storedFiltersSelector);
        let storedFilters;
        try {
            storedFilters = JSON.parse(storedFiltersStr);
        }
        catch (e) {
            return;
        }
        if (!storedFilters) {
            return;
        }
        storedFilters.forEach(storedFilter => {
            // if is filter
            if (storedFilter.hasOwnProperty("id") && storedFilter.hasOwnProperty("label") && storedFilter.hasOwnProperty("show")) {
                var filter = this.filters.find((filter) => filter.id === storedFilter.id);
                if (filter) {
                    filter.show = storedFilter.show;
                }
            }
        });
    }
    filterMiners(formVal, propertyVal) {
        this.activeFilters[propertyVal] = formVal;
        let filteredMiners = this.issues.hashingFilterMiners;
        if (!filteredMiners) {
            return;
        }
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (!formVal || formVal === "" || formVal.length === 0) {
                return;
            }
            if (isTextInput) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        this.issues.populateMinersGrid(filteredMiners);
    }
    applyFilters(view) {
        let filteredMiners = this.issues.hashingFilterMiners;
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (isTextInput) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        var gridView = view ? view : "";
        this.issues.populateMinersGrid(filteredMiners, gridView);
    }
    clearFilter(id) {
        this.activeFilters[id] = "";
        this.filterMiners(id, "");
    }
    changeActiveFilters(newFilters) {
        this.filters = newFilters;
        this.filters.forEach(filter => {
            let filterRemoved = false;
            // If the filter is active and it's being remove
            if ($(`[c-id=${filter.id}]`).hasClass("active") && filter.show === false) {
                // Then clear the active state and remove the filting on the miner grid
                this[`${filter.id}Filter`].deactivateFilter();
                this.activeFilters[filter.id] = "";
                filterRemoved = true;
            }
            if (filter.show) {
                $(`[c-id=${filter.id}]`).removeClass("hide");
            }
            else {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
            if (filterRemoved) {
                this.filterMiners("", "");
            }
        });
        localStorage.setItem(this.storedFiltersSelector, JSON.stringify(this.filters));
    }
}

class Login extends OptiFleetService {
    constructor() {
        super();
        $("#username").focus();
        this.checkRememberMe();
    }
    checkRememberMe() {
        const rememberMe = JSON.parse(localStorage.getItem("RememberMe"));
        if (!rememberMe) {
            $("#username").focus();
            $("#rememberMeSwitch").prop("checked", false);
            return;
        }
        $("#username").val(rememberMe.username);
        $("#rememberMeSwitch").prop("checked", true);
        $("#password").focus();
    }
    hasCredentials() {
        const username = $("#username").val().trim().length;
        const password = $("#password").val().trim().length;
        if (username > 0 && password > 0) {
            return true;
        }
        return false;
    }
    login() {
        if (!this.hasCredentials()) {
            $("#invalidUserNamePass").removeClass("hide");
            return;
        }
        $("#invalidUserNamePass").addClass("hide");
        $("#lockedOut").addClass("hide");
        this.toggleLoginBusy(true);
        const username = btoa($("#username").val());
        const password = btoa($("#password").val());
        const selectedCompany = JSON.parse(localStorage.getItem("selectedCompany"));
        const loginData = {
            userName: username,
            password: password,
            tzOffset: new Date().getTimezoneOffset() * -1,
            selectedCompanyId: selectedCompany,
            isMobile: this.isMobile()
        };
        this.post("/login", loginData)
            .then((resp) => {
            if (!resp.result.isAuthenticated) {
                this.toggleLoginBusy(false);
                if (resp.result.isTooManyAttempts || resp.result.isLockedOut) {
                    $("#lockedOut").removeClass("hide");
                    return;
                }
                $("#invalidUserNamePass").removeClass("hide");
                return;
            }
            SessionHandler.clearLocalStorage();
            SessionHandler.setInitialTimeLeft(resp.result.timeLeft);
            localStorage.setItem("OptiFleetID", resp.result.userId.toString());
            if (!resp.result.selectedCompanyId) {
                window.location.reload();
                return;
            }
            localStorage.setItem("selectedCompany", resp.result.selectedCompanyId.toString());
            const userObj = {
                userId: resp.result.userIdInteger,
                username: this.getUsername()
            };
            localStorage.setItem("user", JSON.stringify(userObj));
            if ($("#rememberMeSwitch").prop("checked") === true) {
                localStorage.setItem("RememberMe", this.getRememberMeJson());
            }
            else {
                localStorage.removeItem("RememberMe");
            }
            window.location.reload();
        });
    }
    getUsername() {
        return $("#username").val();
    }
    getRememberMeJson() {
        const rememberMe = {
            rememberMe: $("#rememberMeSwitch").prop("checked"),
            username: this.getUsername()
        };
        return JSON.stringify(rememberMe);
    }
    toggleLoginBusy(isBusy) {
        if (!isBusy) {
            $(".login-busy").removeClass("active");
            return;
        }
        $(".login-busy").addClass("active");
    }
    isMobile() {
        if (window.PointerEvent && ('maxTouchPoints' in navigator)) {
            if (navigator.maxTouchPoints > 0) {
                return true;
            }
        }
        if (window.matchMedia && window.matchMedia("(any-pointer:coarse)").matches) {
            return true;
        }
        if ("ontouchstart" in document.documentElement) {
            return true;
        }
        return false;
    }
    forgotPassword() {
        window.location.href = "/Content/Login/ForgotPassword.aspx";
    }
}

class MinerCommentsPanel extends OptiFleetPage {
    constructor(minerId, canEdit = false) {
        super();
        this.canEdit = canEdit;
        this.url = "/MinerHistory";
        this.saveNoteUrl = "/MinerNote";
        this.minerId = minerId;
        this.commentBoxManager = new OpCommentBox();
        this.commentBoxManager.patchHandler = this.editComment.bind(this);
        this.commentBoxManager.postHandler = this.saveComment.bind(this);
        this.commentBoxManager.deleteHandler = this.deleteComment.bind(this);
        this.loadComments();
    }
    setMinerId(minerId) {
        this.minerId = minerId;
        return this;
    }
    loadComments() {
        this.get(`${this.url}?MinerId=${this.minerId}`).then((resp) => {
            this.populateComments(resp.notes);
        });
        return this;
    }
    populateComments(comments) {
        this.notes = comments;
        const currentUser = JSON.parse(localStorage.getItem("user"));
        const now = window.moment(Date.now());
        const commentsList = $("#commentList");
        commentsList.empty();
        comments.forEach((comment, index) => {
            let exactTime = window.moment(comment.dateCreated).format('MMMM Do YYYY, h:mm:ss a');
            let elapsedTime = window.moment.duration(now.diff(comment.dateCreated)).humanize();
            let user = {
                userId: comment.userId,
                username: comment.user,
            };
            const data = {
                index,
                user,
                commentId: comment.minerNoteId,
                initiator: comment.user,
                contents: comment.note,
                exactTime: exactTime,
                elapsedTime: elapsedTime
            };
            const commentBoxType = (currentUser === null || currentUser === void 0 ? void 0 : currentUser.userId) === user.userId ? CommentBoxType.Edit : CommentBoxType.ReadOnly;
            this.commentBoxManager.appendTemplate(commentsList, commentBoxType, data);
        });
        const writeData = {
            index: -1,
            user: currentUser !== null && currentUser !== void 0 ? currentUser : undefined
        };
        this.canEdit && this.commentBoxManager.appendTemplate(commentsList, CommentBoxType.Write, writeData);
    }
    saveComment(elId, e) {
        const comment = $(`#${elId}`).text().trim();
        if (comment === "")
            return;
        const savedata = {
            minerId: this.minerId,
            note: comment,
        };
        this.post(this.saveNoteUrl, savedata).then(() => {
            this.loadComments();
        });
    }
    editComment(commentId, comment) {
        if (comment === "")
            return;
        const savedata = {
            minerId: this.minerId,
            minerNoteId: commentId,
            note: comment
        };
        this.post(this.saveNoteUrl, savedata).then(() => {
            this.loadComments();
        });
    }
    deleteComment(commentId, e) {
        this.confirm("Delete Note", "Are you sure you want to delete this note?", () => {
            const deletedata = {
                minerNoteId: commentId
            };
            this.delete(this.saveNoteUrl, deletedata).then((resp) => {
                if (resp.success === false) {
                    let message = "Unable to delete note";
                    if (resp.message) {
                        message = `${message}: ${resp.message}`;
                    }
                    this.showErrorMessage(message);
                }
                this.loadComments();
            });
        });
    }
}

class MinerFanSpeedGraph {
    constructor() {
        this.chart = new LineChart([MinerFanSpeedGraph.fanSpeedQuery], "#fanSpeedBusy");
        this.chart.elementSelector = "fanSpeedChart";
        this.chart.title = "Fan Speed";
        this.chart.extraOptions.export = {
            csv: {
                filename: "Miner Fan Speed",
                headerCategory: "Time",
                headerValue: "Fan Speed (rpm)",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.extraOptions.autoColor = true;
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        try {
            graphData.forEach((resp) => {
                resp.data.result.forEach((result) => {
                    serieData.push({
                        name: result.metric.fanName,
                        data: result.values
                    });
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.series = serieData;
        $(".fanSpeed-chart").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return `${val} RPM`;
        // toFixed(0) breaks the tooltip when selecting a specific metric in legend (apex charts bug?)
        //return `${val.toFixed(0)} RPM`;
    }
}
MinerFanSpeedGraph.fanSpeedQuery = "/MinerFanSpeed/Graph";

class MinerHashrateGraph {
    constructor() {
        this.chart = new LineChart([MinerHashrateGraph.hashrateQuery, MinerHashrateGraph.theoreticalQuery], "#hashrateBusy");
        this.hashingType = 1;
        this.chart.elementSelector = "hashrateChart";
        this.chart.title = "Hash Rate";
        this.chart.extraOptions.export = {
            csv: {
                filename: "Miner Hash Rate",
                headerCategory: "Time",
                headerValue: "Hash Rate",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        try {
            graphData.forEach((resp) => {
                serieData.push({
                    name: (resp.internalName === "hashrate" ? "Hash Rate" : "Expected Hash Rate"),
                    data: resp.data.result[0].values
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.series = serieData;
        $(".hashrate-chart").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return HashrateUtil.parseHashrate(val, this.hashingType);
    }
    setHashingType(hashingType) {
        const changed = this.hashingType != hashingType;
        this.hashingType = hashingType;
        if (changed) {
            this.chart.render();
        }
    }
}
MinerHashrateGraph.hashrateQuery = "/MinerHashrate";
MinerHashrateGraph.theoreticalQuery = "/MinerTheoreticalHashrate";

const PROPERTIES = {
    "name": "Miner Name",
    "model": "Model",
    "serialNumber": "Serial #",
    "ipAddress": "IP",
    "poolWorker": "Worker Name",
};
class MinerLinkModal extends OptiFleetPage {
    constructor(minerId) {
        super();
        this.minerStatsUrl = "/MinerStats?id=";
        this.minersIpUrl = "/MinerIps";
        this.linkMinerUrl = "/LinkMiners";
        this.modalId = "#LinkMinerModal";
        this.minerId = minerId;
        this.init();
    }
    init() {
        this.getMiner(this.minerId).then(miner => {
            this.minerOne = miner;
            this.buildIpList();
            $(".modal-title").text('Link Miners');
            $(".modal-footer-text").text("Accepting will delete the Previous miner and change the Updated miner's location.");
            this.fillProperties();
        });
    }
    getMiner(minerId) {
        return new Promise((resolve, reject) => {
            if (!minerId) {
                reject("No Miner Id Given");
            }
            this.get(this.minerStatsUrl + minerId).then(res => {
                resolve(res);
            });
        });
    }
    open() {
        this.reset();
        this.fillProperties();
        $(this.modalId).show();
    }
    load(minerId) {
        this.getMiner(minerId).then(miner => {
            this.minerTwo = miner;
            this.reset();
            this.fillProperties();
        });
    }
    reset() {
        $(".modal-content").empty();
    }
    close() {
        this.reset();
        $(this.modalId).hide();
    }
    save() {
        if (!this.minerTwo)
            return;
        const minerIds = this.sortMinersByDate().map(m => m.id);
        // call api
        this.toggleBusy(true);
        this.post(this.linkMinerUrl, { MinerIds: minerIds }).then((resp) => {
            this.toggleBusy(false);
            if (!resp.success) {
                this.showErrorMessage("Something went wrong saving your settings.");
                return;
            }
            this.close();
            this.showSuccessMessage("Settings saved!");
            // handle save
            const [_Old, New] = this.sortMinersByDate();
            this.onMinerLink(New);
        });
    }
    onMinerChanged() {
        let id = $("#ipFilterModal").data("kendoDropDownList");
        let minerId = parseInt(id.value());
        this.load(minerId);
    }
    populateIpList(resp) {
        if (resp.ips.length === 0) {
            this.showNullState("There aren't any miners setup yet.");
            return;
        }
        this.hideNullState();
        const ipFilter = $("#ipFilterModal").data("kendoDropDownList");
        const dataSource = new self.kendo.data.DataSource({
            data: resp.ips.filter(entry => entry.id !== this.minerId)
        });
        ipFilter.value(this.minerId);
        ipFilter.setDataSource(dataSource);
    }
    buildIpList() {
        var _a;
        $("#ipFilterModal").kendoDropDownList({
            dataTextField: "ip",
            dataValueField: "id",
            dataSource: [],
            filter: "contains",
            height: 200,
            autoWidth: true,
            value: (_a = this.minerId) === null || _a === void 0 ? void 0 : _a.toString(),
            virtual: {
                itemHeight: 26,
                valueMapper: (options) => {
                    this.convertValues(options);
                }
            },
            change: this.onMinerChanged.bind(this)
        });
        this.loadMinerIps();
    }
    loadMinerIps() {
        this.get(this.minersIpUrl)
            .then((resp) => {
            this.populateIpList(resp);
        });
    }
    convertValues(value) {
        var data = {};
        value = $.isArray(value) ? value : [value];
        for (var idx = 0; idx < value.length; idx++) {
            data["values[" + idx + "]"] = value[idx];
        }
        return data;
    }
    sortMinersByDate() {
        var _a, _b, _c, _d;
        let Old;
        let New;
        if (((_a = this.minerOne) === null || _a === void 0 ? void 0 : _a.dateCreated) <= ((_b = this.minerTwo) === null || _b === void 0 ? void 0 : _b.dateCreated)) {
            Old = this.minerOne;
            New = this.minerTwo;
        }
        else if (((_c = this.minerOne) === null || _c === void 0 ? void 0 : _c.dateCreated) > ((_d = this.minerTwo) === null || _d === void 0 ? void 0 : _d.dateCreated)) {
            Old = this.minerTwo;
            New = this.minerOne;
        }
        else {
            Old = this.minerOne;
            New = null;
        }
        return [Old, New];
    }
    fillProperties() {
        const [Old, New] = this.sortMinersByDate();
        let descEls = `<div class="swap-receipt-item no-show">Description</div>`;
        let oldEls = `<div class="swap-receipt-item head">Previous</div>`;
        const icon = `<i id="modalUpdateIcon" class="icons icon-arrow-big-right-dash"></i>`;
        let newEls = `<div class="swap-receipt-item head">Updated</div>`;
        Object.entries(PROPERTIES).forEach(([prop, name]) => {
            descEls += `<div class="swap-receipt-item">${name}:</div>`;
            oldEls += `<div class="swap-receipt-item old">${Old[prop]}</div>`;
            newEls += `<div class="swap-receipt-item new ${New ? "" : "no-show"}">${New ? New[prop] : null}</div>`;
        });
        $(".modal-content").append(this.buildModalContent(descEls, oldEls, icon, newEls));
    }
    buildModalContent(descEls, oldEls, icon, newEls) {
        return `<div  class="miner-swap-receipt">
            <ul class='swap-receipt descriptions'>${descEls}</ul>
            <ul class='swap-receipt values'>${oldEls}</ul>
            <div class='swap-receipt icons'>${icon}</div>
            <ul class='swap-receipt values'>${newEls}</ul>
            </div>`;
    }
}

class MinerMetricsPanel extends OptiFleetService {
    constructor(minerId) {
        super();
        this.minerId = minerId;
        this.hashrateUrl = "/MinerHashrate";
        this.expectedhashrateQuery = "/MinerTheoreticalHashrate";
        this.fanspeedUrl = "/MinerFanSpeed/Graph";
        this.chipTempUrl = "/MinerTemperature";
        this.uptimeUrl = "/MinerOnline";
        this.hashrateChart = new StyledLineChart("hashrateChart", "Hash Rate");
        this.hashrateChart.formatter = (val) => HashrateUtil.parseHashrate(val, 1);
        this.fanSpeedChart = new StyledLineChart("fanSpeedChart", "Fan Speed", { withLegend: true });
        this.fanSpeedChart.formatter = (val) => `${val} rpm`;
        this.chipTempChart = new StyledLineChart("pcbTempChart", "Hashboard Temperature", { withLegend: true });
        this.chipTempChart.formatter = (val) => `${val} Â°C`;
        this.uptimeChart = new StyledLineChart("uptimeChart", "Uptime");
        this.uptimeChart.formatter = (val) => val > 0 ? "Online" : "Offline";
        this.datePicker = new DatePicker("#datePicker", this.loadCharts.bind(this));
    }
    loadCharts() {
        return __awaiter(this, arguments, void 0, function* (params = this.datePicker.refreshParams()) {
            return Promise.all([this.loadHashrate(params), this.loadFanSpeed(params), this.loadChipTemp(params), this.loadUptime(params)]);
        });
    }
    reloadCharts() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.datePicker.isAbsoluteRange)
                this.loadCharts(this.datePicker.refreshParams());
        });
    }
    loadHashrate(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const hrPromise = this.post(this.hashrateUrl, Object.assign({ id: this.minerId }, params));
            const expectedHrPromise = this.post(this.expectedhashrateQuery, Object.assign({ id: this.minerId }, params));
            return Promise.all([hrPromise, expectedHrPromise]).then(res => {
                this.hashrateChart.populateChartData(res);
            });
        });
    }
    loadFanSpeed(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.post(this.fanspeedUrl, Object.assign({ minerIds: [this.minerId] }, params)).then((res) => {
                this.fanSpeedChart.populateChartData([res]);
            });
        });
    }
    loadChipTemp(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.post(this.chipTempUrl, Object.assign({ id: this.minerId }, params)).then((res) => {
                this.chipTempChart.populateChartData([res]);
            });
        });
    }
    loadUptime(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.post(this.uptimeUrl, Object.assign({ id: this.minerId }, params)).then((res) => {
                this.uptimeChart.populateChartData([res]);
            });
        });
    }
}

class MinerOnlineGraph {
    constructor() {
        this.chart = new LineChart([MinerOnlineGraph.onlineQuery], "#onlineBusy");
        this.chart.elementSelector = "onlineChart";
        this.chart.title = "Online Status";
        this.chart.extraOptions.tickAmountY = 1;
        this.chart.extraOptions.export = {
            csv: {
                filename: "Online Status",
                headerCategory: "Time",
                headerValue: "Online",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        try {
            serieData.push({
                name: "Status:",
                data: graphData[0].data.result[0].values
            });
        }
        catch (_a) {
            serieData.push({
                name: "Status:",
                data: []
            });
        }
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.series = serieData;
        $(".online-chart").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        if (Math.round(val) === 1) {
            return "Online";
        }
        if (Math.round(val) === 0) {
            return "Offline";
        }
        return "";
    }
}
MinerOnlineGraph.onlineQuery = "/MinerOnline";

class MinerStatPanel extends OptiFleetService {
    constructor() {
        super();
        this.minerStatsUrl = "/MinerStats?id=";
    }
    load() {
        if (!this.minerId) {
            return;
        }
        return this.get(this.minerStatsUrl + this.minerId)
            .then((resp) => {
            this.populateStats(resp);
            this.onStatsLoaded(resp);
        });
    }
    populateStats(resp) {
        let pcbTemps = resp.pcbTemps
            .sort((a, b) => a.hashboard < b.hashboard ? a.hashboard : b.hashboard)
            .map(x => x.temperature)
            .join("/<wbr>");
        $("#minerName").text(resp.name);
        $("#lblMinerName").text(resp.name);
        $("#model").text(resp.model);
        $("#company").text(resp.customer);
        $("#subcustomer").text(resp.subcustomerName);
        $("#siteId").val(resp.siteId);
        $("#facility").text(resp.facility);
        $("#rowSection").text(resp.rowSection);
        $("#rackShelf").text(resp.rackShelf);
        $("#position").text(resp.position);
        $("#ipAddress").attr("href", `http://${resp.ipAddress}`).text(resp.ipAddress);
        $("#status").text(resp.status);
        $("#status").removeClass("op-label-value online").addClass(`op-label-value ${resp.status.toLowerCase()}`);
        $("#hashrateStat").text(this.parseHashrate(resp.hashingTypeId, resp.hashrate));
        $("#fanSpeedStat").html("<p>" + resp.fanSpeeds.join("/<wbr>") + "</p>");
        $("#tempStat").html("<p>" + pcbTemps + "</p>");
        $("#uptimeStat").text(resp.uptime);
        $("#pool").text(resp.poolUrl);
        $("#account").text(resp.poolAccount);
        $("#worker").text(resp.poolWorker);
        this.handleSerialNumber(resp);
        const online = resp.status.toLowerCase() === "online";
        this.onOnlineStatusLoaded(online);
    }
    handleSerialNumber(resp) {
        if (!resp.isDiscoveredSerialNumber) {
            $("#serialNumber").text(resp.serialNumber);
            return;
        }
        $("#serialNumber").html(`<div title="This serial number was pulled from this miners API.  Edit this miner to update the serial number.">${resp.serialNumber}</div>`);
    }
    parseHashrate(hashingType, val) {
        return HashrateUtil.parseHashrate(val, hashingType);
    }
}

class MinerTemperatureGraph {
    constructor() {
        this.chart = new LineChart([MinerTemperatureGraph.tempQuery], "#tempBusy");
        this.chart.elementSelector = "tempChart";
        this.chart.title = "Chip Temperature";
        this.chart.extraOptions.export = {
            csv: {
                filename: "Miner Chip Temperature",
                headerCategory: "Time",
                headerValue: "Temperature",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
        this.chart.onGraphDataLoaded = this.onGraphDataReceived.bind(this);
    }
    onGraphDataReceived(graphData) {
        const serieData = [];
        try {
            serieData.push({
                name: "Temp:",
                data: graphData[0].data.result[0].values
            });
        }
        catch (_a) {
            return;
        }
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.series = serieData;
        $(".temp-chart").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return `${val.toFixed(1)} C`;
    }
}
MinerTemperatureGraph.tempQuery = "/MinerTemperature";

class MinerTicketPanel extends OptiFleetPage {
    constructor() {
        super();
        this.url = "/Ticketing";
        this.loader = new TicketPropertiesLoader();
        this.init();
    }
    init() {
        this.loadTicketProperties();
    }
    loadTicketProperties() {
    }
    showDetails(ticketId) {
        OptiFleetMaster.openTab(`Administration/Tickets?ticket_id=${ticketId}`);
    }
    reloadTickets() {
        this.loadTickets(this.minerId);
    }
    loadTickets(minerId) {
        this.toggleBusy(true);
        this.minerId = minerId;
        this.get(`${this.url}?minerId=${this.minerId}`)
            .then((data) => {
            this.populateTicketsList(data);
            this.toggleBusy(false);
        });
    }
    populateTicketsList(data) {
        $("#noTicketsMsg").removeClass('active');
        if (data.tickets.length === 0) {
            $("#noTicketsMsg").addClass('active');
            return;
        }
        const ticketListEl = $("#ticketList");
        ticketListEl.empty();
        const currentTime = window.moment(Date.now());
        for (const ticket of data.tickets) {
            const elId = `ticket${ticket.id}`;
            const ticketCreatedDate = window.moment(ticket.created);
            const timeDiff = currentTime.diff(ticketCreatedDate);
            const ticketTemplateData = Object.assign(Object.assign({}, ticket), { dateCreatedFormatted: window.moment.duration(timeDiff).humanize(), iconStatus: document.querySelector(`[icon-name=icon${ticket.status.replace(/\s/g, "")}]`).innerHTML, elId });
            const ticketListTemplate = document.getElementById("ticketListTemplate").innerHTML;
            const template = self.Mustache.to_html(ticketListTemplate, ticketTemplateData);
            $("#ticketList").append(template);
            $(`#${elId}`).click(this.showDetails.bind(this, ticket.id));
        }
    }
}

class MinerViewService extends OptiFleetService {
    constructor() {
        super();
        this.minerUrl = "/Miners?siteId={site}";
    }
    getMiners(companyId, siteId) {
        const url = this.minerUrl.replace("{site}", siteId.toString());
        return this.get(url);
    }
}

class AggTemperatureGraph {
    constructor() {
        this.chart = new LineChart(null, "#aggTempBusy");
        this.isLoading = false;
        this.chart.elementSelector = "aggTempChart";
        this.chart.title = "Sensor Temperatures";
        this.chart.extraOptions.autoColor = true;
        this.chart.extraOptions.lineType = "line";
        this.chart.extraOptions.formatter = (val, index) => {
            return Math.round(val);
        };
        this.chart.extraOptions.legend = {
            show: false,
        };
        this.chart.extraOptions.tooltip = {
            shared: true,
            intersect: false,
            custom: (opts) => {
                const timeStamp = opts.w.globals.seriesX[opts.seriesIndex][opts.dataPointIndex];
                const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                const dayStart = window.moment(new Date(timeStamp)).startOf('day');
                const sensorItems = opts.w.globals.seriesNames.map((seriesName, seriesIndex) => {
                    const color = opts.w.globals.colors[seriesIndex];
                    const value = opts.series[seriesIndex][opts.dataPointIndex];
                    const tempTextVariant = value >= SensorsReport.temperatureThreshold ? "error" : "primary";
                    const highestTempTime = this.highestTemps[seriesName][dayStart.toString()].time;
                    const highestTemp = this.highestTemps[seriesName][dayStart.toString()].temp;
                    return `
                        <m-stack horizontal align-center>
                            <m-text as="span" style="width: 10px; height: 10px; background-color: ${color};"></m-text>
                            <m-text as="span">${seriesName}: <m-text as="span" variant=${tempTextVariant}>${value}&deg;F</m-text></m-text>
                            <m-text as="span">(Highest ${highestTemp}&deg;F @${highestTempTime})</m-text>
                        </m-stack>
                    `;
                });
                return `<m-stack space="none" class="m-box is-variant-ghost has-space-xs">
                        <m-stack horizontal space-between align-center>
                            <m-text>${time}</m-text>
                            <m-text>Temperature</m-text>
                        </m-stack>
                        <div class="m-divider has-space-xs"></div>
                        <m-stack space="xs">
                            ${sensorItems.join("")}
                        <m-stack>
                    </m-stack>
                `;
            }
        };
        this.chart.extraOptions.export = {
            csv: {
                filename: "Sensor Temperatures",
                headerCategory: "Time",
                headerValue: "Temperatures",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
    }
    setSiteId(siteId) {
        this.siteId = siteId;
    }
    loadChartData(params) {
        if (this.isLoading) {
            return;
        }
        this.isLoading = true;
        this.chart.toggleGraphBusy(true);
        this.chart.post(AggTemperatureGraph.query, Object.assign(Object.assign({}, params), { siteId: this.siteId }))
            .then((response) => {
            this.chart.toggleGraphBusy(false);
            if (!response.data.result[0]) {
                response.data.result.push({
                    values: [],
                    metric: {
                        __name__: ""
                    }
                });
            }
            this.graphData = response;
            this.populateChartData();
        });
    }
    populateChartData() {
        const seriesData = [];
        try {
            this.graphData.data.result.sort((a, b) => {
                return a.metric["name"].localeCompare(b.metric["name"]);
            });
            this.graphData.data.result.forEach((result, idx) => {
                if (SensorsReport.zoneNames.length && !SensorsReport.zoneNames.includes(result.metric["facility"])) {
                    return;
                }
                seriesData.push({
                    name: result.metric.name,
                    data: result.values
                });
            });
        }
        catch (_a) {
            return;
        }
        this.highestTemps = {};
        for (const series of seriesData) {
            for (let i = series.data.length - 1; i >= 0; i--) {
                const data = series.data[i];
                const timestamp = data[0];
                const temp = Number(data[1]);
                const timestampDayStart = window.moment(timestamp).startOf("day");
                if (this.highestTemps[series.name] === undefined) {
                    this.highestTemps[series.name] = {};
                }
                if (this.highestTemps[series.name][timestampDayStart.toString()] === undefined) {
                    this.highestTemps[series.name][timestampDayStart.toString()] = { temp: 0, time: "" };
                }
                if (temp >= this.highestTemps[series.name][timestampDayStart.toString()].temp) {
                    this.highestTemps[series.name][timestampDayStart.toString()] = { temp: temp, time: window.moment(new Date(timestamp)).format("hh:mmA") };
                }
            }
        }
        this.isLoading = false;
        this.chart.series = seriesData;
        $(".agg-temp-chart").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return val.toString();
    }
}
AggTemperatureGraph.query = "/SensorPushAggTemperature";

class ConsumptionGraph {
    constructor() {
        this.chart = new LineChart(null, "#consumptionBusy");
        this.chart.elementSelector = "consumptionGraph";
        this.chart.title = "Power Consumption";
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.extraOptions.autoColor = true;
        this.chart.extraOptions.export = {
            csv: {
                filename: "Power Consumption",
                headerCategory: "Time",
                headerValue: "Consumption",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
    }
    populateChartData(graphData) {
        const serieData = [];
        try {
            graphData.forEach((resp) => {
                if (resp.data.result.length === 0) {
                    return;
                }
                serieData.push({
                    name: (resp.internalName === "meteredConsumption" ? "Metered" : "Estimated"),
                    data: resp.data.result[0].values
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.series = serieData;
        $(".consumption-graph").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return PowerConverter.parsePower(val);
    }
}
ConsumptionGraph.overallQuery = "/OverallHashrate";
ConsumptionGraph.theoreticalQuery = "/TheoreticalHashrate";

class KmrGraph {
}
KmrGraph.TEMPLATE = `<div class="m-stack chart">
                                    <div class="metric-header m-stack is-horizontal has-space-between">
                                        <h1 id="header" class="m-heading is-size-l">{{siteName}}</h1>
                                        <div class="m-stack is-horizontal is-align-center">
                                            <m-icon name="home" id="chart{{siteId}}Home" size="m" class="home-icon"></m-icon>
                                            <div class="tooltip">
                                                <m-icon class="info-icon" name="info"></m-icon>
                                                <span id="tooltiptext" class="tooltiptext">Displays site metrics over a period of time. Time periods during excused events will be excluded from the Average Values calculations</span>
                                            </div>
                                        </div>
                                    </div>
                                    <span id="chart{{siteId}}" class="canvas"></span>
                                    <div id="Labels{{siteId}}" class="chart-x-axis">
                                        <div id="chart{{siteId}}StartLabel" class="m-text is-tertiary">--</div>
                                        <div id="chart{{siteId}}EndLabel" class="m-text is-tertiary end-label">--</div>
                                    </div>
                                    <div id="chart{{siteId}}AnnotationEditor" class="legend annotation-editor m-stack is-horizontal m-gap-s" style="display:none;" >
                                        <div class="m-container" style="padding: revert;">
                                            <div class="m-box" style="overflow: visible;">

                                                <div class="m-stack is-horizontal is-align-center has-space-between">
                                                    <div class="m-stack has-space-xs">
                                                        <span class="m-text is-size-s">
                                                            Edit Curtailment
                                                        </span>
                                                    </div>
                                                    <div class="m-stack has-space-xs">
                                                        <div class="site-name ">
                                                            <div class="tooltip m-stack is-horizontal">
                                                                <span class="site-name m-label m-stack is-horizontal has-space-xs"/>
                                                                <span class="tooltiptext" />
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <div class="m-stack is-horizontal is-align-center" >
                                                        <div class="m-stack prev-annotation">
                                                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-left"><path d="m15 18-6-6 6-6"/></svg>
                                                        </div>
                                                        <div class="m-stack has-space-xs">
                                                            <p class="m-label">Start</p>
                                                        </div>
                                                        <div class="m-stack has-space-xs">
                                                            <input class="start-date-input m-input" type="text"></input>
                                                        </div>
                                                        <div class="m-stack has-space-xs">
                                                            <input class="start-time-input m-input" type="text"></input>
                                                        </div>
                                                        <div class="m-stack has-space-xs">
                                                            <input class="end-date-input m-input" type="text"></input>
                                                        </div>
                                                        <div class="m-stack has-space-xs">
                                                            <input class="end-time-input m-input" type="text"></input>
                                                        </div>
                                                        <div class="m-stack has-space-xs">
                                                            <p class="m-label">End</p>
                                                        </div>
                                                        <div class="m-stack next-annotation">
                                                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-right"><path d="m9 18 6-6-6-6"/></svg>
                                                        </div>
                                                    </div>
                                                    <div class="m-stack save-button is-align-center has-space-between">
                                                        <button class="m-button save" autocomplete="off" data-form-type="other" disabled="disabled" >
		                                                    Save
	                                                    </button>
                                                    </div>
                                                    <div class="m-stack close">
                                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div id="chart{{siteId}}Legend" class="legend m-stack is-horizontal m-gap-s">

                                    </div>
                                </div>

                                <script id="chart{{siteId}}LegendItemTemplate" type="x-tmpl-mustache">
                                    {{=<%  %>=}}
                                    <div id="{{elId}}" class="m-stack is-horizontal m-chip m-text is-size-s">
                                        <div class="legend-chip-dot" style="background: {{color}};"></div>
                                        <p>{{name}}</p>
                                    </div>
                                    <%={{ }}=%>
                                </script>

                                <script id="chart{{siteId}}LegendAnnotationTemplate" type="x-tmpl-mustache">
                                    {{=<%  %>=}}
                                    <div id="{{elId}}" class="m-stack is-align-center is-horizontal m-text is-size-s is-tertiary">
                                        <div class="legend-chip-dot" style="background: {{color}};"></div>
                                        <p>{{name}}</p>
                                    </div>
                                    <%={{ }}=%>
                                </script>`;

class CurtailmentEventsPanel extends OptiFleetService {
    constructor() {
        super();
        this.init();
    }
    init() {
        $("#curtailmentGrid").kendoGrid({
            dataSource: {
                data: []
            },
            pageable: false,
            height: "100%",
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            columns: [
                { field: "eventType", title: "Event", filterable: { extra: false, multi: true }, width: 170 },
                { field: "start", title: "Started", filterable: { extra: false, search: true }, width: 170, template: '#= start ? kendo.toString(new Date(start) ,"MM/dd/yyyy HH:mm") : "" #' },
                { field: "end", title: "Ended", filterable: { extra: false, search: true }, width: 170, template: '#= end ? kendo.toString(new Date(end) ,"MM/dd/yyyy HH:mm") : "" #' },
                { field: "duration", title: "Duration (hh:mm:ss)", filterable: { extra: false, search: true }, width: 180 },
                { field: "durationBetween", title: "Uptime since last event (d.hh:mm:ss)", filterable: { extra: false, search: true } },
            ],
            excelExport: function (e) {
                const sheet = e.workbook.sheets[0];
                const startTemplate = kendo.template(this.columns[1].template);
                const endTemplate = kendo.template(this.columns[2].template);
                for (let i = 1; i < sheet.rows.length; i++) {
                    let row = sheet.rows[i];
                    let dataItem = {
                        start: row.cells[1].value,
                        end: row.cells[2].value
                    };
                    row.cells[1].value = startTemplate(dataItem);
                    row.cells[2].value = endTemplate(dataItem);
                }
            }
        });
    }
    populateEvents(siteCurtailments) {
        this.reset();
        if (siteCurtailments.events.length === 0) {
            this.toggleCurtailmentListVisible(false);
            return;
        }
        this.toggleCurtailmentListVisible(true);
        this.bindEvents(siteCurtailments.events);
        $("#totalCurtailments").text(siteCurtailments.totalEvents);
        $("#totalCurtailmentDuration").text(siteCurtailments.totalDuration);
    }
    reset() {
        $("#totalCurtailments").text("--");
        $("#totalCurtailmentDuration").text("--");
        this.bindEvents([]);
    }
    toggleCurtailmentListVisible(isVisible) {
        if (!isVisible) {
            $(".curtailment-panel").removeClass("active");
            return;
        }
        $(".curtailment-panel").addClass("active");
    }
    bindEvents(curtailmentEvents) {
        const grid = $("#curtailmentGrid").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: curtailmentEvents
        });
        grid.setDataSource(dataSource);
    }
    export() {
        const grid = $("#curtailmentGrid").data("kendoGrid");
        grid.saveAsExcel();
    }
}

class EgaugeGraph {
    constructor() {
        this.chart = new LineChart(null, "#metricBusy");
        this.chart.elementSelector = "meterGraph";
        this.chart.title = "Meters";
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.extraOptions.autoColor = true;
        this.chart.extraOptions.export = {
            csv: {
                filename: "Metered Power",
                headerCategory: "Time",
                headerValue: "Meter Value",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
    }
    populateChartData(graphData) {
        const serieData = [];
        try {
            graphData.data.result.forEach((result, idx) => {
                serieData.push({
                    name: `${result.metric.facility} - ${result.metric.eGauge}`,
                    data: result.values
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.series = serieData;
        $(".metric-graph").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return PowerConverter.parsePower(val);
    }
}

class ErcotGraph {
    constructor() {
        this.chart = new LineChart(null, "#ercotBusy");
        this.chart.elementSelector = "ercotGraph";
        this.chart.title = "ERCOT SPP";
        this.chart.extraOptions.formatter = this.formatter.bind(this);
        this.chart.extraOptions.autoColor = true;
        this.chart.extraOptions.export = {
            csv: {
                filename: "ERCOT SPP",
                headerCategory: "Time",
                headerValue: "SPP",
                dateFormatter: (timeStamp) => {
                    const time = window.moment(new Date(timeStamp)).format("YYYY-MM-DD hh:mm:ss A");
                    return time;
                }
            }
        };
        this.chart.render();
    }
    populateChartData(graphData) {
        const serieData = [];
        try {
            graphData.data.result.forEach((result, idx) => {
                serieData.push({
                    name: result.metric.location,
                    data: result.values
                });
            });
        }
        catch (_a) {
            return;
        }
        this.chart.series = serieData;
        $(".ercot-graph").addClass("active");
        this.chart.render();
    }
    formatter(val, index) {
        return `$${val}`;
    }
}

class KeyMetricsEventEditor extends OptiFleetPage {
    constructor(keyMetricsReport, chart, scheduledShutdowns, eventType) {
        super();
        this.keyMetricsReport = keyMetricsReport;
        this.chart = chart;
        this.scheduledShutdowns = scheduledShutdowns;
        this.eventType = eventType;
        this.scheduledShutdownsUrl = "/ScheduledShutdowns";
        this.selectedIndex = 0;
        this.saving = false;
        this.highlightedScheduledShutdown = null;
        this.highlightColor = "yellow";
    }
    open() {
        this.chart.find(".annotation-editor .prev-annotation").on("click", this.prev.bind(this));
        this.chart.find(".annotation-editor .next-annotation").on("click", this.next.bind(this));
        this.chart.find(".annotation-editor .save").on("click", this.save.bind(this));
        this.chart.find(".annotation-editor .close").on("click", this.close.bind(this));
        this.chart.find(".annotation-editor .start-date-input").on("change keyup", this.validateDate.bind(this));
        this.chart.find(".annotation-editor .start-time-input").on("change keyup", this.validateTime.bind(this));
        this.chart.find(".annotation-editor .end-date-input").on("change keyup", this.validateDate.bind(this));
        this.chart.find(".annotation-editor .end-time-input").on("change keyup", this.validateTime.bind(this));
        this.chart.find(".legend").last().hide();
        this.chart.find(".annotation-editor").show();
        this.chart.find(".annotation-editor .prev-annotation").trigger("click");
    }
    close() {
        this.chart.find(".annotation-editor .prev-annotation").off("click");
        this.chart.find(".annotation-editor .next-annotation").off("click");
        this.chart.find(".annotation-editor .start-date-input").off("change keyup");
        this.chart.find(".annotation-editor .start-time-input").off("change keyup");
        this.chart.find(".annotation-editor .end-date-input").off("change keyup");
        this.chart.find(".annotation-editor .end-time-input").off("change keyup");
        this.chart.find(".annotation-editor .save").off("click");
        this.chart.find(".annotation-editor .close").off("click");
        this.chart.find(".annotation-editor").hide();
        this.chart.find(".legend").last().show();
    }
    validateDate(event) {
        event.preventDefault();
        let date = $(event.currentTarget);
        let dateRegex = /[0-2]\d\/[01]\d\/20\d\d/;
        if (!dateRegex.test(date.val())) {
            date.addClass("is-error");
            return;
        }
        date.removeClass("is-error");
        let errors = this.chart.find(".annotation-editor .is-error").length;
        if (errors > 0) {
            this.chart.find(".annotation-editor .save").attr("disabled", "disabled");
        }
        else {
            this.chart.find(".annotation-editor .save").removeAttr("disabled");
        }
    }
    validateTime(event) {
        event.preventDefault();
        let time = $(event.currentTarget);
        let timeRegex = /[0-2]\d:\d\d:\d\d/;
        if (!timeRegex.test(time.val())) {
            time.addClass("is-error");
            return;
        }
        time.removeClass("is-error");
        let errors = this.chart.find(".annotation-editor .is-error").length;
        if (errors > 0) {
            this.chart.find(".annotation-editor .save").attr("disabled", "disabled");
        }
        else {
            this.chart.find(".annotation-editor .save").removeAttr("disabled");
        }
    }
    save(event) {
        event.preventDefault();
        if (this.saving) {
            return;
        }
        this.saving = true;
        let startDateInput = this.chart.find(".start-date-input");
        let startTimeInput = this.chart.find(".start-time-input");
        let endDateInput = this.chart.find(".end-date-input");
        let endTimeInput = this.chart.find(".end-time-input");
        if (startDateInput.hasClass("is-error") || startTimeInput.hasClass("is-error")) {
            this.showErrorMessage("Invalid Start Date/Time");
            return;
        }
        if (endDateInput.hasClass("is-error") || endTimeInput.hasClass("is-error")) {
            this.showErrorMessage("Invalid End Date/Time");
            return;
        }
        let scheduledShutdown = this.highlightedScheduledShutdown;
        let newStart = window.moment(`${startDateInput.val()} ${startTimeInput.val()}`, "MM/DD/YYYY HH:mm:ss");
        let newEnd = window.moment(`${endDateInput.val()} ${endTimeInput.val()}`, "MM/DD/YYYY HH:mm:ss");
        scheduledShutdown.start = newStart.toISOString();
        scheduledShutdown.end = newEnd.toISOString();
        let data = {
            scheduledShutdown: scheduledShutdown
        };
        this.chart.find(".annotation-editor .save").text("Saving").attr("disabled", "disabled");
        this.patch(this.scheduledShutdownsUrl, data).then((resp) => {
            setTimeout(() => {
                this.saving = false;
                if (!resp.success) {
                    this.chart.find(".annotation-editor .save").text("Save").removeAttr("disabled");
                    this.showErrorMessage("Failed to Save Event");
                    return;
                }
                this.chart.find(".annotation-editor .save").text("Save");
                this.showSuccessMessage("Event Saved");
                this.keyMetricsReport.runReport();
            }, 1000);
        });
    }
    prev() {
        let current = this.chart.find(`.apexcharts-xaxis-annotation-label.annotation-editor-selected:contains("${this.eventType}")`);
        if (current.length == 0) {
            let last = this.chart.find(`.apexcharts-xaxis-annotation-label:contains('${this.eventType}')`).last();
            this.highlightAnnotation(last);
            return;
        }
        let prev = current.prevAll(`.apexcharts-xaxis-annotation-label:contains('${this.eventType}')`).first();
        if (prev.length == 0) {
            prev = this.chart.find(`.apexcharts-xaxis-annotation-label:contains('${this.eventType}')`).last();
        }
        this.unHighlightAnnotation(current);
        this.highlightAnnotation(prev);
    }
    next() {
        let current = this.chart.find(`.apexcharts-xaxis-annotation-label.annotation-editor-selected:contains("${this.eventType}")`);
        if (current.length == 0) {
            let first = this.chart.find(`.apexcharts-xaxis-annotation-label:contains("${this.eventType}")`).first();
            this.highlightAnnotation(first);
            return;
        }
        let next = current.nextAll(`.apexcharts-xaxis-annotation-label:contains('${this.eventType}')`).first();
        if (next.length == 0) {
            next = this.chart.find(`.apexcharts-xaxis-annotation-label:contains('${this.eventType}')`).first();
        }
        this.unHighlightAnnotation(current);
        this.highlightAnnotation(next);
    }
    unHighlightAnnotation(labelElem) {
        labelElem.attr("fill", labelElem.attr("originalFill")).removeClass("annotation-editor-selected");
        let highlight = labelElem.prev().prev();
        highlight.attr("fill", highlight.attr("originalFill"));
    }
    highlightAnnotation(labelElem) {
        labelElem.addClass("annotation-editor-selected");
        labelElem.attr("originalFill", labelElem.attr("fill"));
        labelElem.attr("fill", this.highlightColor);
        let highlight = labelElem.prev().prev();
        highlight.attr("originalFill", highlight.attr("fill"));
        highlight.attr("fill", this.highlightColor);
        let prefixedClassName = labelElem.attr("class").split(" ").find(name => name.startsWith(KeyMetricsEventEditor.SCHEDULED_SHUTDOWN_CLASSNAME_PREFIX));
        let scheduledShutdownId = prefixedClassName.replace(KeyMetricsEventEditor.SCHEDULED_SHUTDOWN_CLASSNAME_PREFIX, "");
        //let kmr = (window as any).k as KeyMetricsReport;
        let ss = this.getScheduledShutdown(parseInt(scheduledShutdownId));
        if (!ss) {
            // Disable inputs
            return;
        }
        this.highlightedScheduledShutdown = ss;
        let startDateInput = this.chart.find(".start-date-input");
        let startTimeInput = this.chart.find(".start-time-input");
        let endDateInput = this.chart.find(".end-date-input");
        let endTimeInput = this.chart.find(".end-time-input");
        let siteName = this.chart.find("span.site-name");
        let siteTooltip = this.chart.find("div.site-name .tooltiptext");
        let start = window.moment(ss.start);
        startDateInput.val(start.format("MM/DD/YYYY"));
        startTimeInput.val(start.format("HH:mm:ss"));
        let end = window.moment(ss.end);
        endDateInput.val(end.format("MM/DD/YYYY"));
        endTimeInput.val(end.format("HH:mm:ss"));
        siteName.html(ss.siteName + '<m-icon name="zoom-in" style="color: var(--color-text-default) !important;"></m-icon>');
        siteTooltip.html(ss.zoneNames.length > 0 ? ss.zoneNames.join("<br/>") : "All Zones");
    }
    getScheduledShutdown(id) {
        for (let shutdown of this.scheduledShutdowns) {
            if (shutdown.scheduledShutdownId === id) {
                return shutdown;
            }
        }
    }
}
KeyMetricsEventEditor.SCHEDULED_SHUTDOWN_CLASSNAME_PREFIX = "SCHEDULED_SD_____";

var KEY_METRICS_INTERVAL;
(function (KEY_METRICS_INTERVAL) {
    KEY_METRICS_INTERVAL[KEY_METRICS_INTERVAL["HOUR"] = 1] = "HOUR";
    KEY_METRICS_INTERVAL[KEY_METRICS_INTERVAL["DAY"] = 2] = "DAY";
})(KEY_METRICS_INTERVAL || (KEY_METRICS_INTERVAL = {}));
class KeyMetricsReport extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: true, elemId: "ddlSites" });
        this.keyMetricsUrl = "/KeyMetrics";
        this.scheduledShutdownsUrl = "/ScheduledShutdowns";
        this.customersUrl = "/CustomersNew";
        this.minute = 60 * 1000;
        this.selectedSubCustomer = null;
        this.excusedEventsGrid = new ExcusedEventsGrid();
        this.onCompanyFilterChanged = this.handleCompanyChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteChanged.bind(this);
        const subCustomerDDL = document.getElementById("ddlSubCustomer");
        subCustomerDDL.options = [
            {
                label: "Full Site",
                value: "-1"
            },
        ];
        subCustomerDDL.addEventListener("on-change", this.handleCustomerChanged.bind(this));
        this.datePicker = new DatePicker("#datePicker", this.loadReport.bind(this));
    }
    handleCompanyChanged() {
        this.siteCache.loadSites();
    }
    handleSiteChanged(siteId) {
        this.loadCustomers(siteId);
        this.runReport();
    }
    handleCustomerChanged(e) {
        let option = e.detail;
        this.selectedSubCustomer = option.value === "-1" ? null : option;
        if (!this.isLoadingReport) {
            const params = this.datePicker.getParams();
            this.loadReport(params);
        }
    }
    loadCustomers(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                this.get(`${this.customersUrl}?siteId=${siteId}`).then((res) => {
                    if (!res.success) {
                        this.showErrorMessage("Failed to fetch customers");
                        $("#ddlSubCustomer").hide();
                        resolve(false);
                    }
                    if (res.customers.length === 0) {
                        $("#ddlSubCustomer").hide();
                    }
                    else {
                        const subCustomerDDL = document.getElementById("ddlSubCustomer");
                        subCustomerDDL.options = [
                            { label: "Full Site", value: "-1" },
                            ...res.customers.map((c) => ({ value: c.id.toString(), label: c.name }))
                        ];
                        $("#ddlSubCustomer").show();
                    }
                    resolve(true);
                });
            });
        });
    }
    runReport() {
        const params = this.datePicker.getParams();
        this.loadReport(params);
    }
    loadReport(params) {
        this.isLoadingReport = true;
        this.toggleBusy(true);
        const siteId = this.getSelectedSiteId();
        const subCust = this.selectedSubCustomer;
        let { start, end } = params;
        Promise.all([
            this.excusedEventsGrid.refresh({ siteId, start, end }),
            this.get(`${this.keyMetricsUrl}?siteId=${siteId}&subcustomerId=${(subCust === null || subCust === void 0 ? void 0 : subCust.value) || "null"}&interval=${params.step}&step=${params.step}&start=${params.start}&end=${params.end}`),
        ]).then((results) => {
            this.metrics = results[1];
            this.populateCharts();
            this.fillStats();
            this.toggleBusy(false);
            this.isLoadingReport = false;
        });
    }
    populateCharts() {
        $(".charts").children().remove();
        this.metrics.forEach((kmr) => {
            const template = self.Mustache.to_html(KmrGraph.TEMPLATE, kmr);
            $(".charts").append(template);
            let chartOverrideParams = { withLegend: true, height: '200px', annotationLegendClickHandler: this.handleCurtailmentEditorToggle.bind(this) };
            const chart = new StyledLineChart(`chart${kmr.siteId}`, kmr.siteName, chartOverrideParams);
            chart.formatter = (val) => `${val} %`;
            let labeledData = keyMetricsResponseToPromSeries(kmr);
            chart.populateChartData(labeledData, this.buildChartAnnotations(kmr.scheduledShutdowns));
        });
    }
    fillStats() {
        this.metrics.length;
        const sumHashrate = this.metrics.map((metric) => metric.sumHashrateOverTime).reduce((a, b) => a + b, 0);
        const sumExpectedHashrate = this.metrics.map((metric) => metric.sumExpectedHashrateOverTime).reduce((a, b) => a + b, 0);
        const sumHashingCount = this.metrics.map((metric) => metric.sumHashingMinerCount).reduce((a, b) => a + b, 0);
        const sumTotalMinerCount = this.metrics.map((metric) => metric.sumTotalMinerCount).reduce((a, b) => a + b, 0);
        const sumOccupancyCount = this.metrics.map((metric) => metric.sumAssignedSlotsCount).reduce((a, b) => a + b, 0);
        const sumTotalSlotsCount = this.metrics.map((metric) => metric.sumTotalSlotsCount).reduce((a, b) => a + b, 0);
        const hre = Math.round(sumHashrate * 1000 / sumExpectedHashrate) / 10;
        const uptime = Math.round((sumHashingCount * 1000) / sumTotalMinerCount) / 10;
        const util = Math.round((sumOccupancyCount * 1000) / sumTotalSlotsCount) / 10;
        $("#hashrateEfficiencyStat").text(`${hre}%`);
        $("#uptimeStat").text(`${uptime}%`);
        if (this.selectedSubCustomer !== null) {
            $("#avgSiteUtilizationCard").css("display", "none");
        }
        else {
            $("#avgSiteUtilizationCard").css("display", "flex");
        }
        $("#siteUtilizationStat").text(`${util}%`);
    }
    buildChartAnnotations(excusedEvents) {
        let xaxis = excusedEvents.map((event) => {
            let annotation = StyledLineChart.newXaxisAnnotation(event.title, new Date(event.start).getTime(), new Date(event.end).getTime(), ExcusedEventsGrid.EVENT_TYPE_COLORS[event.typeId] || ExcusedEventsGrid.EVENT_TYPE_COLORS[1]);
            annotation.label.click = this.handleAnnotationClick.bind(this);
            annotation.label.style.cssClass = KeyMetricsEventEditor.SCHEDULED_SHUTDOWN_CLASSNAME_PREFIX + event.scheduledShutdownId;
            return annotation;
        });
        return { xaxis: xaxis };
    }
    handleAnnotationClick(annotation, event) {
        event.preventDefault();
    }
    savePDF() {
        kendo.drawing.drawDOM($(".content-placeholder"), {
            margin: "2px", // configure some of the PDF options.
            paperSize: "A3",
            landscape: true,
            multiPage: true
        }).then(function (group) {
            kendo.drawing.pdf.saveAs(group, "filename.pdf");
        });
    }
    exportChartData() {
        const siteName = this.getSelectedSiteName();
        let title = "Key Metrics";
        if (siteName) {
            title = title + ` (${siteName})`;
        }
        //let withAverages = true
        //this.metricsChart.exportExcel(title, withAverages);
        this._exportExcel(title, siteName);
    }
    exportExcusedEventsGrid() {
        this.excusedEventsGrid.exportExcel();
    }
    _exportExcel(title, siteName) {
        if (this.selectedSubCustomer !== null) {
            $("#ddlSubCustomer").data("kendoDropDownList").text();
            siteName = `${siteName} (${this.selectedSubCustomer.label})`;
        }
        let siteNameHeader = [siteName, "\r\n"];
        let header;
        if (this.selectedSubCustomer !== null) {
            header = ["Time", "Hash Rate Efficiency", "Uptime", "Event", "\r\n"];
        }
        else {
            header = ["Time", "Hash Rate Efficiency", "Uptime", "Site Utilization", "Event", "\r\n"];
        }
        let rows = [];
        const uptimeValues = this.metrics[0].uptime.data.result[0].values;
        let eventCursor = 0;
        let currentEvent = this.metrics[0].scheduledShutdowns.length > 0 ? this.metrics[0].scheduledShutdowns[eventCursor] : null;
        this.metrics[0].hashrateEfficiency.data.result[0].values.forEach(([time, val], index) => {
            const datetime = new Date(time);
            let eventString = "";
            if (currentEvent === null || currentEvent === void 0 ? void 0 : currentEvent.start) {
                const start = new Date(currentEvent.start);
                const end = new Date(currentEvent.end);
                // add label if during an event
                if (datetime >= start && datetime < end) {
                    eventString = currentEvent.title;
                    // make sure to snap the next event if the current one is in the past
                }
                else if (datetime >= end) {
                    while (currentEvent && new Date(currentEvent.end) < datetime) {
                        eventCursor += 1;
                        currentEvent = this.metrics[0].scheduledShutdowns.length > 0 ? this.metrics[0].scheduledShutdowns[eventCursor] : null;
                    }
                }
            }
            let row;
            if (this.selectedSubCustomer !== null) {
                row = [
                    window.moment(datetime).format("MM-DD-YYYY HH:mm:ss"),
                    val,
                    uptimeValues[index][1],
                    eventString
                ];
            }
            else {
                row = [
                    window.moment(datetime).format("MM-DD-YYYY HH:mm:ss"),
                    val,
                    uptimeValues[index][1],
                    this.metrics[0].siteUtilization.data.result[0].values[index][1],
                    eventString
                ];
            }
            row.push("\r\n");
            rows.push(row.join(","));
        });
        //this.metrics.siteAverages.forEach(siteAvgs => {
        //    let row
        //    if (this.selectedSubCustomer) {
        //        row = [
        //            `"${siteAvgs.siteName} Average"`,
        //            siteAvgs.averageHashrateEfficiency,
        //            siteAvgs.averageUptime,
        //            "\r\n"
        //        ];
        //    } else {
        //        row = [
        //            `"${siteAvgs.siteName} Average"`,
        //            siteAvgs.averageHashrateEfficiency,
        //            siteAvgs.averageUptime,
        //            siteAvgs.averageSiteUtilization,
        //            "\r\n"
        //        ];
        //    }
        //    rows.push(row.join(","));
        //});
        const sumHashrate = this.metrics.map((metric) => metric.sumHashrateOverTime).reduce((a, b) => a + b, 0);
        const sumExpectedHashrate = this.metrics.map((metric) => metric.sumExpectedHashrateOverTime).reduce((a, b) => a + b, 0);
        const sumHashingCount = this.metrics.map((metric) => metric.sumHashingMinerCount).reduce((a, b) => a + b, 0);
        const sumTotalMinerCount = this.metrics.map((metric) => metric.sumTotalMinerCount).reduce((a, b) => a + b, 0);
        const sumOccupancyCount = this.metrics.map((metric) => metric.sumAssignedSlotsCount).reduce((a, b) => a + b, 0);
        const sumTotalSlotsCount = this.metrics.map((metric) => metric.sumTotalSlotsCount).reduce((a, b) => a + b, 0);
        const hre = Math.round(sumHashrate * 1000 / sumExpectedHashrate) / 10;
        const uptime = Math.round((sumHashingCount * 1000) / sumTotalMinerCount) / 10;
        const util = Math.round((sumOccupancyCount * 1000) / sumTotalSlotsCount) / 10;
        let avg_row;
        if (this.selectedSubCustomer !== null) {
            avg_row = [
                "Average",
                hre,
                uptime,
                "\r\n"
            ];
        }
        else {
            avg_row = [
                "Average",
                hre,
                uptime,
                util,
                "\r\n"
            ];
        }
        rows.push(avg_row.join(","));
        const csv = [siteNameHeader, header, ...rows].join("");
        ExcelUtility.exportFromCsvData(csv, title);
    }
    handleCurtailmentEditorToggle(labelId, labelName, e) {
        let scheduledShutdowns = [];
        this.metrics.forEach(kmr => {
            kmr.scheduledShutdowns.forEach((shutdown, index) => {
                if (shutdown.title === labelName) {
                    scheduledShutdowns.push(shutdown);
                }
            });
        });
        if (scheduledShutdowns.length < 1) {
            this.showErrorMessage(`No Excused Events for ${labelName}`);
            return;
        }
        let chart = $(e.currentTarget).parents(".chart").first();
        let editor = new KeyMetricsEventEditor(this, chart, scheduledShutdowns, labelName);
        editor.open();
    }
}
function keyMetricsResponseToPromSeries(resp) {
    if (resp.siteUtilization.data.result.length > 0) {
        resp.siteUtilization.data.result[0].metric.name = "Site Utilization";
    }
    if (resp.uptime.data.result.length > 0) {
        resp.uptime.data.result[0].metric.name = "Uptime";
    }
    if (resp.hashrateEfficiency.data.result.length > 0) {
        resp.hashrateEfficiency.data.result[0].metric.name = "Hash Rate Efficiency";
    }
    return [
        resp.siteUtilization,
        resp.uptime,
        resp.hashrateEfficiency,
    ];
}

class SensorGraphPanel extends OptiFleetPage {
    constructor() {
        super();
        this.init();
    }
    init() {
        this.temperatureGraph = new SensorPushTemperatureGraph();
        this.temperatureGraph.chart.selectedInterval = GraphIntervals.LAST_24_HOURS;
        this.humidityGraph = new SensorPushHumidityGraph();
        this.humidityGraph.chart.selectedInterval = GraphIntervals.LAST_24_HOURS;
    }
    setSensorList(sensors) {
        this.sensors = sensors;
    }
    open(sensorId) {
        $(".graph-panel").addClass("active");
        this.setSensorInfo(sensorId);
        this.temperatureGraph.chart.load([["sensorId", sensorId]]);
        this.humidityGraph.chart.load([["sensorId", sensorId]]);
    }
    setSensorInfo(sensorId) {
        const sensor = this.getSensor(sensorId);
        if (!sensor) {
            return;
        }
        $("#selectedSensorName").text(sensor.sensorName);
        $("#selectedSensorLastReading").text(sensor.lastSample);
    }
    getSensor(sensorId) {
        return this.sensors.filter((sensor) => {
            return sensor.sensorId === sensorId;
        })[0];
    }
    close() {
        $(".graph-panel").removeClass("active");
    }
}

class Base64ToBlob {
    static Convert(b64Data) {
        const sliceSize = 512;
        const byteCharacters = atob(b64Data);
        const byteArrays = [];
        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            const slice = byteCharacters.slice(offset, offset + sliceSize);
            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        const blob = new Blob(byteArrays);
        return blob;
    }
}

class ClassNames {
    static createClassName(...args) {
        let classes = "";
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (typeof arg === "undefined" || arg === null) {
                continue;
            }
            if (typeof arg === "string") {
                classes += ` ${arg}`;
                continue;
            }
            for (const key in arg) {
                const shouldInclude = Boolean(arg[key]);
                classes += shouldInclude ? ` ${key}` : "";
            }
        }
        return classes.trim();
    }
}

class ExcelUtility {
    static exportToExcel(headers, rows, fileName, excludedColumnIndexes) {
        ExcelUtility.headers = headers;
        ExcelUtility.rows = rows;
        if (!fileName) {
            fileName = "download";
        }
        if (!excludedColumnIndexes) {
            excludedColumnIndexes = [];
        }
        const tableData = ExcelUtility.buildTableData(excludedColumnIndexes);
        const base64 = btoa(tableData);
        const blob = Base64ToBlob.Convert(base64);
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.download = `${fileName}.xls`;
        link.href = url;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    static exportToCSV(headers, rows, fileName, excludedColumnIndexes) {
        ExcelUtility.headers = headers;
        ExcelUtility.rows = rows;
        if (!fileName) {
            fileName = "download";
        }
        if (!excludedColumnIndexes) {
            excludedColumnIndexes = [];
        }
        const tableData = ExcelUtility.buildCsvData(excludedColumnIndexes);
        const base64 = btoa(tableData);
        const blob = Base64ToBlob.Convert(base64);
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.download = `${fileName}.csv`;
        link.href = url;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    static buildCsvData(excludedColumnIndexes) {
        var headerData = ExcelUtility.buildCsvHeader(excludedColumnIndexes);
        var rowData = ExcelUtility.buildCsvRows(excludedColumnIndexes);
        return headerData + rowData;
    }
    static buildCsvHeader(excludedColumnIndexes) {
        let header = "";
        ExcelUtility.headers.forEach((headerCell, index) => {
            if (excludedColumnIndexes.indexOf(index) > -1) {
                return;
            }
            header += `"${headerCell.innerText}",`;
        });
        header = header.substring(0, header.length - 1) + "\r\n";
        return header;
    }
    static buildCsvRows(excludedColumnIndexes) {
        let rowElements = "";
        ExcelUtility.rows.forEach((row) => {
            let csvRow = "";
            for (let cell = 0; cell < row.cells.length; cell++) {
                if (excludedColumnIndexes.indexOf(cell) > -1) {
                    csvRow += "";
                }
                else {
                    csvRow += `"${row.cells[cell].innerText}",`;
                }
            }
            csvRow = csvRow.substring(0, csvRow.length - 1) + "\r\n";
            rowElements += csvRow;
        });
        return rowElements;
    }
    static buildTableData(excludedColumnIndexes) {
        return `<table>${ExcelUtility.getRows(excludedColumnIndexes)}</table>`;
    }
    static getRows(excludedColumnIndexes) {
        let excelData = "";
        excelData += ExcelUtility.addTableHeader(excludedColumnIndexes);
        excelData += ExcelUtility.addTableRowData(excludedColumnIndexes);
        return excelData;
    }
    static addTableHeader(excludedColumnIndexes) {
        let row = "<tr>";
        ExcelUtility.headers.forEach((header, index) => {
            if (excludedColumnIndexes.indexOf(index) > -1) {
                return;
            }
            row = row + `<td style="border: solid thin black;">${header.innerText}</td>`;
        });
        row = row + "</tr>";
        return row;
    }
    static addTableRowData(excludedColumnIndexes) {
        let rowElements = "";
        ExcelUtility.rows.forEach((row) => {
            rowElements += "<tr>";
            for (let cell = 0; cell < row.cells.length; cell++) {
                if (excludedColumnIndexes.indexOf(cell) > -1) {
                    rowElements += "";
                }
                else {
                    rowElements += `<td style="border: solid thin black;">${row.cells[cell].innerText}</td>`;
                }
            }
            rowElements += "</tr>";
        });
        return rowElements;
    }
    static exportFromCsvData(csv, fileName) {
        const base64 = btoa(csv);
        const blob = Base64ToBlob.Convert(base64);
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.download = `${fileName}.csv`;
        link.href = url;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}

class HashrateUtil {
    static parseHashrate(hashrate, hashingTypeId, fractionDigits) {
        if (!hashrate) {
            hashrate = 0;
        }
        var cleanHashrate = Math.abs(hashrate);
        var digits = cleanHashrate.toFixed(0).length;
        var magnitudes = Math.floor((digits - 0.1) / 3);
        var fraction = cleanHashrate / Math.pow(1000, magnitudes);
        const f = typeof fractionDigits === "undefined" ? 1 : fractionDigits;
        return `${fraction.toFixed(f)} ${HashrateUtil.getHashrateLabel(magnitudes, hashingTypeId)}`;
    }
    static getHashrateUnit(hashrate, hashingType) {
        let mod = 0;
        while (hashrate > 1000) {
            mod++;
            hashrate = hashrate / 1000;
        }
        return HashrateUtil.getHashrateLabel(mod, hashingType);
    }
    static getHashrateScaled(hashrate, fractionDigits) {
        if (!hashrate) {
            hashrate = 0;
        }
        while (hashrate > 1000) {
            hashrate = hashrate / 1000;
        }
        if (fractionDigits && fractionDigits > 0) {
            return hashrate.toFixed(fractionDigits);
        }
        return hashrate.toFixed(1);
    }
    static toTerahashRate(hashrate) {
        return `${Math.round(hashrate / this.OneTerahash)} TH`;
    }
    static getHashrateLabel(mod, hashingType) {
        var prefix = mod < HashrateUtil.prefixes.length ? HashrateUtil.prefixes[mod] : HashrateUtil.prefixes[0];
        var postfix = hashingType < HashrateUtil.postfixes.length ? HashrateUtil.postfixes[hashingType] : HashrateUtil.postfixes[0];
        return `${prefix}${postfix}`;
    }
    static normalizeHashrate(hashrate, fromUnit, toUnit) {
        const postfix = (toUnit === null || toUnit === void 0 ? void 0 : toUnit.toLowerCase().includes("sol")) ? "Sol/s" : "Hs";
        const multiplier = HashrateUnits[fromUnit].valueOf();
        const hashesPerSecond = hashrate * multiplier;
        // determine number of exponents
        const hashrateLog = Math.log10(hashesPerSecond);
        let targetIndex = HashrateUtil.exponents.findIndex(exponent => hashrateLog <= exponent) - 1;
        targetIndex = Math.max(0, targetIndex);
        const targetUnit = HashrateUtil.prefixes[targetIndex] + postfix;
        const divisor = HashrateUnits[targetUnit].valueOf();
        return {
            hashesPerSecond: hashesPerSecond,
            value: formatHashratePrecision(hashesPerSecond / divisor),
            unit: targetUnit
        };
    }
}
HashrateUtil.OneTerahash = 1e12;
HashrateUtil.prefixes = ["", "K", "M", "G", "T", "P", "E", "Z", "Y"];
HashrateUtil.postfixes = ["H/s", "Hs", "Sol/s", "Gps"];
HashrateUtil.exponents = [0, 3, 6, 9, 12, 15, 18, 21, 24];
function formatHashratePrecision(value) {
    const exp = Math.log10(value);
    if (exp >= 2) {
        value = parseFloat(value.toFixed(1));
    }
    else {
        value = parseFloat(value.toFixed(2));
    }
    return value;
}
var HashrateUnits;
(function (HashrateUnits) {
    HashrateUnits[HashrateUnits["Hs"] = 1] = "Hs";
    HashrateUnits[HashrateUnits["kHs"] = 1000] = "kHs";
    HashrateUnits[HashrateUnits["KHs"] = 1000] = "KHs";
    HashrateUnits[HashrateUnits["MHs"] = 1000000] = "MHs";
    HashrateUnits[HashrateUnits["GHs"] = 1000000000] = "GHs";
    HashrateUnits[HashrateUnits["THs"] = 1000000000000] = "THs";
    HashrateUnits[HashrateUnits["PHs"] = 1000000000000000] = "PHs";
    HashrateUnits[HashrateUnits["EHs"] = 1000000000000000000] = "EHs";
    HashrateUnits[HashrateUnits["Sol/s"] = 1] = "Sol/s";
    HashrateUnits[HashrateUnits["KSol/s"] = 1000] = "KSol/s";
    HashrateUnits[HashrateUnits["MSol/s"] = 1000000] = "MSol/s";
    HashrateUnits[HashrateUnits["GSol/s"] = 1000000000] = "GSol/s";
    HashrateUnits[HashrateUnits["TSol/s"] = 1000000000000] = "TSol/s";
    HashrateUnits[HashrateUnits["PSol/s"] = 1000000000000000] = "PSol/s";
    HashrateUnits[HashrateUnits["Gps"] = 1] = "Gps";
    HashrateUnits[HashrateUnits["KGps"] = 1000] = "KGps";
    HashrateUnits[HashrateUnits["MGps"] = 1000000] = "MGps";
    HashrateUnits[HashrateUnits["GGps"] = 10000000001] = "GGps";
    HashrateUnits[HashrateUnits["TGps"] = 1000000000000] = "TGps";
    HashrateUnits[HashrateUnits["PGps"] = 1000000000000000] = "PGps";
})(HashrateUnits || (HashrateUnits = {}));

class MathUtil {
    // simple util for dividing numbers while avoiding dividing by zero
    // e.g. divide(1, 0) -> 0, divide(1, 2) -> 0.5
    static divide(num1, num2) {
        if (num2 == 0) {
            return 0;
        }
        return num1 / num2;
    }
    // rounds to a specified number of decimal places
    // e.g. round(1.253, 2) -> 1.26
    static round(num, decimalPlaces = 0) {
        const multiplier = Math.pow(10, decimalPlaces);
        return Math.round((num * multiplier) * (1 + Number.EPSILON)) / multiplier;
    }
}

class PowerConverter {
    static parsePower(powerLoad, fractionDigits) {
        if (!powerLoad) {
            powerLoad = 0;
        }
        let mod = 0;
        while (powerLoad > 1000) {
            mod++;
            powerLoad = powerLoad / 1000;
        }
        if (fractionDigits && fractionDigits > 0) {
            return `${powerLoad.toFixed(fractionDigits)} ${PowerConverter.getPowerLabel(mod)}`;
        }
        return `${powerLoad.toFixed(1)} ${PowerConverter.getPowerLabel(mod)}`;
    }
    static getPowerUnit(powerLoad) {
        let mod = 0;
        while (powerLoad > 1000) {
            mod++;
            powerLoad = powerLoad / 1000;
        }
        return PowerConverter.getPowerLabel(mod);
    }
    static getPowerScaled(powerLoad, fractionDigits) {
        if (!powerLoad) {
            powerLoad = 0;
        }
        if (typeof (powerLoad) === "string") {
            powerLoad = parseFloat(powerLoad);
        }
        while (powerLoad > 1000) {
            powerLoad = powerLoad / 1000;
        }
        if (fractionDigits && fractionDigits > 0) {
            return powerLoad.toFixed(fractionDigits);
        }
        return powerLoad.toFixed(1);
    }
    static getPowerLabel(mod) {
        if (mod > 5) {
            return "EW";
        }
        if (mod > 4) {
            return "PW";
        }
        if (mod > 3) {
            return "TW";
        }
        if (mod > 2) {
            return "GW";
        }
        if (mod > 1) {
            return "MW";
        }
        if (mod > 0) {
            return "kW";
        }
        return "W";
    }
}

class SiteMapNew extends OptiFleetPage {
    constructor() {
        const showWeather = true;
        super(showWeather, { includeAllSites: false, elemId: "ddlSites" });
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.siteCache.loadSites();
        const selectedSiteId = this.getQueryStringValue("siteId");
        if (selectedSiteId) {
            this.siteCache.setSiteId(selectedSiteId);
        }
        this.siteMapData = new SiteMapData(this);
        new SiteMapFilters(this);
        new SiteMapMenus(this);
        this.siteMapRacks = new SiteMapRacks(this);
        this.siteMapStats = new SiteMapStats(this);
        new SiteMapLegend(this);
        this.refreshDisabled = false;
        this.refreshFunction = this.siteMapData.refreshAll.bind(this.siteMapData);
        $("#createZonesLink").on('click', () => __awaiter(this, void 0, void 0, function* () { return this.navToZoneSetup(); }));
    }
    navToMinerList() {
        localStorage.setItem("minerPreference", "list");
        window.location.assign("/Content/Dashboard/Miners/List.aspx");
    }
    handleCompanyFilterChanged() {
        this.siteCache.loadSites();
    }
    navToZoneSetup() {
        return __awaiter(this, void 0, void 0, function* () {
            OptiFleetMaster.goTo(`/Administration/SiteDetails.aspx?siteId=${yield this.siteCache.getSiteId()}&tab=Zones`);
        });
    }
}

class Agents extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.agentUrl = "/agents";
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
    }
    handleCompanyFilterChanged(companyId) {
        if (this.getSelectedCompanyId() <= 0) {
            this.toggleSelectCompany(true);
            return;
        }
        this.toggleSelectCompany(false);
        this.loadAgents();
    }
    loadAgents() {
        this.get(this.agentUrl)
            .then((resp) => {
            this.agents = resp.agents;
            this.renderAgentCards(this.agents);
        });
    }
    getNoRecordsTemplate() {
        if (this.getSelectedCompanyId() <= 0) {
            return "Please select a Company from the Company Filter.";
        }
        return `<div>There aren't any Agents yet. Head over to the <a class="site-link" href="Sites.aspx">Sites screen</a> to create a Site and add an Agent!</div>`;
    }
    renderAgentCards(agents) {
        if (agents.length === 0) {
            $("#agent-cards").empty().append(this.getNoRecordsTemplate());
        }
        const elem = self.Mustache.to_html(AgentMustacheTemplates.AGENT_CARDS, { agents });
        $("#agent-cards").empty().append(elem);
    }
}
Agents.mustache = window.Mustache;

class SiteMap extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: false });
        this.siteDetailsUrl = "/siteDetails";
        this.rebootMinersUrl = "/rebootMiners";
        this.updateMinersUrl = "/BulkUpdateMiners";
        this.companyLocationsUrl = "/MinerPropertyList?type=CompanyLocation";
        this.availableLocationsUrl = "/MinerPropertyList?type=AvailableCompanyLocation";
        this.minersUrl = "/Miners";
        this.builder = new SiteMapBuilder(this);
        this.ui = new SiteMapUI(this);
        this.zoneId = parseInt(this.getQueryStringValue("zoneId"));
        const initialSiteId = this.getQueryStringValue("siteId");
        if (initialSiteId) {
            //sets the site when navigated from a zone in main dashboard
            localStorage.setItem("selectedSite", initialSiteId);
        }
        this.init();
    }
    init() {
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        this.siteCache.loadSites();
        this.loadLocations().then(() => {
            this.ui.init();
        });
        $("#zoneList").kendoDropDownList({
            dataTextField: "name",
            dataValueField: "value",
            dataSource: [],
            height: 200,
            autoWidth: true,
            change: (e) => {
                this.zoneId = parseInt(e.sender.value());
                this.refresh();
                this.clickRefresh();
            },
        });
        $("#intervalList").kendoDropDownList({
            dataTextField: "text",
            dataValueField: "value",
            dataSource: SiteMap.getIntervals(),
            height: 200,
            autoWidth: true,
            change: this.changeRefreshInterval.bind(this),
        });
        $("#refreshButton").on("click", this.clickRefresh.bind(this));
        $("#statList").kendoDropDownList({
            dataTextField: "name",
            dataValueField: "value",
            dataSource: this.getStatTypes(),
            height: 200,
            autoWidth: true,
            change: (e) => {
                if (e.sender.value() === "hashrate_rt") {
                    this.refreshMethod = this.builder.populateHashrateData.bind(this.builder);
                    this.builder.setAggregationInterval(null);
                }
                if (e.sender.value().includes("hashrateAgg")) {
                    this.refreshMethod = this.builder.populateHashrateData.bind(this.builder);
                    const interval = e.sender.value().split("_").pop();
                    this.builder.setAggregationInterval(interval);
                }
                if (e.sender.value() === "temperature") {
                    this.refreshMethod = this.builder.populateTemperatureData.bind(this.builder);
                    this.builder.setAggregationInterval(null);
                }
                this.clickRefresh();
            },
        });
        $("#menu").kendoContextMenu({
            target: "#zones",
            filter: ".miner-position-cell",
            animation: {
                open: { effects: "fadeIn" },
            },
            open: this.ui.contextOpen.bind(this.ui),
            select: this.ui.contextSelection.bind(this.ui),
            showOn: "click",
        });
        this.refreshMethod = this.builder.populateHashrateData.bind(this.builder);
        $("#reboot-dialog").kendoDialog({
            width: "450px",
            title: "Miner Reboot",
            closable: true,
            modal: true,
            visible: false,
            actions: [{ text: "Cancel" }, { text: "Reboot", primary: true, action: this.rebootMiner.bind(this) }],
        });
        $("#location-dialog").kendoDialog({
            width: "450px",
            title: "Select a new location",
            closable: true,
            modal: true,
            visible: false,
            actions: [
                { text: "Cancel" },
                { text: "Update", primary: true, action: this.ui.updateSelectedMiner.bind(this.ui) },
            ],
        });
        $("#miner-dialog").kendoDialog({
            width: "450px",
            title: "Select a miner",
            closable: true,
            modal: true,
            visible: false,
            actions: [
                { text: "Cancel" },
                { text: "Update", primary: true, action: this.updateSelectedLocation.bind(this) },
            ],
        });
    }
    handleCompanyFilterChanged(companyId) {
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(siteId) {
        this.loadLocations();
        this.ui.loadSiteDetails();
    }
    getSiteId() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.siteCache.getSiteId();
        });
    }
    getZoneId() {
        return this.zoneId;
    }
    setZoneId(zoneId) {
        return (this.zoneId = zoneId);
    }
    getZones() {
        return this.zones;
    }
    setZones(zones) {
        // Update the Zone information to match the active locations
        const activeLocationNames = Array.from(this.activeLocations.keys());
        for (const zone of zones) {
            const zoneLocations = activeLocationNames.filter((name) => name.startsWith(zone.zoneName + "-"));
            let largestRack = 1;
            let largestShelf = 1;
            for (const location of zoneLocations) {
                const [, rack, shelf] = location.split("-");
                let rackValue = parseInt(rack);
                if (/^[A-Z]/.test(rack)) {
                    rackValue = rack.charCodeAt(0) - 64;
                }
                largestRack = rackValue > largestRack ? rackValue : largestRack;
                const shelfValue = parseInt(shelf);
                largestShelf = shelfValue > largestShelf ? shelfValue : largestShelf;
            }
            zone.racks = largestRack;
            zone.rows = largestShelf;
        }
        return (this.zones = zones);
    }
    IsActiveLocation(location) {
        return this.activeLocations.has(location);
    }
    refresh() {
        $(".site-map-wrapper .grid-busy").show();
        this.builder.rebuildLayout();
        this.refreshMethod().then(() => {
            $("#zones").show();
            $(".site-map-wrapper .grid-busy").hide();
        });
    }
    cancelMultiSelect() {
        this.ui.disableMultiSelectMode();
    }
    rebootMiners() {
        this.ui.promptRebootMiners();
    }
    clickRefresh() {
        const button = $("#refreshButton");
        const spinner = $("#refreshButtonSpinner");
        button.attr("disabled", "disabled");
        spinner.show();
        this.refreshMethod();
        setTimeout(() => {
            spinner.hide();
            button.removeAttr("disabled");
        }, 1500);
    }
    changeRefreshInterval(e) {
        const intervalTimeValue = e.sender.value();
        const newIntervalTime = parseInt(intervalTimeValue);
        clearInterval(this.interval);
        this.interval = undefined;
        if (newIntervalTime > 0) {
            this.interval = setInterval(this.clickRefresh.bind(this), newIntervalTime);
        }
    }
    loadLocations() {
        return this.get(`${this.companyLocationsUrl}`).then((resp) => {
            this.activeLocations = new Map(resp.list.map((location) => [location.text, location.value]));
        });
    }
    rebootMiner() {
        this.showNullState("Rebooting");
        const selectedMinerIds = [];
        for (const elem of $(".miner-position-cell[minerId].selected").get()) {
            selectedMinerIds.push(parseInt($(elem).attr("minerId")));
        }
        const minerIds = selectedMinerIds.length > 0 ? selectedMinerIds : [this.ui.targetMinerId];
        this.post(this.rebootMinersUrl, { miners: minerIds }).then((resp) => {
            this.hideNullState();
            if (!resp.success) {
                this.showErrorMessage("Something went wrong sending the request to reboot the selected miners.");
                return;
            }
            this.showSuccessMessage("Miner reboot command sent!");
            this.ui.disableMultiSelectMode();
        });
    }
    updateSelectedLocation() {
        const minerDDL = $("#minerList").data("kendoDropDownList");
        let location = this.ui.targetCell.attr("location");
        if (location === undefined) {
            location = $("#zoneList").data("kendoDropDownList").text() + "-" + this.ui.targetCell.attr("position");
        }
        if (minerDDL.value() !== "-1" && location !== undefined) {
            this.updateMinerLocation(minerDDL.value(), location);
        }
    }
    updateMinerLocation(minerId, locationId) {
        this.showNullState("Updating Location");
        this.toggleBusy(true);
        const saveData = {
            miners: [minerId],
            values: [["location", locationId]],
        };
        this.post(this.updateMinersUrl, saveData).then(() => {
            this.showSuccessMessage("Location Updated!");
            this.clickRefresh();
        });
        this.toggleBusy(false);
        this.hideNullState();
    }
    static getIntervals() {
        return [
            {
                text: "None",
                value: null,
            },
            {
                text: "1 Minute",
                value: 60 * 1000,
            },
            {
                text: "5 Minutes",
                value: 5 * 60 * 1000,
            },
            {
                text: "10 Minutes",
                value: 10 * 60 * 1000,
            },
        ];
    }
    getStatTypes() {
        return [
            {
                name: "Hashrate (RT)",
                value: "hashrate_rt",
            },
            {
                name: "Hashrate (30min)",
                value: "hashrateAgg_30m",
            },
            {
                name: "Temperature",
                value: "temperature",
            },
        ];
    }
}

class IndividualMiner extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.minerPermissionUrl = "/MinerPermission?id=";
        this.rebootUrl = "/RebootMiners";
        this.minute = 60 * 1000;
        this.canEdit = false;
        this.checkPermission();
    }
    init() {
        this.minerTagsPanel = new MinerTagsPanel("tagsPanel");
        this.get(`/MinerInfo?minerId=${this.minerId}`)
            .then((resp) => {
            this.miner = resp.individualMiner;
            this.minerTagsPanel.init(this.miner);
        });
        this.canEdit = $(`#${window.hfId}`).val() === "true";
        this.metricsPanel = new MinerMetricsPanel(this.minerId);
        this.detailsPanel = new OpMinerDetailsPanel();
        this.detailsPanel.openMinerDetailsView({ minerId: this.minerId });
        this.ticketPanel = new MinerTicketPanel();
        this.commentsPanel = new MinerCommentsPanel(this.minerId, this.canEdit);
        this.minerLinkModal = new MinerLinkModal(this.minerId);
        this.poolConfigModal = new OpPoolConfigModal(this, "PoolConfigModal");
        this.minerActivityList = new MinerActivityList(this.constructor.name);
        this.minerActivityList.init(this.minerId);
        this.minerLinkModal.onMinerLink = this.onMinerLink.bind(this);
        this.refreshButton = document.querySelector("op-refresh-button");
        this.refreshButton.onRefresh = this.reload.bind(this);
        this.minerEditor = new OpMinerEditorModal(this, "MinerEditorModal", this.load.bind(this));
        this.minerEditor.reloadComments = this.reloadComments.bind(this);
        this.logFetchModal = new LogFetchModal(this, "LogFetchModal", this.load.bind(this));
        this.rebootModal = new OpRebootMinersModal(this, "RebootMinersModal", this.handleRebootResponse.bind(this));
        this.load();
        // get url param and click element
        const activeTab = this.getQueryStringValue("active_tab");
        switch (activeTab) {
            case "History":
                $("#metricsTab").click();
                break;
            case "Activity":
                $("#activityTab").click();
                break;
            case "Tickets":
                $("#ticketsTab").click();
                break;
            case "Comments":
                $("#commentsTab").click();
                break;
            case "Tags":
                $("#tagsTab").click();
                break;
        }
    }
    onMinerLink(newMiner) {
        const [base, minerId] = window.location.href.split("id=");
        window.location.href = `${base}id=${newMiner.id}`;
    }
    reloadComments() {
        this.commentsPanel.loadComments();
    }
    onStatsLoaded(resp) {
        this.getUnsupportedModels().then((models) => {
            if (models.length === 0) {
                $(".warning-banner").addClass("hide");
                return;
            }
            this.checkForUnsupportedModel(models);
        });
    }
    onlineStatusLoaded(isOnline) {
        if (!isOnline) {
            $("#btnReboot").attr("disabled", "disabled");
            return;
        }
        $("#btnReboot").removeAttr("disabled");
    }
    checkForUnsupportedModel(unsupportedModels) {
        const model = $("#model").text();
        const foundModel = unsupportedModels.filter((unsupportedModel) => {
            return model === unsupportedModel;
        })[0];
        if (!foundModel) {
            $(".warning-banner").addClass("hide");
            return;
        }
        $(".warning-banner").removeClass("hide");
    }
    reload() {
        return __awaiter(this, void 0, void 0, function* () {
            this.loadStatCards();
            yield this.metricsPanel.reloadCharts();
        });
    }
    load() {
        this.ticketPanel.loadTickets(this.minerId);
        this.minerEditor.preloadMiner(this.minerId);
        this.detailsPanel.openMinerDetailsView({ minerId: this.minerId });
        this.loadStatCards();
    }
    checkPermission() {
        this.minerId = parseInt(window.location.search.toLowerCase().replace("?id=", ""));
        this.get(this.minerPermissionUrl + this.minerId).then((resp) => {
            if (!resp.hasPermission) {
                this.toggleNoPermission(true);
                return;
            }
            this.toggleNoPermission(false);
            this.init();
        });
    }
    loadStatCards() {
        this.get(`/miner/stats/uptime?id=${this.minerId}`).then((resp) => {
            $("#uptimeStat").text(resp.uptime);
        });
        this.get(`/miner/stats/fanspeed?id=${this.minerId}`).then((resp) => {
            if (!resp.fanspeeds)
                return;
            if (resp.fanspeeds.length === 0) {
                $("#fanSpeedStat").text("N/A");
                return;
            }
            $("#fanSpeedStat").html("<p>" + resp.fanspeeds.join("/<wbr>") + "</p>");
        });
        this.get(`/miner/stats/hashboardtemp?id=${this.minerId}`).then((resp) => {
            if (!resp.hashboardTemps)
                return;
            if (resp.hashboardTemps.length === 0) {
                $("#tempStat").text("N/A");
                return;
            }
            let pcbTemps = resp.hashboardTemps
                .sort((a, b) => a.hashboard < b.hashboard ? a.hashboard : b.hashboard)
                .map(x => x.temperature)
                .join("/<wbr>");
            $("#tempStat").html("<p>" + pcbTemps + "</p>");
        });
        this.get(`/miner/stats/hashrate?id=${this.minerId}`).then((resp) => {
            $("#hashrateStat").text(this.parseHashrate(resp.hashingTypeId, resp.hashrate));
        });
    }
    parseHashrate(hashingType, val) {
        return HashrateUtil.parseHashrate(val, hashingType);
    }
    toggleNoPermission(visible) {
        if (!visible) {
            $(".no-access").removeClass("active");
            $(".miner-info").addClass("active");
            return;
        }
        $(".no-access").addClass("active");
        $(".miner-info").removeClass("active");
    }
    createSupportTicket() {
        window.sessionStorage.setItem("ticket_cache", JSON.stringify([this.minerId]));
        OptiFleetMaster.openTab(`Administration/Tickets?ticket_cache=true`);
    }
    handleMinerEditorClick() {
        this.minerEditor.setInputValues(this.minerEditor.miner); //force reset
        this.minerEditor.open();
    }
    handleFetchLogsClick() {
        this.logFetchModal.open(this.minerId);
    }
    handleConfigurePoolsClick() {
        if (this.detailsPanel.view.viewType === MinerDetailsPanelViewVariant.MinerDetails && this.detailsPanel.view.minerInfo) {
            this.poolConfigModal.open(this.detailsPanel.view.minerInfo);
        }
    }
    rebootMiner() {
        this.rebootModal.open([this.minerId]);
    }
    handleRebootResponse(resp) {
        this.rebootModal.close();
        if (!resp.success) {
            this.showErrorMessage("Reboot attempt failed. Custom firmware is not supported by this reboot feature. Please create a support ticket if this problem persists.");
            return;
        }
        this.showSuccessMessage("Miner reboot command has been sent.");
    }
    toggleTab(tab) {
        $(tab).addClass("selected");
        $(tab).siblings(".tab").removeClass("selected");
        $(".metrics-panel,.tickets-panel,.comments-panel,.activity-panel,.tags-panel").removeClass("active");
        if (tab.innerText === "Metrics") {
            $(".metrics-panel").addClass("active");
            return;
        }
        if (tab.innerText === "Activity") {
            $(".activity-panel").addClass("active");
            return;
        }
        if (tab.innerText === "Tickets") {
            $(".tickets-panel").addClass("active");
            return;
        }
        if (tab.innerText === "Comments") {
            $(".comments-panel").addClass("active");
        }
        if (tab.innerText === "Tags") {
            $(".tags-panel").addClass("active");
        }
    }
}

class CurtailmentEvents extends OptiFleetPage {
    constructor(page) {
        super();
        this.page = page;
    }
    formatDuration(duration) {
        const SECONDS = 1;
        const MIN = SECONDS * 60;
        const HOUR = MIN * 60;
        const DAY = HOUR * 24;
        let d = duration;
        const days = Math.floor(d / DAY);
        d = d - (days * DAY);
        const hours = Math.floor(d / HOUR);
        d = d - (hours * HOUR);
        const minutes = Math.floor(d / MIN);
        d = d - (minutes * MIN);
        const seconds = d;
        return `${days}d ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    render(events) {
        const tempData = {
            events: events.map((e) => {
                return Object.assign(Object.assign({}, e), { start: window.moment(new Date(e.start)).format("MM/DD/YYYY HH:mm"), end: window.moment(new Date(e.end)).format("MM/DD/YYYY HH:mm"), duration: this.formatDuration(e.duration) });
            }),
        };
        const elem = this.page.mustache.to_html(CurtailmentEvents.eventsTableTemplate, tempData);
        $("#tab-content-events").empty().append(elem);
    }
}
CurtailmentEvents.eventsTableTemplate = `
                    <table class="m-table">
                        <thead class="m-table-header">
                            <tr class="m-table-row">
                                <th class="m-table-cell m-table-column-header-cell">Type</th>
                                <th class="m-table-cell m-table-column-header-cell" style="width: 15%">Start</th>
                                <th class="m-table-cell m-table-column-header-cell" style="width: 15%">End</th>
                                <th class="m-table-cell m-table-column-header-cell">Duration</th>
                                <th class="m-table-cell m-table-column-header-cell" style="width: 25%">Comments/Notes</th>
                                <th class="m-table-cell m-table-column-header-cell">Site</th>
                            </tr>
                        </thead>
                        <tbody class="m-table-body">
                            {{#events}}
                                <tr class="m-table-row">
                                    <th class="m-table-cell">{{type}}</th>
                                    <th class="m-table-cell">{{start}}</th>
                                    <th class="m-table-cell">{{end}}</th>
                                    <th class="m-table-cell">{{duration}}</th>
                                    <th class="m-table-cell">{{description}}</th>
                                    <th class="m-table-cell">{{siteName}}</th>
                                </tr>
                            {{/events}}
                        </tbody>
                    </table>
        `;

function renderRuleType(rule) {
    let d = (str) => window.moment(str).format("MM-DD-YY hh:mma");
    switch (rule.type) {
        case "market":
            return "Market " + `($${rule.priceThresholdDollars})`;
        case "system_demand":
            return "System Demand " + `(${new Intl.NumberFormat().format(rule.demandThresholdWatts)} MW)`;
        case "schedule":
            return "Scheduled " + `(${d(rule.start)} - ${d(rule.end)})`;
    }
}
class Curtailment extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: false, elemId: "ddlSites" });
        this.tabs = {
            "Rules": $(`#tab-rules`),
            "Events": $(`#tab-events`),
        };
        this.tabContent = {
            "Rules": $(`#tab-content-rules`),
            "Events": $(`#tab-content-events`),
        };
        this.currentTab = `Rules`;
        this.mustache = window.Mustache;
        this.canEdit = window.canEdit;
        this.dialogNewRule = document.getElementById("dialogNewRule");
        this.dialogEditRule = document.getElementById("dialogEditRule");
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        this.ruleForm = new RuleForm(this);
        this.configForm = new ConfigForm(this);
        this.curtailmentEvents = new CurtailmentEvents(this);
        this.canEdit = (this.canEdit.toLowerCase() === "true");
        this.changeTab(this.currentTab);
    }
    loadAndRenderAll() {
        return __awaiter(this, void 0, void 0, function* () {
            this.toggleBusy(true);
            this.currentSiteId = Number(yield this.siteCache.getSiteId());
            Promise.all([
                this.get(`Curtailment/Config?siteId=${this.currentSiteId}`),
                this.get(`Curtailment/Stats/${this.currentSiteId}`),
                this.get("Curtailment/PowerMarkets"),
                this.get(`/Curtailment/ZoneInfo?siteId=${this.currentSiteId}`),
                this.get("/ScheduledShutdowns" + `?siteId=${this.currentSiteId}`),
                this.get("/Agents?includeAllAgents=true"),
            ]).then(([config, stats, powerMarkets, zones, events, agentsResponse]) => {
                this.toggleBusy(false);
                this.curtailmentConfig = config;
                this.curtailmentStats = stats;
                this.powerMarkets = powerMarkets;
                this.zones = zones;
                this.events = events.scheduledShutdowns;
                this.agent = agentsResponse.agents.find(agent => agent.siteId == this.currentSiteId && agent.serviceName == "CurtailmentAgent");
                this.handleAgentStatus();
                this.curtailmentEvents.render(this.events);
                this.configForm.render();
                this.populateStatCards();
                this.renderRulesTable();
            });
        });
    }
    handleCompanyFilterChanged(companyId) {
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(siteId) {
        this.loadAndRenderAll();
    }
    populateStatCards() {
        $("#label-miner-capacity").text(this.curtailmentStats.minerCapacity);
        $("#label-miners-monitored-count").text(this.curtailmentStats.minersMonitoredCount);
        $("#label-unassinged-miners-count").text(this.curtailmentStats.unassignedMinersCount);
        var hashrateData = HashrateUtil.normalizeHashrate(this.curtailmentStats.totalHashrate, "Hs", HashrateUtil.getHashrateUnit(this.curtailmentStats.totalHashrate, 1));
        $("#label-total-hash-rate").text(`${hashrateData.value} ${hashrateData.unit}`);
        const powerLoad = PowerConverter.getPowerScaled(this.curtailmentStats.totalPowerConsumptionWatts, 2);
        const powerLoadUnit = PowerConverter.getPowerUnit(this.curtailmentStats.totalPowerConsumptionWatts);
        $("#label-total-calculated-power").text(`${powerLoad} ${powerLoadUnit}`);
    }
    renderRulesTable() {
        const tempData = {
            hasConfig: this.curtailmentConfig !== null,
            canEdit: this.canEdit,
            hasRules: this.curtailmentConfig && this.curtailmentConfig.rules.length > 0,
            rules: derive(() => {
                if (!this.curtailmentConfig) {
                    return [];
                }
                return this.curtailmentConfig.rules.map((r) => {
                    return {
                        ruleId: r.id,
                        description: r.description || "No description added.",
                        zones: this.renderZonesList(r.zones),
                        type: renderRuleType(r),
                    };
                });
            }),
        };
        const elem = this.mustache.to_html(Curtailment.rulesTableTemplate, tempData);
        $("#tab-content-rules").empty().append(elem);
    }
    changeTab(newTab) {
        this.tabs[this.currentTab]
            .removeClass(`active`)
            .find(`.m-heading`)
            .removeClass(`is-accent`)
            .addClass(`is-tertiary`);
        this.tabs[newTab]
            .addClass(`active`)
            .find(`.m-heading`)
            .addClass(`is-accent`)
            .removeClass(`is-tertiary`);
        this.tabContent[this.currentTab].hide();
        this.tabContent[newTab].show();
        this.currentTab = newTab;
    }
    renderZonesList(zones) {
        if (this.zones.length === zones.length) {
            return "All Zones";
        }
        return this.zones.filter((z) => zones.includes(z.zoneId)).map((z) => z.zoneName).join(", ");
    }
    handleEditButtonClick() {
        this.configForm.edit();
    }
    handleCancelButtonClick() {
        this.configForm.cancel();
    }
    closeDialogNewRule() {
        this.dialogNewRule.close();
        $(this.dialogNewRule).find(".m-modal-content").empty();
    }
    closeDialogEditRule() {
        this.dialogEditRule.close();
        $(this.dialogNewRule).find(".m-modal-content").empty();
    }
    openDialogNewRule() {
        this.dialogNewRule.showModal();
        this.ruleForm.renderRuleForm();
    }
    openDialogEditRule(ruleId) {
        this.dialogEditRule.showModal();
        this.ruleForm.renderRuleForm(Number(ruleId));
    }
    deleteRule(ruleId) {
        this.curtailmentConfig.rules.find((r) => r.id === ruleId);
        this.confirm("DELETE RULE", "Are you sure you want to delete this rule?", () => {
            this.toggleBusy(true);
            this.delete(`Curtailment/Config/${this.curtailmentConfig.id}/rules/${ruleId}`, undefined, true)
                .then((res) => {
                this.loadAndRenderAll();
                if (res.isAxiosError) {
                    this.showErrorMessage("An error occured while deleting rule.");
                    return;
                }
            });
        });
    }
    handleAgentStatus() {
        if (!this.agent) {
            $(".agent-status").hide();
            return;
        }
        this.toggleAgentStatus(this.agent.isOnline);
        $(".agent-status").show();
    }
    toggleAgentStatus(swtch) {
        let statusIcon = $(".agent-status m-icon");
        let statusText = $(".agent-status .m-code");
        if (swtch == undefined) {
            swtch = !(statusIcon.attr("name") === "wifi");
        }
        if (swtch) {
            statusIcon.attr("name", "wifi");
            statusIcon.attr("status", "success");
            statusText.text("CURTAILMENT AGENT ONLINE");
        }
        else {
            statusIcon.attr("name", "wifi-off");
            statusIcon.attr("status", "warning");
            statusText.text("CURTAILMENT AGENT OFFLINE");
        }
    }
}
Curtailment.rulesTableTemplate = `
            <div class="m-stack">
                {{#hasRules}}
                    <table class="m-table">
                        <thead class="m-table-header">
                            <tr class="m-table-row" style="vertical-align: middle;">
                                <th class="m-table-cell m-table-column-header-cell">Rule</th>
                                <th class="m-table-cell m-table-column-header-cell">Type</th>
                                <th class="m-table-cell m-table-column-header-cell" style="width: 40%;">
                                    <div class="m-stack is-horizontal has-space-between is-align-center">
                                        <span class="m-text">Zones</span>
                                        <button class="m-button is-tertiary" type="button" onclick="c.openDialogNewRule();" style="height: 1.5rem;">
                                            <span class="m-button-label">New Curtailment Rule</span>
                                        </button>
                                    </div>

                                </th>
                            </tr>
                        </thead>
                        <tbody class="m-table-body">
                            {{#rules}}
                                <tr class="m-table-row">
                                    <th class="m-table-cell sentence-case">{{description}}</th>
                                    <th class="m-table-cell">{{type}}</th>
                                    <th class="m-table-cell">
                                        <div class="m-stack is-horizontal has-space-between">
                                            <span class="m-text">{{zones}}</span>
                                            {{#canEdit}}
                                                <div class="m-form-group is-grouped-right m-stack is-horizontal has-space-l">
                                                    <m-icon class="cursor-pointer" name="pencil" onclick="c.openDialogEditRule('{{ruleId}}');" style="color: var(--color-icon-default);"></m-icon>
                                                    <m-icon class="cursor-pointer" name="trash-2" onclick="c.deleteRule({{ruleId}});" style="color: var(--color-icon-default);"></m-icon>
                                                </div>
                                            {{/canEdit}}
                                        </div>
                                    </th>
                                </tr>
                            {{/rules}}
                        </tbody>
                    </table>
                {{/hasRules}}
                {{^hasRules}}
                    <div class="m-stack">
                        <div class="m-form-group is-grouped-right">
                            <button class="m-button is-secondary" type="button" onclick="c.openDialogNewRule();">
                                <span class="m-button-label">New Curtailment Rule</span>
                            </button>
                        </div>
                        <span class="m-text" style="text-align: center;">No rules have been configured.</span>
                    </div>
                {{/hasRules}}
            </div>
        `;

class Assets extends OptiFleetPage {
    constructor(siteIdGetter) {
        super();
        this.siteIdGetter = siteIdGetter;
        this.assetsUrl = "/Assets";
        this.assetModelsUrl = "/ManufacturerModels";
        this.assetStatusUrl = "/AssetStatus";
        this.assetTypesUrl = "/AssetTypes";
        this.assetGrid = $("#assetsGrid");
        this.assetsFilters = new AssetsFilters(this);
        this.editForm = new AssetFormView("EditAssetModalView", $("#EditAssetModalViewWrapper"));
        this.editFormModal = new OpProgressionModalBase("EditAssetModal", [this.editForm], { submitUrl: this.assetsUrl, submitType: ProgressionModalSubmitType.PATCH });
        this.editFormModal.onClose = this.loadAssets.bind(this);
        this.initGrid();
        this.getAssetModels();
        this.getAssetStatuses();
        this.getAssetTypes();
    }
    loadAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            this.isLoading = true;
            let siteId = yield this.siteIdGetter();
            this.get(`${this.assetsUrl}?siteId=${siteId}`).then(res => {
                this.isLoading = false;
                this.populateAssetsGrid(res.assets);
                this.assetsFilters.assets = res.assets;
            });
        });
    }
    getAssetModels() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.get(this.assetModelsUrl);
            this.assetModels = res;
        });
    }
    getAssetStatuses() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.get(this.assetStatusUrl);
            this.assetStatuses = res.statuses;
        });
    }
    getAssetTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.get(this.assetTypesUrl);
            this.assetTypes = res.assetTypes;
        });
    }
    initGrid() {
        const openEditModalHandler = this.openEditAsset.bind(this);
        this.assetGrid.kendoGrid({
            pageable: {
                pageSizes: [10, 100, 500, 1000, 5000],
                buttonCount: 5
            },
            sortable: true,
            mobile: true,
            resizable: true,
            scrollable: true,
            //filter: this.onFilterChange.bind(this),
            dataBound: function () {
                this.autoFitColumns();
            },
            columns: [
                { selectable: true, width: "55px" },
                {
                    command: {
                        name: "Edit", iconClass: { edit: "pencil" }, click: function (e) {
                            e.preventDefault();
                            const tr = $(e.target).closest("tr");
                            const data = this.dataItem(tr);
                            openEditModalHandler(data);
                        },
                    },
                    width: "105px",
                },
                { field: "assetId", title: "Asset ID" },
                { field: "assetName", title: "Asset Name" },
                { field: "assetTypeName", title: "Type" },
                { field: "status", title: "Status" },
                { field: "serialNumber", title: "Serial Number" },
                { field: "sku", title: "SKU" },
                { field: "manufacturerName", title: "Manufacturer" },
                { field: "modelName", title: "Model" },
                { field: "modelDescription", title: "Model Description" },
                { field: "dateCreated", title: "Date Created", template: ({ dateCreated }) => dateCreated != null ? window.moment.utc(dateCreated).local().format("M/D/YYYY") : "" },
                { field: "warrantyDate", title: "Warranty Date", template: ({ warrantyDate }) => warrantyDate != null ? window.moment.utc(warrantyDate).local().format("M/D/YYYY") : "" },
                { field: "state", title: "State" },
                { field: "city", title: "City" },
                { field: "address", title: "Address" },
                //{ title: "", width: "55px", locked: true, template: MinerGridColumnTemplates.getElipsisTemplate() }
            ]
        });
    }
    populateAssetsGrid(assets) {
        const grid = this.assetGrid.data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: assets,
            pageSize: 100,
            schema: {
                model: {
                    assetId: "assetId"
                }
            }
        });
        grid.setDataSource(dataSource);
        grid.refresh();
    }
    toggleActionsDropdownMenu(id) {
        const elem = id.indexOf("#") === 0 ? $(id) : $(`#${id}`);
        const isHidden = elem.attr("aria-hidden");
        elem.attr("aria-hidden", isHidden ? "" : "true");
        $(".m-menu-item").removeAttr("aria-current");
        // FIND AND CLOSE ALL SUBMENUS
        elem.find(".m-dropdown-menu")
            .attr("aria-hidden", "true");
    }
    openEditAsset(row) {
        const initData = {
            asset: row,
            manufacturerModels: this.assetModels,
            statusList: this.assetStatuses,
            assetTypes: this.assetTypes
        };
        this.editForm.load(initData);
        this.editForm.companyId = this.getSelectedCompanyId();
        this.editForm.show();
        this.editFormModal.open();
    }
}

class ScheduledShutdownFilters extends OptiFleetPage {
    constructor(excusedEvents) {
        super();
        this.excusedEvents = excusedEvents;
        this.storedFiltersSelector = "excusedEventFilters";
        this.events = [];
        this.titleFilter;
        this.descriptionFilter;
        this.startTimeFilter;
        this.durationFilter;
        // show means the filter is visible in the filter section
        this.filters = [
            { label: "Title", id: "title", show: true, options: [] },
            { label: "Description", id: "description", show: true, options: [] },
        ];
        this.activeFilters = {
            title: "",
            description: "",
        };
        this.init();
    }
    init() {
        this.initFilters();
        let opFilters = [];
        this.filters.forEach(filter => {
            const filterName = `${filter.id}Filter`;
            this[filterName] = new OpFilter(filter.id, this.filterMiners.bind(this), this.clearFilter.bind(this), filter.options);
            opFilters.push(this[filterName]);
            if (!filter.show) {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
        });
        new SelectFilters("moreFilters", this.filters, this.changeActiveFilters.bind(this));
        new ClearFilters("clearFilters", opFilters);
    }
    initFilters() {
        const storedFiltersStr = localStorage.getItem(this.storedFiltersSelector);
        let storedFilters;
        try {
            storedFilters = JSON.parse(storedFiltersStr);
        }
        catch (e) {
            return;
        }
        if (!storedFilters) {
            return;
        }
        storedFilters.forEach(storedFilter => {
            // if is filter
            if (storedFilter.hasOwnProperty("id") && storedFilter.hasOwnProperty("label") && storedFilter.hasOwnProperty("show")) {
                var filter = this.filters.find((filter) => filter.id === storedFilter.id);
                if (filter) {
                    filter.show = storedFilter.show;
                }
            }
        });
    }
    filterMiners(formVal, propertyVal) {
        this.activeFilters[propertyVal] = formVal;
        let filteredEvents = this.events;
        if (!filteredEvents) {
            return;
        }
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (!formVal || formVal === "" || formVal.length === 0) {
                return;
            }
            if (isTextInput) {
                filteredEvents = filteredEvents.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredEvents = filteredEvents.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        this.excusedEvents.populateShutdowns(filteredEvents);
    }
    applyFilters() {
        let filteredEvents = this.events;
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (isTextInput) {
                filteredEvents = filteredEvents.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredEvents = filteredEvents.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        this.excusedEvents.populateShutdowns(filteredEvents);
    }
    clearFilter(id) {
        this.activeFilters[id] = "";
        this.filterMiners(id, "");
    }
    changeActiveFilters(newFilters) {
        this.filters = newFilters;
        this.filters.forEach(filter => {
            let filterRemoved = false;
            // If the filter is active and it's being remove
            if ($(`[c-id=${filter.id}]`).hasClass("active") && filter.show === false) {
                // Then clear the active state and remove the filting on the miner grid
                this[`${filter.id}Filter`].deactivateFilter();
                this.activeFilters[filter.id] = "";
                filterRemoved = true;
            }
            if (filter.show) {
                $(`[c-id=${filter.id}]`).removeClass("hide");
            }
            else {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
            if (filterRemoved) {
                this.filterMiners("", "");
            }
        });
        localStorage.setItem(this.storedFiltersSelector, JSON.stringify(this.filters));
    }
}

class ScheduledShutdowns extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: false, elemId: "scheduledShutdownsSiteFilter" });
        this.ssTypesUrl = "/ScheduledShutdownTypes";
        this.scheduledShutdownsUrl = "/ScheduledShutdowns";
        this.sites = [];
        this.canEdit = false;
        this.canEdit = $(`#${window.hfId}`).val() === "true";
        this.addScheduledShutdownModal = new OpScheduledShutdownModal(this, "ScheduledShutdownModal", () => __awaiter(this, void 0, void 0, function* () { return yield this.refreshShutdownsGrid(); }));
        this.onSiteFilterChanged = this.handleSiteChange.bind(this);
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.eventFilters = new ScheduledShutdownFilters(this);
        this.init();
    }
    init() {
        this.initGrid();
        $("#btn-add-scheduled-shutdown").on("click", this.openAddScheduledShutdownModal.bind(this));
    }
    initTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.get(this.ssTypesUrl);
            this.eventTypeList = resp.eventTypes;
        });
    }
    refreshShutdownsGrid() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteId = yield this.siteCache.getSiteId();
            const resp = yield this.get(`${this.scheduledShutdownsUrl}?siteId=${siteId}`);
            if (!resp.success) {
                this.showErrorMessage("Unable to load Scheduled Shutdowns");
                return;
            }
            this.scheduledShutdowns = resp.scheduledShutdowns;
            this.eventFilters.events = resp.scheduledShutdowns;
            this.eventFilters.applyFilters();
            this.populateShutdowns(resp.scheduledShutdowns);
        });
    }
    handleSiteChange() {
        return __awaiter(this, void 0, void 0, function* () {
            this.toggleBusy(true);
            this.sites = yield this.siteCache.getSites();
            const typesProm = this.initTypes();
            const gridProm = this.refreshShutdownsGrid();
            yield Promise.all([typesProm, gridProm]);
            this.toggleBusy(false);
        });
    }
    toggleBusy(busy) {
        $(".screen-busy").toggleClass("active", busy);
    }
    initGrid() {
        let columns = [
            { field: "scheduledShutdownId", hidden: true },
            { field: "title", title: "Title", width: 120 },
            { field: "description", title: "Description", width: 300 },
            { field: "site", title: "Site", template: this.getSiteName.bind(this), width: 100 },
            {
                field: "start", title: "Start Time", width: 100,
                template: (data) => {
                    const formatted = kendo.toString(new Date(data.start), "MM/dd/yyyy hh:mm tt");
                    return formatted;
                }
            },
            { field: "duration", title: "Duration", template: this.getDuration.bind(this), width: 100 }
        ];
        if (this.canEdit) {
            columns = [
                { command: { text: "Edit", click: this.editShutdown.bind(this) }, title: " ", width: "70px" },
                ...columns,
                { command: { text: "Delete", click: this.deleteShutdown.bind(this) }, title: " ", width: "65px" }
            ];
        }
        this.shutdownsGrid = $("#scheduled-shutdowns-grid").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 100
            },
            pageable: {
                numeric: true,
                previousNext: true,
            },
            noRecords: {
                template: this.getNoRecordsTemplate.bind(this)
            },
            filterable: false,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: false,
            columns,
        }).data("kendoGrid");
    }
    getNoRecordsTemplate() {
        return "No scheduled shutdowns have been defined";
    }
    getSiteName(data) {
        for (const site of this.sites) {
            if (site.siteId == data.siteId) {
                return site.siteName;
            }
        }
        return "Unknown";
    }
    getDuration(data) {
        return `${MathUtil.round(MathUtil.divide(data.duration, 60), 0)} minutes`;
    }
    deleteShutdown(event) {
        event.preventDefault();
        this.confirm("Delete Scheduled Shutdown", "Are you sure you want to delete this scheduled shutdown?", () => {
            const row = $(event.currentTarget).closest("tr");
            const dataItem = this.shutdownsGrid.dataItem(row);
            const scheduledShutdownId = dataItem.get("scheduledShutdownId");
            const data = {
                ScheduledShutdownId: scheduledShutdownId
            };
            this.delete(this.scheduledShutdownsUrl, data).then((resp) => __awaiter(this, void 0, void 0, function* () {
                this.toggleBusy(true);
                yield this.refreshShutdownsGrid();
                this.toggleBusy(false);
            }));
        });
    }
    handleCompanyFilterChanged() {
        if (this.getSelectedCompanyId() <= 0) {
            this.toggleSelectCompany(true);
            return;
        }
        else {
            this.toggleSelectCompany(false);
        }
        this.siteCache.loadSites();
    }
    editShutdown(event) {
        let tr = $(event.target).closest("tr");
        let ssId = Number(tr.children()[1].innerText);
        let targetSS = this.scheduledShutdowns.find(ss => ss.scheduledShutdownId === ssId);
        this.addScheduledShutdownModal.open(targetSS);
    }
    openAddScheduledShutdownModal() {
        this.addScheduledShutdownModal.beforeOpen(null).then(() => {
            this.addScheduledShutdownModal.open(null);
        });
    }
    populateShutdowns(scheduledShutdowns) {
        const dataSource = new self.kendo.data.DataSource({
            data: scheduledShutdowns,
            pageSize: 20
        });
        this.shutdownsGrid.setDataSource(dataSource);
    }
}

class Drilldown extends OptiFleetPage {
    constructor() {
        super();
        this.initGrid();
        this.loadMiners();
    }
    loadMiners() {
        const view = this.getQueryStringValue("view");
        const siteId = this.getQueryStringValue("siteId");
        switch (view) {
            case DrilldownView.OFFLINE:
                new OfflineView(this.onMinerDataLoaded, siteId);
                return;
            case DrilldownView.LOW_HASHING:
                new LowHashingView(this.onMinerDataLoaded, siteId);
                return;
            case DrilldownView.NON_HASHING:
                new NonHashingView(this.onMinerDataLoaded, siteId);
                return;
            case DrilldownView.RMA:
                new RMAView(this.onMinerDataLoaded, siteId);
                return;
            case DrilldownView.PENDING_RMA:
                new PendingRMAView(this.onMinerDataLoaded, siteId);
                return;
            case DrilldownView.ERROR:
                new ErrorView(this.onMinerDataLoaded, siteId);
                return;
            default:
                //todo
                return;
        }
    }
    onMinerDataLoaded(miners) {
        Drilldown.miners = miners;
    }
    initGrid() {
        $("#minerList").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20
            },
            pageable: {
                numeric: false,
                previousNext: false,
            },
            scrollable: {
                virtual: true
            },
            height: "100%",
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            noRecords: {
                template: "<div class=\"no-records\">No data is available</div>"
            },
            columns: [
                { command: { text: "View Stats", click: this.showDetails.bind(this) }, title: " ", width: "150px" },
                { field: "name", title: "Name", filterable: { extra: false, search: true } },
                { field: "model", title: "Model", filterable: { multi: true } },
                { field: "location", title: "Location", width: 160, filterable: { extra: false, search: true } },
                { field: "serialNumber", title: "Serial Number", width: 190, filterable: { extra: false, search: true } },
                { field: "ipAddress", title: "IP Address", width: 150, filterable: { extra: false, search: true } },
                { field: "installDate", title: "Install Date", hidden: true, width: 140, filterable: { multi: true } },
                { field: "rmaDate", title: "RMA Date", hidden: true, width: 140, filterable: { multi: true } },
                { field: "status", title: "Status", hidden: true, width: 180, filterable: { multi: true } },
                { field: "hashrate", title: "Hash Rate", hidden: true, width: 140 },
                { field: "expectedHashrate", title: "Expected Hash Rate", hidden: true, width: 180 }
            ]
        });
    }
    showDetails(e) {
        e.preventDefault();
        const grid = $("#minerList").data("kendoGrid");
        const row = $(e.currentTarget).closest("tr");
        const dataItem = grid.dataItem(row);
        window.location.assign(`/Content/Miners/IndividualMiner.aspx?id=${dataItem.get("id")}`);
    }
    exportToExcel() {
        event.preventDefault();
        const headers = $("#minerList").find(".k-grid-header th").get();
        let exportHeaders = [];
        for (let cellStart = 1; cellStart <= headers.length; cellStart++) {
            if ($(headers[cellStart]).css("display") !== "none") {
                exportHeaders.push(headers[cellStart]);
            }
        }
        let exportRows = [];
        Drilldown.miners.forEach((miner) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart <= headers.length; cellStart++) {
                if ($(headers[cellStart]).css("display") !== "none") {
                    newRow.append(this.getMinerPropertyAsCell(miner, cellStart));
                }
            }
            exportRows.push(newRow);
        });
        $("#drilldownActionsDropdown").attr("aria-hidden", "true");
        ExcelUtility.exportToExcel(exportHeaders, exportRows, "miners");
    }
    exportToCsv() {
        event.preventDefault();
        const headers = $("#minerList").find(".k-grid-header th").get();
        let exportHeaders = [];
        for (let cellStart = 1; cellStart < headers.length; cellStart++) {
            if ($(headers[cellStart]).css("display") !== "none") {
                exportHeaders.push(headers[cellStart]);
            }
        }
        let exportRows = [];
        Drilldown.miners.forEach((miner) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart < headers.length; cellStart++) {
                if ($(headers[cellStart]).css("display") !== "none") {
                    newRow.append(this.getMinerPropertyAsCell(miner, cellStart));
                }
            }
            exportRows.push(newRow);
        });
        $("#drilldownActionsDropdown").attr("aria-hidden", "true");
        ExcelUtility.exportToCSV(exportHeaders, exportRows, "miners");
    }
    getMinerPropertyAsCell(miner, index) {
        let prop = "";
        switch (index) {
            case 1:
                prop = miner.name;
                break;
            case 2:
                prop = miner.model;
                break;
            case 3:
                prop = miner.location;
                break;
            case 4:
                prop = miner.serialNumber;
                break;
            case 5:
                prop = miner.ipAddress;
                break;
            case 6:
                prop = miner.installDate;
                break;
            case 7:
                prop = miner.rmaDate;
                break;
            case 8:
                prop = miner.status;
                break;
            case 9:
                prop = miner.hashrate;
                break;
            case 10:
                prop = miner.expectedHashrate;
                break;
        }
        const cell = document.createElement("td");
        cell.innerText = prop;
        return cell;
    }
}
var DrilldownView;
(function (DrilldownView) {
    DrilldownView["OFFLINE"] = "offline";
    DrilldownView["RMA"] = "rma";
    DrilldownView["NON_HASHING"] = "nonhashing";
    DrilldownView["LOW_HASHING"] = "lowhashing";
    DrilldownView["PENDING_RMA"] = "pendingrma";
    DrilldownView["ERROR"] = "error";
})(DrilldownView || (DrilldownView = {}));

var styles$1 = i$4``;

var styles = i$4`m-stack::part(stack) {
  padding: 0rem 0.5rem;
  border: 1px solid var(--color-border-primary);
  border-radius: var(--radius-m);
  width: max-content;
}

.arrow-icon {
  color: var(--color-text-tertiary);
}`;

let MutedLinkButton = class MutedLinkButton extends s$1 {
    render() {
        return x `<m-stack horizontal class="muted-link-button" space="xs">
            <m-text variant="tertiary">
                View Detailed Sensor Graph
            </m-text>
            <m-icon class="arrow-icon" name="arrow-up-right" size="l"></m-icon>
        </m-stack>`;
    }
};
MutedLinkButton.styles = styles;
MutedLinkButton = __decorate([
    t$2("muted-link-button")
], MutedLinkButton);

const columnHelper = createColumnHelper();
const columns = [
    columnHelper.accessor("isOnline", {
        cell: (info) => info.row.original.isOnline
            ? x `<m-icon size="xl" name="check" status="success"></m-icon>`
            : x `<m-icon size="xl" name="ban" status="error"></m-icon>`,
        header: "Sensor",
    }),
    columnHelper.accessor("sensorName", {
        header: "Sensor Name",
        cell: (info) => {
            const isRowHovered = info.rowHovered;
            if (isRowHovered) {
                return x `<muted-link-button></muted-link-button>`;
            }
            return info.cell.row.original.sensorName;
        }
    }),
    columnHelper.accessor("temp", {
        header: "Temperature",
        cell: (info) => {
            const temp = info.row.original.temp;
            const variant = temp >= SensorsReport.temperatureThreshold ? "error" : "primary";
            return x `
                <m-text as="span" variant=${variant}>
                    ${temp}Â°F
                </m-text>
            `;
        },
    }),
    columnHelper.accessor("humidity", {
        header: "Humidity",
        cell: (info) => `${info.row.original.temp}%`,
    }),
    columnHelper.accessor("voltage", {
        header: "Voltage",
        cell: (info) => `${info.row.original.voltage}V`,
    }),
    columnHelper.accessor("facility", {
        header: "Zone",
    }),
    columnHelper.accessor("lastSample", {
        cell: (info) => `${kendo.toString(new Date(info.row.original.lastSample), "MM/dd hh:mm tt")}`,
        header: "Last Reading",
    }),
];
let SensorsTable = class SensorsTable extends s$1 {
    constructor() {
        super(...arguments);
        this.sensors = [];
        this.hoveredRowId = "";
    }
    _handleRowClick(e) {
        const row = e.detail.row;
        const sensorId = row.original.sensorId;
        this.dispatchEvent(new CustomEvent("row-click", { bubbles: true, composed: true, detail: { sensorId, }, }));
    }
    render() {
        return x `<m-table
        class="test"
            .data=${this.sensors}
            .columns=${columns}
            @row-click=${this._handleRowClick}
            layout="auto"
        >
        </m-table>`;
    }
};
SensorsTable.styles = styles$1;
__decorate([
    n$1()
], SensorsTable.prototype, "sensors", void 0);
__decorate([
    r$1()
], SensorsTable.prototype, "hoveredRowId", void 0);
SensorsTable = __decorate([
    t$2("sensors-table")
], SensorsTable);

class SensorsReport extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: false, elemId: "ddlSites" });
        this.sitesUrl = "/sites";
        this.sensorsUrl = "/sensors?siteId=";
        this.siteDetailsUrl = "/siteDetails?siteId=";
        this.minute = 60 * 1000;
        this.isInitialLoad = true;
        this.init();
        this.sensorGraphPanel = new SensorGraphPanel();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        this.datePicker = new DatePicker("#datePicker", this.loadChart.bind(this), {
            start: window.moment().subtract(1, "days"),
            end: window.moment(),
            label: "Last 24 Hours"
        }, undefined, {
            alwaysShowCalendars: false,
        });
        const sensorsTable = document.querySelector("sensors-table");
        sensorsTable.addEventListener("row-click", (e) => {
            const row = e.detail.row;
            const sensorId = row.original.sensorId;
            this.sensorGraphPanel.open(sensorId);
        });
    }
    init() {
        this.aggTemperatureChart = new AggTemperatureGraph();
        $("#zoneFilter").kendoMultiSelect({
            dataSource: new kendo.data.DataSource({ data: [] }),
            dataTextField: "zoneName",
            dataValueField: "zoneName",
            autoClose: false,
            placeholder: "All Zones",
            downArrow: true,
            change: (e) => this.handleZoneFilterChange(),
        });
    }
    handleCompanyFilterChanged(companyId) {
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(siteId) {
        this.aggTemperatureChart.setSiteId(siteId);
        this.reload();
    }
    loadChart(params) {
        return __awaiter(this, void 0, void 0, function* () {
            params.siteId = parseInt(yield this.siteCache.getSiteId());
            this.aggTemperatureChart.loadChartData(params);
        });
    }
    reload() {
        return __awaiter(this, void 0, void 0, function* () {
            this.toggleBusy(true);
            const siteId = yield this.siteCache.getSiteId();
            const zoneList = $("#zoneFilter").data("kendoMultiSelect");
            SensorsReport.zoneNames = zoneList.value();
            const sensorsUrl = `${this.sensorsUrl}${siteId}`;
            const siteDetailsReq = this.get(`${this.siteDetailsUrl}${siteId}`);
            const sensorsReq = this.get(sensorsUrl);
            const [siteDetailsResp, sensorsResp] = yield Promise.all([
                siteDetailsReq,
                sensorsReq,
            ]);
            this.setSensors(sensorsResp.sensors);
            this.populateSensors();
            if (sensorsResp.sensors.length > 0) {
                const params = this.datePicker.getParams();
                const now = window.moment();
                const tenMinutes = 1000 * 60 * 10;
                params.start < (now.startOf("day").valueOf() + tenMinutes);
                params.start < (now.valueOf() - tenMinutes);
                this.loadChart(params);
            }
            $("#zoneFilter").data("kendoMultiSelect").setDataSource(new kendo.data.DataSource({ data: siteDetailsResp.zones }));
            this.toggleBusy(false);
        });
    }
    handleZoneFilterChange() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteId = parseInt(yield this.siteCache.getSiteId());
            const zoneList = $("#zoneFilter").data("kendoMultiSelect");
            SensorsReport.zoneNames = zoneList.value();
            const sensorsUrl = `${this.sensorsUrl}${siteId}`;
            const sensorsResp = yield this.get(sensorsUrl);
            this.setSensors(sensorsResp.sensors);
            this.populateSensors();
            this.aggTemperatureChart.populateChartData();
        });
    }
    setSensors(sensors) {
        SensorsReport.sensors = derive(() => {
            const filteredSensors = SensorsReport.zoneNames.length === 0
                ? sensors
                : sensors.filter((s) => SensorsReport.zoneNames.includes(s.facility));
            const offlineSensorsSorted = filteredSensors.filter((s) => !s.isOnline).toSorted((a, b) => b.temp - a.temp);
            const onlineSensorsSorted = filteredSensors.filter((s) => s.isOnline).toSorted((a, b) => b.temp - a.temp);
            return offlineSensorsSorted.concat(onlineSensorsSorted).map((s) => (Object.assign(Object.assign({}, s), { clickable: true })));
        });
    }
    populateSensors() {
        const sensorsTable = document.querySelector("sensors-table");
        $(".error-placeholder").empty();
        $(".empty").hide();
        $("#main-area").show();
        if (SensorsReport.sensors.length === 0) {
            $("#main-area").hide();
            $(".empty").show();
            $(".error-placeholder").append("No sensors found for selected site. Please choose another site.");
            sensorsTable.sensors = [];
            return;
        }
        sensorsTable.sensors = SensorsReport.sensors;
        this.sensorGraphPanel.setSensorList(SensorsReport.sensors);
    }
    getLineStat(stat) {
        if (stat < 0) {
            stat = 0;
        }
        if (stat > 97) {
            stat = 97;
        }
        return stat;
    }
}
SensorsReport.temperatureThreshold = 89;

class UserActivation extends OptiFleetService {
    constructor() {
        super();
        this.activateUrl = "/ActivateUser";
        this.securityQuestionUrl = "/SecurityQuestions";
        this.loadSecurityQuestions();
    }
    loadSecurityQuestions() {
        this.get(this.securityQuestionUrl)
            .then((resp) => {
            this.populateQuestionDropDown(resp.questions);
        });
    }
    populateQuestionDropDown(questions) {
        $("#securityQuestions").kendoDropDownList({
            dataTextField: "question",
            dataValueField: "id",
            dataSource: questions,
            height: 100,
            autoWidth: true,
        });
    }
    toggleActivateButton() {
        const securityAnswer = $("#securityAnswer").val();
        if (securityAnswer.length > 0) {
            $("#completeButton").removeAttr("disabled");
            return;
        }
        $("#completeButton").attr("disabled", "disabled");
    }
    toggleNextButton() {
        const password = $("#password").val();
        const confirmPass = $("#confirmPass").val();
        const firstname = $("#firstname").val();
        const lastname = $("#lastname").val();
        if (password.length > 0
            && confirmPass.length > 0
            && firstname.length > 0
            && lastname.length > 0) {
            $("#nextBtn").removeAttr("disabled");
            return;
        }
        $("#nextBtn").attr("disabled", "disabled");
    }
    complete() {
        this.completeActivation();
    }
    clearValidation() {
        $("#errorPasswordsDontMatch").hide();
        $("#errorInvalidPassword").hide();
    }
    isValid() {
        const password = $("#password").val();
        const confirmPass = $("#confirmPass").val();
        if (password !== confirmPass) {
            $("#errorPasswordsDontMatch").show();
            return false;
        }
        const symbols = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]+/;
        const hasSymbols = symbols.test(password);
        const hasNumbers = password.match(/^[^0-9]+$/) ? false : true;
        const hasChars = password.match(/^[^a-zA-Z]+$/) ? false : true;
        if (password.length < 8 || !hasSymbols || !hasNumbers || !hasChars) {
            $("#errorInvalidPassword").show();
            return;
        }
        return true;
    }
    next() {
        this.clearValidation();
        const isValid = this.isValid();
        if (!isValid) {
            return;
        }
        $(".activate-panel").removeClass("active");
        $(".question-panel").addClass("active");
    }
    back() {
        $(".activate-panel").addClass("active");
        $(".question-panel").removeClass("active");
    }
    completeActivation() {
        this.toggleActivationBusy(true);
        const password = $("#password").val();
        const firstName = $("#firstname").val();
        const lastName = $("#lastname").val();
        const nonce = window.location.search.replace("?nonce=", "");
        const securityAnswer = $("#securityAnswer").val();
        const questions = $("#securityQuestions").data("kendoDropDownList");
        const questionId = questions.value();
        const activateData = {
            password: btoa(password),
            firstName,
            lastName,
            nonce: nonce,
            questionId: questionId,
            answer: securityAnswer
        };
        this.post(this.activateUrl, activateData)
            .then((resp) => {
            this.toggleActivationBusy(false);
            if (!resp.success) {
                $(".username-in-use").removeClass("hide");
                this.back();
                return;
            }
            window.location.href = "/Content/Login/Start.aspx";
        });
    }
    toggleActivationBusy(isBusy) {
        if (!isBusy) {
            $(".login-busy").removeClass("active");
            return;
        }
        $(".login-busy").addClass("active");
    }
}

class MinerStats extends OptiFleetPage {
    constructor() {
        super();
        this.minersIpUrl = "/MinerIps";
        this.rebootUrl = "/RebootMiners";
        this.minute = 60 * 1000;
        this.buildIpList();
        this.init();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        this.rebootModal = new OpRebootMinersModal(this, "RebootMinersModal", this.handleRebootResponse.bind(this));
        setInterval(() => {
            this.loadQueries();
        }, 120000);
    }
    onlineStatusLoaded(isOnline) {
        if (!isOnline) {
            $("#btnReboot").attr("disabled", "disabled");
            return;
        }
        $("#btnReboot").removeAttr("disabled");
    }
    handleCompanyFilterChanged() {
        this.loadMinerIps();
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged() {
        this.loadMinerIps();
    }
    buildIpList() {
        var _a;
        $("#ipFilter").kendoDropDownList({
            dataTextField: "ip",
            dataValueField: "id",
            dataSource: [],
            filter: "contains",
            height: 200,
            autoWidth: true,
            value: (_a = this.minerId) === null || _a === void 0 ? void 0 : _a.toString(),
            virtual: {
                itemHeight: 26,
                valueMapper: (options) => {
                    this.convertValues(options);
                }
            },
            change: this.onMinerChanged.bind(this)
        });
        this.loadMinerIps();
    }
    convertValues(value) {
        var data = {};
        value = $.isArray(value) ? value : [value];
        for (var idx = 0; idx < value.length; idx++) {
            data["values[" + idx + "]"] = value[idx];
        }
        return data;
    }
    loadMinerIps() {
        this.get(this.minersIpUrl)
            .then((resp) => {
            this.populateIpList(resp);
        });
    }
    onMinerChanged() {
        const minerId = $("#ipFilter").data("kendoDropDownList");
        this.minerId = parseInt(minerId.value());
        this.load();
    }
    populateIpList(resp) {
        if (resp.ips.length === 0) {
            this.showNullState("There aren't any miners setup yet.");
            return;
        }
        this.hideNullState();
        const firstMinerIp = resp.ips[0];
        if (firstMinerIp && firstMinerIp.id !== this.minerId) {
            this.minerId = firstMinerIp.id;
            this.load();
        }
        const ipFilter = $("#ipFilter").data("kendoDropDownList");
        const dataSource = new self.kendo.data.DataSource({
            data: resp.ips
        });
        ipFilter.value(this.minerId);
        ipFilter.setDataSource(dataSource);
    }
    init() {
        this.buildIntervals();
        this.statPanel = new MinerStatPanel();
        this.statPanel.onStatsLoaded = this.onStatsLoaded.bind(this);
        this.statPanel.onOnlineStatusLoaded = this.onlineStatusLoaded.bind(this);
        this.hashrateGraph = new MinerHashrateGraph();
        this.tempGraph = new MinerTemperatureGraph();
        this.fanSpeedGraph = new MinerFanSpeedGraph();
        this.onlineGraph = new MinerOnlineGraph();
        this.minerEditor = new OpMinerEditorModal(this, "MinerEditorModal", this.load.bind(this));
        this.load();
    }
    onStatsLoaded(stats) {
        this.hashrateGraph.setHashingType(stats.hashingTypeId);
        this.getUnsupportedModels()
            .then((models) => {
            if (models.length === 0) {
                $(".warning-banner").addClass("hide");
                return;
            }
            this.checkForUnsupportedModel(models);
        });
    }
    checkForUnsupportedModel(unsupportedModels) {
        const model = $("#model").text();
        const foundModel = unsupportedModels.filter((unsupportedModel) => {
            return model === unsupportedModel;
        })[0];
        if (!foundModel) {
            $(".warning-banner").addClass("hide");
            return;
        }
        $(".warning-banner").removeClass("hide");
    }
    buildIntervals() {
        let interval = parseInt(localStorage.getItem("graphInterval"));
        if (!interval) {
            interval = (this.minute * 5);
        }
        this.selectedInterval = interval;
        $("#intervalList").kendoDropDownList({
            dataTextField: "text",
            dataValueField: "value",
            dataSource: GraphIntervals.getIntervals(),
            height: 200,
            autoWidth: true,
            change: this.onchange.bind(this),
            value: interval.toString()
        });
    }
    onchange() {
        const interval = $("#intervalList").data("kendoDropDownList");
        this.selectedInterval = parseInt(interval.value());
        localStorage.setItem("graphInterval", this.selectedInterval.toString());
        this.loadQueries();
    }
    load() {
        if (!this.minerId) {
            return;
        }
        this.minerLinkModal = new MinerLinkModal(this.minerId);
        this.minerLinkModal.onMinerLink = this.onMinerLink.bind(this);
        this.statPanel.minerId = this.minerId;
        this.statPanel.load();
        this.loadQueries();
    }
    // load newly linked miner
    onMinerLink(newMiner) {
        let ddList = $("#ipFilter").data('kendoDropDownList');
        ddList.value(newMiner.id);
        // do not trigger change since the new miner id is not realized in this trigger
        this.minerId = newMiner.id;
        this.load();
    }
    loadQueries() {
        if (!this.minerId) {
            return;
        }
        this.hashrateGraph.chart.selectedInterval = this.selectedInterval;
        this.tempGraph.chart.selectedInterval = this.selectedInterval;
        this.fanSpeedGraph.chart.selectedInterval = this.selectedInterval;
        this.onlineGraph.chart.selectedInterval = this.selectedInterval;
        this.hashrateGraph.chart.load([["id", this.minerId]]);
        this.tempGraph.chart.load([["id", this.minerId]]);
        this.fanSpeedGraph.chart.load([["minerIds", [this.minerId]]]);
        this.onlineGraph.chart.load([["id", this.minerId]]);
        this.minerEditor.preloadMiner(this.minerId);
    }
    createSupportTicket() {
        window.sessionStorage.setItem("ticket_cache", JSON.stringify([this.minerId]));
        OptiFleetMaster.openTab(`Administration/Tickets?ticket_cache=true`);
    }
    onSupportTicketClosed(ticketCreated) {
        $(".graph-placeholder").removeClass("hide");
        if (ticketCreated) {
            this.showSuccessMessage("Support ticket was created!");
        }
    }
    handleMinerEditorClick() {
        this.minerEditor.open();
    }
    rebootMiner() {
        this.rebootModal.open([this.minerId]);
    }
    handleRebootResponse(resp) {
        this.rebootModal.close();
        this.toggleBusy(false);
        if (!resp.success) {
            this.showErrorMessage("Reboot attempt failed. Custom firmware is not supported by this reboot feature. Please create a support ticket if this problem persists.");
            return;
        }
        this.showSuccessMessage("Miner reboot command has been sent.");
    }
}

class AssetDefinitions extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.currentTab = "Models";
        this.tabs = {
            "Models": $(`#tab-models`),
            "Manufacturers": $(`#tab-manufacturers`),
            "Asset Types": $(`#tab-asset-types`),
        };
        this.tabContent = {
            "Models": $(`#tab-models-content`),
            "Manufacturers": $(`#tab-manufacturers-content`),
            "Asset Types": $(`#tab-asset-types-content`),
        };
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.changeTab(this.getCachedTab());
        this.assetTypes = new AssetTypes();
        this.assetManufacturers = new AssetManufacturers();
        this.assetModels = new AssetModels(this.assetTypes, this.assetManufacturers);
    }
    handleCompanyFilterChanged(_) {
    }
    getCachedTab() {
        switch (localStorage.getItem("AssetDefinitionsTab")) {
            case "Models":
                return "Models";
            case "Manufacturers":
                return "Manufacturers";
            case "Asset Types":
                return "Asset Types";
            default:
                return "Manufacturers";
        }
    }
    changeTab(newTab) {
        this.tabs[this.currentTab]
            .removeClass(`active`)
            .find(`.m-text`)
            .removeClass(`is-accent`);
        this.tabs[newTab]
            .addClass(`active`)
            .find(`.m-text`)
            .addClass(`is-accent`);
        this.tabContent[this.currentTab].hide();
        this.tabContent[newTab].show();
        try {
            this.tabContent[newTab].find(".grid").first().data("kendoGrid").refresh();
        }
        catch (_a) {
            console.log("Must add 'grid' class to kendo grid element");
        }
        this.currentTab = newTab;
        localStorage.setItem("AssetDefinitionsTab", newTab);
    }
}

class AssetManagement extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: true, elemId: "ddlSites" });
        this.currentTab = "Assets";
        this.tabs = {
            "Assets": $(`#tab-assets`),
            "Inventory": $(`#tab-inventory`),
        };
        this.tabContent = {
            "Assets": $(`#tab-assets-content`),
            "Inventory": $(`#tab-inventory-content`),
        };
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        this.changeTab(this.getCachedTab());
        const siteIdGetter = () => __awaiter(this, void 0, void 0, function* () { return yield this.siteCache.getSiteId(); });
        this.assets = new Assets(siteIdGetter);
        this.inventoryItems = new InventoryItems();
    }
    handleCompanyFilterChanged(_) {
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(siteId) {
        if (!this.assets.isLoading) {
            this.assets.loadAssets();
        }
    }
    getCachedTab() {
        switch (localStorage.getItem("AssetManagementTab")) {
            case "Assets":
                return "Assets";
            case "Inventory":
                return "Inventory";
            default:
                return "Assets";
        }
    }
    changeTab(newTab) {
        this.tabs[this.currentTab]
            .removeClass(`active`)
            .find(`.m-text`)
            .removeClass(`is-accent`);
        this.tabs[newTab]
            .addClass(`active`)
            .find(`.m-text`)
            .addClass(`is-accent`);
        this.tabContent[this.currentTab].hide();
        this.tabContent[newTab].show();
        try {
            this.tabContent[newTab].find(".grid").first().data("kendoGrid").refresh();
        }
        catch (_a) {
            console.log("Must add 'grid' class to kendo grid element");
        }
        this.currentTab = newTab;
        localStorage.setItem("AssetManagementTab", newTab);
    }
}

class ModelsAdmin extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.modelsUrl = "/MinerModels";
        this.hashingTypesUrl = "/hashingTypes";
        this.init();
    }
    init() {
        this.toggleBusy(true);
        this.get(this.hashingTypesUrl).then((hashingTypesResp) => {
            this.hashingTypes = hashingTypesResp.hashingTypes.map((hashingType) => {
                return {
                    text: hashingType.hashingTypeName,
                    value: hashingType.hashingTypeId,
                };
            });
            $("#modelsGrid").kendoGrid({
                dataSource: [],
                pageable: false,
                sortable: true,
                toolbar: ["create", "search"],
                search: {
                    fields: [
                        { name: "name", operator: "contains" }
                    ]
                },
                columns: [
                    { command: ["edit"], title: "&nbsp;", width: "125px" },
                    { field: "name", title: "Model", width: "200px" },
                    { field: "powerConsumption", title: "Power Consumption", format: "{0:#}", width: "180px" },
                    { field: "hashRate", title: "Hash Rate", width: "240px", editor: this.hashrateEditor.bind(this), template: "#= formattedHashrate #" },
                    { field: "hashingTypeId", title: "Hashing Type", width: "150px", editor: this.hashingTypeEditor.bind(this), template: this.hashingTypeDisplay.bind(this) },
                    { field: "efficiency", title: "Efficiency (w/TH)", format: "{0:n1}", width: "150px" },
                    { field: "footprint", title: "Model Footprint", format: "{0:#}", width: "160px" },
                    { field: "minerCount", title: "Miner Qty", width: "150px" },
                    { field: "isSupportedByOptiFleet", title: "Supported By OptiFleet", width: "250px" }
                ],
                editable: "inline",
                save: this.onSave.bind(this)
            });
            this.getModels();
        });
    }
    hashrateEditor(container, options) {
        const hashrate = $(`<input name="convertedHashrate" required="required" style="width: 100px" />`);
        hashrate.appendTo(container);
        hashrate.kendoNumericTextBox();
        const hashingTypeId = options.model.hashingTypeId;
        const scale = $(`<input name="hashrateScale" required="required" style="width: 80px; margin-left: 10px" />`);
        scale.appendTo(container);
        scale.kendoDropDownList({
            dataSource: HashingTypes.getUnits(hashingTypeId)
        });
    }
    hashingTypeEditor(container, options) {
        const hashingType = $(`<input name="hashingTypeId" required="required" style="width: 100px" />`);
        hashingType.appendTo(container);
        hashingType.kendoDropDownList({
            dataSource: this.hashingTypes,
            dataValueField: "value",
            dataTextField: "text",
            change: (event) => {
                const hashingTypeId = this.getCurrentlySelectedHashingTypeId();
                const datasource = new kendo.data.DataSource({
                    data: HashingTypes.getUnits(hashingTypeId)
                });
                const ddl = $("input[name=hashrateScale]").data("kendoDropDownList");
                const selected = ddl.select();
                ddl.setDataSource(datasource);
                ddl.select(selected);
            }
        });
    }
    getCurrentlySelectedHashingTypeId() {
        const input = parseInt($("input[name=hashingTypeId]").val());
        return isNaN(input) ? 1 : input;
    }
    hashingTypeDisplay(model) {
        var _a;
        const hashingType = this.hashingTypes.filter(x => x.value === model.hashingTypeId)[0];
        return (_a = hashingType === null || hashingType === void 0 ? void 0 : hashingType.text) !== null && _a !== void 0 ? _a : "Hashes";
    }
    onSave(e) {
        const saveData = {
            id: e.model.id,
            name: e.model.name,
            scale: e.model.hashrateScale,
            hashrate: e.model.convertedHashrate,
            powerConsumption: e.model.powerConsumption,
            footprint: e.model.footprint,
            hashingTypeId: e.model.hashingTypeId,
        };
        this.toggleBusy(true);
        this.post(this.modelsUrl, saveData)
            .then((resp) => {
            if (!resp.successful) {
                this.showErrorMessage(resp.errorMessage);
                this.populateGrid(resp.models);
                return;
            }
            this.populateGrid(resp.models);
            this.showSuccessMessage("Model saved.");
        });
    }
    onDelete(e) {
        const deleteData = {
            id: e.model.id
        };
        this.toggleBusy(true);
        this.delete(this.modelsUrl, deleteData)
            .then((resp) => {
            if (!resp.successful) {
                this.showErrorMessage(resp.errorMessage);
                this.populateGrid(resp.models);
                return;
            }
            this.showSuccessMessage("Model deleted.");
            this.toggleBusy(false);
        });
    }
    getModels() {
        this.get(this.modelsUrl)
            .then((resp) => {
            this.populateGrid(resp.models);
        });
    }
    populateGrid(models) {
        const grid = $("#modelsGrid").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: models,
            schema: {
                model: {
                    id: "id",
                    fields: {
                        id: { editable: false, nullable: true },
                        name: { validation: { required: true } },
                        powerConsumption: { type: "number", validation: { required: true, min: 1 } },
                        hashRate: { type: "number", validation: { required: true, min: 1 } },
                        footprint: { type: "number", validation: { required: true, min: 1 } },
                        efficiency: { type: "number", editable: false },
                        hashrateScale: { type: "string" },
                        formattedHashrate: { type: "string" },
                        convertedHashrate: { type: "number" },
                        minerCount: { type: "number", editable: false },
                        isSupportedByOptiFleet: { type: "boolean", editable: false },
                        hashingTypeId: { type: "number" }
                    }
                }
            }
        });
        grid.setDataSource(dataSource);
        this.toggleBusy(false);
    }
}

class SiteDetails extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.tabs = {
            "Site": $(`#tab-site`),
            "Agents": $(`#tab-agents`),
            "Zones": $(`#tab-zones`),
            "Active Models": $(`#tab-active-models`),
            "Pool Config": $(`#tab-pool-config`),
            "Settings": $(`#tab-settings`),
            "Tags": $(`#tab-miner-tags`),
        };
        this.tabContent = {
            "Site": $(`#tab-site-content`),
            "Agents": $(`#tab-agents-content`),
            "Zones": $(`#tab-zones-content`),
            "Active Models": $(`#tab-active-models-content`),
            "Pool Config": $(`#tab-pool-config-content`),
            "Settings": $(`#tab-settings-content`),
            "Tags": $(`#tab-miner-tags-content`),
        };
        this.currentTab = `Site`;
        // URLS
        this.siteDetails = "/siteDetails";
        this.agentZonesUrl = "/AgentZones";
        this.scanConfigUrl = "/AgentScanConfig";
        this.agentUrl = "/Agents";
        this.siteModelsUrl = "/sitesModels";
        this.rebootRestrictionsUrl = "/RebootRestrictions";
        this.siteUrl = "/Site";
        this.sitesUrl = "/Sites";
        this.initialized = false;
        this.saveBtn = $("#saveSiteButton");
        this.canEdit = $(`#${window.hfId}`).val() === "true";
        const siteId = derive(() => {
            const u = new URL(window.location.href);
            const params = u.searchParams;
            return params.has("siteId")
                ? params.get("siteId")
                : this.getSelectedSiteId().toString();
        });
        this.changeTab(this.deriveTab());
        this.siteId = parseInt(siteId);
        this.checkSiteAgainstCompanyFilter(this.siteId);
        this.agentDetails = new AgentDetailsFormView("AgentDetails", $("#agentsViewList"), { initNullFields: false, addAgentHidden: true, allowDelete: false, editHandler: this.openAgentEditModal.bind(this) });
        // edit agent modal
        this.editAgentModalView = new AgentDetailsFormView("EditAgentModalView", $("#EditAgentModalViewWrapper"), { initNullFields: false, addAgentHidden: true, allowDelete: false });
        this.editAgentModal = new OpProgressionModalBase("EditAgentModal", [this.editAgentModalView], { submitUrl: "/Agents", submitType: ProgressionModalSubmitType.PATCH });
        this.editAgentModal.onClose = this.loadPageData.bind(this, siteId);
        // add agent modal
        this.addAgentModalView = new AgentDetailsFormView("AddAgentModalView", $("#AddAgentModalViewWrapper"), { initNullFields: true, addAgentHidden: false, allowDelete: true });
        this.addAgentModal = new OpProgressionModalBase("AddAgentModal", [this.addAgentModalView], { submitUrl: "/Agents", submitType: ProgressionModalSubmitType.POST });
        this.addAgentModal.onClose = this.loadPageData.bind(this, siteId);
        this.agentDetails.show();
        // Zones Panel
        this.zonePanel = new ZonePanel(this.siteId);
        // Active Model Panel
        this.activeModelsPanel = new ActiveModelsPanel(this);
        // Site Settings Panel
        this.settingsPanel = new SiteSettingsPanel(this);
        // Tags Panel
        this.tagsPanel = new TagsPanel(this.siteId);
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.loadPageData(siteId);
    }
    handleCompanyFilterChanged() {
        if (!this.initialized) {
            this.initialized = true;
            return;
        }
        this.redirectToSitesPage();
    }
    redirectToSitesPage() {
        OptiFleetMaster.goTo(`Administration/Sites`);
    }
    // use to ensure the siteId in the url query string is related to the current selected company
    // if not redirect back to sites;
    checkSiteAgainstCompanyFilter(siteId) {
        this.siteCache.setSiteId(siteId.toString());
        this.siteCache.loadSites().then(() => __awaiter(this, void 0, void 0, function* () {
            const urlParams = new URLParams();
            const siteIdQS = urlParams.get("siteId");
            if (!siteIdQS)
                return;
            // get site list for current company and ensure site id is included
            const selectedCompanyId = JSON.parse(localStorage.getItem("selectedCompany"));
            if (!selectedCompanyId || selectedCompanyId == "-1")
                this.redirectToSitesPage();
            const sites = yield this.siteCache.getSites();
            const targetSite = sites.find(site => Number(site.siteId) === siteId);
            if (!targetSite)
                this.redirectToSitesPage();
        }));
    }
    loadPageData(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.toggleBusy(true);
            const siteDetailsReq = this.get(`${this.siteDetails}?siteId=${siteId}`);
            const siteReq = this.get(`${this.siteUrl}?siteId=${siteId}`);
            const [siteDetailsResp, siteResp] = yield Promise.all([
                siteDetailsReq,
                siteReq,
            ]);
            $("#label-site-name").text(siteDetailsResp.siteName);
            this.settingsPanel.setZones(siteDetailsResp.zones);
            this.loadTabSites(siteResp),
                this.loadTabAgents(siteDetailsResp),
                yield Promise.all([
                    this.loadTabActiveModels(),
                    this.loadTabSettings(),
                ]);
            this.toggleBusy(false);
        });
    }
    loadTabSites(siteResp) {
        const site = siteResp.site;
        let originalSaveData = {
            siteName: site.siteName,
            powerCapacity: site.powerCapacity,
            potentialPowerCapacity: site.potentialPowerCapacity,
        };
        const saveData = Object.assign({}, originalSaveData);
        $("#label-miner-capacity-count").text(site.capacity);
        $("#label-miners-monitored-count").text(site.onlineCount);
        $("#label-agents-configured-count").text(site.agentCount);
        $("#label-zones-count").text(site.zoneCount);
        $("#label-unreachable-miners-count").text(site.unreachableCount);
        $("#label-unassigned-miners-count").text(site.unassignedLocations);
        const inputSiteName = $("#input-site-name");
        const inputCurrentCapacity = $("#input-current-capacity");
        const inputPotentialCapacity = $("#input-potential-capacity");
        inputSiteName.val(site.siteName);
        inputCurrentCapacity.val(site.powerCapacity);
        inputPotentialCapacity.val(site.potentialPowerCapacity);
        function hasSaveDataChanged() {
            if (originalSaveData.potentialPowerCapacity !== saveData.potentialPowerCapacity) {
                return true;
            }
            if (originalSaveData.siteName !== saveData.siteName) {
                return true;
            }
            if (originalSaveData.powerCapacity !== saveData.powerCapacity) {
                return true;
            }
            return false;
        }
        if (this.canEdit) {
            inputSiteName.on("change", (e) => {
                const newVal = $(e.target).val().trim();
                saveData.siteName = newVal;
                const hasChanged = hasSaveDataChanged();
                hasChanged && this.saveBtn
                    ? this.saveBtn.removeAttr("disabled")
                    : this.saveBtn.attr("disabled", "true");
            });
            inputCurrentCapacity.on("change", (e) => {
                const newVal = $(e.target).val().trim();
                saveData.powerCapacity = parseInt(newVal);
                const hasChanged = hasSaveDataChanged();
                hasChanged
                    ? this.saveBtn.removeAttr("disabled")
                    : this.saveBtn.attr("disabled", "true");
            });
            inputPotentialCapacity.on("change", (e) => {
                const newVal = $(e.target).val().trim();
                saveData.potentialPowerCapacity = parseInt(newVal);
                debugger;
                const hasChanged = hasSaveDataChanged();
                hasChanged
                    ? this.saveBtn.removeAttr("disabled")
                    : this.saveBtn.attr("disabled", "true");
            });
        }
        this.saveBtn.on("click", () => {
            const updateSiteReq = Object.assign(Object.assign({}, saveData), { siteId: this.siteId });
            this.toggleBusy(true);
            this.patch(this.siteUrl, updateSiteReq).then((resp) => {
                this.toggleBusy(false);
                if (!resp.success) {
                    this.showErrorMessage("Unable to save site changes");
                    return;
                }
                originalSaveData.siteName = updateSiteReq.siteName;
                originalSaveData.powerCapacity = updateSiteReq.powerCapacity;
                originalSaveData.potentialPowerCapacity = updateSiteReq.potentialPowerCapacity;
                const hasChanged = hasSaveDataChanged();
                hasChanged
                    ? this.saveBtn.removeAttr("disabled")
                    : this.saveBtn.attr("disabled", "true");
                this.showSuccessMessage("Site saved successfully!");
            });
        });
    }
    loadTabAgents(resp) {
        const agentProps = resp.agents.map((agent) => {
            agent.agentUrl = `agents.aspx?agentId=${agent.agentId}`;
            agent.visibility = this.canEdit ? AgentVisibility.ViewWithAdmin : AgentVisibility.View;
            return agent;
        });
        this.agentDetails.addAgentWithData(agentProps);
    }
    loadTabZones() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    loadTabActiveModels() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.activeModelsPanel.populateActiveModelsGrid(this.siteId);
        });
    }
    loadTabSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.settingsPanel.refresh(this.siteId);
        });
    }
    deriveTab() {
        const tabString = derive(() => {
            const u = new URL(window.location.href);
            const params = u.searchParams;
            return params.has("tab")
                ? params.get("tab")
                : this.currentTab;
        });
        if (tabString in this.tabs) {
            return tabString;
        }
        else {
            return this.currentTab;
        }
    }
    changeTab(newTab) {
        newTab === "Site"
            ? this.saveBtn.show()
            : this.saveBtn.hide();
        this.tabs[this.currentTab]
            .removeClass(`active`)
            .find(`.m-text`)
            .removeClass(`is-accent`);
        this.tabs[newTab]
            .addClass(`active`)
            .find(`.m-text`)
            .addClass(`is-accent`);
        this.tabContent[this.currentTab].hide();
        this.tabContent[newTab].show();
        this.currentTab = newTab;
        let u = new URL(window.location.href);
        u.searchParams.set("tab", newTab);
        window.history.replaceState({}, '', u.toString());
    }
    openAgentEditModal(agentProps) {
        this.editAgentModalView.addAgentWithData([agentProps]);
        this.editAgentModalView.siteId = this.siteId;
        this.editAgentModal.open();
    }
    openAddAgentModal() {
        this.addAgentModalView.siteId = this.siteId;
        this.addAgentModal.open();
    }
}

const accessLevelMap = {
    "Customer": -1,
    "Viewer": 0,
    "Facility Tech": 1,
    "Facility Admin": 2,
    "MMS Admin": 3,
    [-1]: "Customer",
    0: "Viewer",
    1: "Facility Tech",
    2: "Facility Admin",
    3: "MMS Admin",
};
const tableColumns$1 = {
    "Name": "lastName",
    "Role": "role",
    "Team": "teamName",
    "Last Login": "lastLogin"
};
class Users extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true, });
        this.usersUrl = "/Users";
        this.userUpdateUrl = "/UpdateUser";
        this.teamsUrl = "/UsersTeams";
        this.deleteUpdateUrl = "/DeleteUser";
        this.inviteUrl = "/InviteUser";
        this.companies = window.companies;
        this.filterValueCompany = "all";
        this.lastNameSortOrder = "desc"; // username column
        this.teamNameSortOrder = "desc"; // team column
        this.lastLoginSortOrder = "desc"; // date invited column
        this.init();
        this.deleteUserModal = new OpConfirmationModal("DeleteUserConfirmationModal", this.confirmDeleteUser.bind(this));
        this.pendingUsersPanel = new PendingUsersPanel();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.toggleBusy(true);
            const usersReq = this.get(this.usersUrl);
            const teamsReq = this.get(this.teamsUrl);
            const [usersRes, teamsRes] = yield Promise.all([
                usersReq,
                teamsReq,
            ]);
            this.toggleBusy(false);
            $("#searchInput").on("input", this.handleSearchChange.bind(this));
            const elemCompanyFilter = $("#companySelect");
            elemCompanyFilter.append(`<option value="All">All</option>`);
            for (let i = 0; i < this.companies.length; i++) {
                const company = this.companies[i];
                elemCompanyFilter.append(`<option value="${company.Name}">${company.Name}</option>`);
            }
            elemCompanyFilter.on("change", this.handleCompanyFilterChange.bind(this));
            this.myAccessLevel = window.accessLevel;
            this.isAtLeastFacilityAdmin = this.myAccessLevel >= accessLevelMap["Facility Admin"];
            if (this.isAtLeastFacilityAdmin) {
                $("#addUserBtn").show();
            }
            this.users = usersRes.users;
            this.teams = teamsRes.teams;
            this.usersToDisplay = this.users.slice(0);
            this.renderUserList();
            this.pendingUsersPanel.renderUserList;
        });
    }
    handleUserClick(idStr) {
        const id = parseInt(idStr);
        this.selectedUser = this.users.find((u) => u.id === id);
        this.selectUser();
        this.renderUserDetails();
    }
    toggleTab(tab) {
        $(tab).addClass("selected");
        $(tab).siblings(".tab").removeClass("selected");
        $("#userPanel, #pendingPanel").removeClass("active");
        const tabName = tab.children[0].innerHTML;
        if (tabName === "Users") {
            $("#userPanel").addClass("active");
            $("#revokeBtn").hide();
            return;
        }
        $("#pendingPanel").addClass("active");
        $("#revokeBtn").show();
    }
    sortColumn(col) {
        const [el, title, newOrder] = SortUtil.getColumnSortInfo(col, tableColumns$1);
        this.usersToDisplay = this.usersToDisplay.sort(SortUtil.dynamicSort(title, newOrder));
        this.renderUserList();
        $(`#${title}Column`).append(el);
    }
    selectUser() {
        $(".user").removeClass("is-selected");
        $(`[user-id=${this.selectedUser.id}]`).addClass("is-selected");
    }
    renderUserList() {
        const mustache = window.Mustache;
        const templateData = {
            users: this.usersToDisplay.map((u) => {
                const getTextElem = (text) => {
                    if (this.filterValueSearch === "") {
                        return `<span class="m-text">${text}</span>`;
                    }
                    return `<span class="m-text">
                            ${text.replace(new RegExp(this.filterValueSearch, "gi"), (s) => `<span class="m-text is-highlighted">${s}</span>`)}
                        </span>`;
                };
                return Object.assign(Object.assign({}, u), { textElemUsername: getTextElem(u.lastName + ", " + u.firstName), textElemRole: getTextElem(u.role), textElemTeamName: getTextElem(u.teamName), textElemLastLogin: getTextElem(u.lastLogin) });
            }),
        };
        const el = mustache.to_html(UserTemplatesNew.USER_LIST, templateData);
        $("#usersList").empty().append(el);
        if (this.selectedUser) {
            this.selectUser();
            this.renderUserDetails();
        }
    }
    renderUserDetails() {
        const mustache = window.Mustache;
        const u = this.selectedUser;
        const role = accessLevelMap[u.accessLevel];
        const isAllCompanies = u.company === "All Companies";
        const companies = isAllCompanies ? this.companies.map((c) => c.Name) : u.company.split(",");
        const isAtLeastEqualRole = this.myAccessLevel >= u.accessLevel;
        const canEdit = this.isAtLeastFacilityAdmin && isAtLeastEqualRole;
        const roles = Object.keys(accessLevelMap).filter(r => {
            if (typeof (r) == "string") {
                return this.myAccessLevel >= accessLevelMap[r];
            }
        }).map(r => {
            return {
                name: r,
                checked: r == role ? "checked" : "",
                disabled: canEdit ? "" : "disabled",
            };
        });
        const userDetailsData = {
            fullName: u.firstName + " " + u.lastName,
            username: u.username,
            deleteBtnAttrs: canEdit
                ? `class="m-button is-secondary"`
                : `class="m-button" disabled`,
            roles,
            companies: derive(() => {
                const derivedCompanies = u.company === "All Companies"
                    ? this.companies.map((c) => ({
                        name: c.Name,
                        checked: "checked",
                        disabled: canEdit ? "" : "disabled",
                    }))
                    : this.companies.map((c) => ({
                        name: c.Name,
                        checked: companies.find((c2) => c.Name.trim() === c2.trim()) ? "checked" : "",
                        disabled: canEdit ? "" : "disabled",
                    }));
                return derivedCompanies.sort(SortUtil.dynamicSort("name"));
            }),
            teams: this.teams.map((t) => {
                return {
                    name: t.teamName,
                    selected: u.teamId === t.teamId ? "selected" : "",
                    id: t.teamId,
                    disabled: canEdit ? "" : "disabled",
                };
            }),
        };
        const el = mustache.to_html(UserTemplatesNew.USER_DETAILS, userDetailsData);
        $("#userDetails").empty().show().append(el);
        $("#userDetails").addClass("active");
        const saveChangesBtn = $("#saveChangesBtn");
        let originalSaveData = {
            id: u.id,
            role: accessLevelMap[u.role],
            companies: [],
            teamId: u.teamId || null,
        };
        let saveData = Object.assign({}, originalSaveData);
        const companyCheckboxes = $("[name='companies']");
        const teamSelect = $("#teamSelect");
        const roleRadioBtns = $("[name='role']");
        companyCheckboxes.on("change", () => {
            if (this.selectedUser.company === "All Companies") {
                saveData.companies;
            }
            saveData.companies = $("[name='companies']")
                .toArray()
                .map((el) => {
                const inputEl = $(el);
                const companyName = inputEl.attr("company-name");
                const company = this.companies.find((c) => c.Name === companyName);
                return {
                    id: company.Id,
                    hasAccess: el.checked
                };
            });
            const hasDataChanged = this.hasSaveDataChanged(originalSaveData, saveData);
            // update team select to only show teams that are in the selected companies
            const selectedCompanyIds = saveData.companies
                .filter((company) => company.hasAccess)
                .map((company) => company.id);
            const filteredTeams = this.teams.filter((team) => selectedCompanyIds.includes(team.companyId));
            teamSelect.empty();
            teamSelect.append(`<option value="null"></option>`);
            filteredTeams.forEach((team) => {
                teamSelect.append(`<option value="${team.teamId}" ${team.teamId === saveData.teamId ? "selected" : ""}>${team.teamName}</option>`);
            });
            teamSelect.trigger("change");
            if (hasDataChanged) {
                saveChangesBtn.removeAttr("disabled");
            }
            else {
                saveChangesBtn.attr("disabled", "true");
            }
        });
        teamSelect.on("change", () => {
            saveData.teamId = Number(teamSelect.val()) || null;
            const hasDataChanged = this.hasSaveDataChanged(originalSaveData, saveData);
            if (hasDataChanged) {
                saveChangesBtn.removeAttr("disabled");
            }
            else {
                saveChangesBtn.attr("disabled", "");
            }
        });
        roleRadioBtns.on("change", () => {
            saveData.role = accessLevelMap[$(`input[name="role"]:checked`).val()];
            const hasDataChanged = this.hasSaveDataChanged(originalSaveData, saveData);
            if (hasDataChanged) {
                saveChangesBtn.removeAttr("disabled");
            }
            else {
                saveChangesBtn.attr("disabled", "");
            }
        });
        saveChangesBtn.on("click", () => {
            this.toggleBusy(true);
            this.post(this.userUpdateUrl, saveData).then((res) => {
                this.toggleBusy(false);
                if (!res.success) {
                    this.showErrorMessage("Failed to Update User.");
                }
                else {
                    originalSaveData = Object.assign({}, saveData);
                    this.refreshUsers();
                    saveChangesBtn.attr("disabled", "");
                    this.showSuccessMessage("User Updated Successfully");
                }
            });
        });
    }
    renderAddUserPanel() {
        const mustache = window.Mustache;
        const roles = Object.keys(accessLevelMap).filter(role => {
            if (typeof (role) == "string") {
                return this.myAccessLevel >= accessLevelMap[role];
            }
        }).map(role => { return { name: role }; });
        const tempData = {
            roles,
            companies: this.companies.map((c) => ({
                name: c.Name,
            })).sort(SortUtil.dynamicSort("name")),
            teams: this.teams.map((t) => ({
                name: t.teamName,
            })),
        };
        const el = mustache.to_html(UserTemplatesNew.ADD_USER, tempData);
        $("#userDetails").empty().show().append(el);
        let formData = {
            email: "",
            companyIds: [],
            accessLevel: -1,
        };
        let validEmail = false;
        let validCompanyIds = false;
        let validAccessLevel = false;
        const companyCheckboxes = $("[name='companies']");
        const roleRadioBtns = $("[name='role']");
        const emailInput = $("#emailInput");
        const inviteUserBtn = $("#inviteUserBtn");
        const emailErrorMessage = $("#invalidEmailAddress");
        const companyErrorMessage = $("#invalidCompany");
        inviteUserBtn.on("click", () => {
            this.toggleBusy(true);
            this.post(this.inviteUrl, formData)
                .then((res) => {
                this.toggleBusy(false);
                if (!res.success) {
                    this.showErrorMessage("Failed to invite new user. Please try again later.");
                    return;
                }
                this.pendingUsersPanel.getInvitations();
                this.renderAddUserPanel();
                this.showSuccessMessage("Successfully Invited User");
            });
        });
        companyCheckboxes.on("change", () => {
            formData.companyIds = $("[name='companies']")
                .toArray()
                .filter((el) => el.checked)
                .map((el) => {
                const inputEl = $(el);
                const companyName = inputEl.attr("company-name");
                const company = this.companies.find((c) => c.Name === companyName);
                return company.Id;
            });
            validCompanyIds = formData.companyIds.length > 0;
            if (validCompanyIds) {
                companyErrorMessage.hide();
            }
            else {
                companyErrorMessage.show();
            }
            if (validEmail && validAccessLevel && validCompanyIds) {
                inviteUserBtn.removeAttr("disabled");
            }
            else {
                inviteUserBtn.attr("disabled", "");
            }
        });
        roleRadioBtns.on("change", () => {
            validAccessLevel = true;
            formData.accessLevel = accessLevelMap[$(`input[name="role"]:checked`).val()];
            if (validEmail && validAccessLevel && validCompanyIds) {
                inviteUserBtn.removeAttr("disabled");
            }
            else {
                inviteUserBtn.attr("disabled", "true");
            }
        });
        emailInput.on("change", (e) => {
            const val = $(e.target).val();
            formData.email = val;
            const emailRegex = /^[^@]+@[^@]+\.[^@]+$/;
            if (!emailRegex.test(val)) {
                validEmail = false;
                emailInput.addClass("is-error");
                emailErrorMessage.show();
                inviteUserBtn.attr("disabled", "true");
                return;
            }
            validEmail = true;
            emailErrorMessage.hide();
            emailInput.removeClass("is-error");
            if (validEmail && validAccessLevel && validCompanyIds) {
                inviteUserBtn.removeAttr("disabled");
            }
            else {
                inviteUserBtn.attr("disabled", "true");
            }
        });
        $("#userDetails").show();
    }
    hasSaveDataChanged(oldSaveData, newSaveData) {
        if (oldSaveData.role !== newSaveData.role) {
            return true;
        }
        if (oldSaveData.companies.length !== newSaveData.companies.length) {
            return true;
        }
        if (oldSaveData.teamId !== newSaveData.teamId) {
            return true;
        }
        for (const c of oldSaveData.companies) {
            if (!newSaveData.companies.includes(c)) {
                return true;
            }
        }
        return false;
    }
    handleSearchChange(e) {
        const newValue = $(e.target).val();
        this.filterValueSearch = newValue.toLowerCase().trim();
        this.filterList();
    }
    handleCompanyFilterChange(e) {
        const newValue = $(e.target).val();
        this.filterValueCompany = newValue.toLowerCase().trim();
        this.filterList();
    }
    ;
    filterList() {
        var _a;
        const isAllCompanies = this.filterValueCompany === "all";
        const isSearch = ((_a = this.filterValueSearch) === null || _a === void 0 ? void 0 : _a.length) > 0;
        if (!isSearch && isAllCompanies) {
            this.usersToDisplay = this.users;
            this.renderUserList();
            return;
        }
        this.usersToDisplay = this.users.filter((u) => {
            var _a, _b, _c, _d;
            const f = (s) => s || "";
            const fullName = f(((_a = u.firstName) === null || _a === void 0 ? void 0 : _a.toLowerCase().trim()) + ((_b = u.lastName) === null || _b === void 0 ? void 0 : _b.toLowerCase().trim()));
            const role = f((_c = u.role) === null || _c === void 0 ? void 0 : _c.toLowerCase().trim());
            const teamName = f((_d = u.teamName) === null || _d === void 0 ? void 0 : _d.toLowerCase().trim());
            const includesCompany = u.company.toLowerCase().includes(this.filterValueCompany) || isAllCompanies;
            const searchMatchesName = fullName.includes(this.filterValueSearch) || !isSearch;
            const searchMatchesRole = role.includes(this.filterValueSearch) || !isSearch;
            const searchMatchesTeam = teamName.includes(this.filterValueSearch) || !isSearch;
            const searchMatches = searchMatchesName || searchMatchesRole || searchMatchesTeam;
            return searchMatches && includesCompany;
        });
        this.renderUserList();
    }
    refreshUsers() {
        return this.get(this.usersUrl)
            .then((res) => {
            this.users = res.users;
            if (this.selectedUser) {
                const selected = this.users.find(u => u.id === this.selectedUser.id);
                this.selectedUser = selected;
            }
            this.filterList();
            this.selectUser();
        });
    }
    promptDeleteUserConfirmation() {
        this.deleteUserModal.open({ primaryText: `Are you sure you wish to delete ${this.selectedUser.firstName} ${this.selectedUser.lastName}?` });
    }
    confirmDeleteUser() {
        this.post(this.deleteUpdateUrl, { id: this.selectedUser.id })
            .then(res => {
            if (!res.success) {
                this.showErrorMessage("Failed to delete user, please try again later");
                return;
            }
            this.selectedUser = null;
            $(".user-details").html("");
            $(".user").removeClass("is-selected");
            this.showSuccessMessage("User successfully deleted");
            this.refreshUsers();
        });
    }
    openAddUserPanel() {
        this.renderAddUserPanel();
    }
    closeAddUserPanel() {
        if (this.selectedUser) {
            this.renderUserDetails();
            $("#userDetails").show();
            return;
        }
        $("#userDetails").hide();
    }
}

class Alerts extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.notificationUsersURL = "/NotificationUsers";
        this.alertManager = new AlertManager(this);
        [this.grdAlert, this.ddlViewUser, this.dlgDelete] = this.init();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
    }
    init() {
        $("#enabled").change((event) => {
            const newText = $(event.currentTarget).is(":checked") === true ? "Enabled" : "Disabled";
            $(event.currentTarget).parent(".material-switch").siblings(".switch-text").text(newText);
        });
        return [this.initAlertGrid(), this.initViewUserDropDownList(), this.initDeleteDialog()];
    }
    handleCompanyFilterChanged() {
        if (this.getSelectedCompanyId() <= 0) {
            return;
        }
        this.closeNewAlertWindow();
        this.refreshNotificationUsers();
        this.refreshConfiguredAlerts();
    }
    initAlertGrid() {
        return $("#alertList").kendoGrid({
            dataSource: {
                type: "odata",
                data: [],
                pageSize: 20
            },
            height: 550,
            sortable: true,
            pageable: false,
            noRecords: {
                template: "<div class=\"no-records\">You haven't created any Alerts yet.</div>"
            },
            columns: [
                { field: "id", title: "Id", hidden: true, attributes: { "class": "idColumn" }, },
                {
                    width: "140px",
                    command: [
                        { text: "Edit", click: this.openEditAlertForm.bind(this) },
                        { text: "Delete", click: this.promptDeletion.bind(this) }
                    ],
                },
                {
                    field: "enabled", title: "Enabled", width: 90, filterable: { extra: false, search: true },
                    template: this.getEnabledColumnTemplate(),
                },
                { field: "alert", title: "Alert Type", width: 150, filterable: { extra: false, search: true } },
                {
                    title: "Alert Trigger", width: 90, filterable: { extra: false, search: true },
                    template: this.getAlertTriggerColumnTemplate(),
                },
                { field: "site", title: "Site", width: 90, filterable: { extra: false, search: true } },
                {
                    title: "Threshold", width: 100, filterable: { extra: false, search: true },
                    template: this.getAlertThresholdColumnTemplate(),
                },
                {
                    title: "Sent To", width: 150, filterable: { extra: false, multi: true },
                    template: this.getSentToColumnTemplate(),
                },
                {
                    title: "Channel", width: 140, filterable: { extra: false, search: true },
                    template: this.getChannelColumnTemplate(),
                },
            ],
        }).data("kendoGrid");
    }
    initViewUserDropDownList() {
        return $('#ddlViewUserId').kendoDropDownList({
            dataTextField: "username",
            dataValueField: "id",
            filter: "contains",
            dataSource: [],
            height: 200,
            change: this.updateTargetUserId.bind(this)
        }).data("kendoDropDownList");
    }
    initDeleteDialog() {
        return $("#dialog").kendoDialog({
            width: "400px",
            title: "Delete Alert",
            closable: false,
            modal: false,
            visible: false,
            content: "<p>Are you sure you want to <strong>DELETE</strong> this alert? <br/>Press OK to continue...</p>",
            actions: [
                { text: 'Cancel' },
                {
                    text: 'OK', primary: true, action: this.deleteAlert.bind(this),
                }
            ]
        }).data("kendoDialog");
    }
    refreshNotificationUsers() {
        this.get(this.notificationUsersURL)
            .then((resp) => {
            this.alertManager.notificationUserData = resp.users;
            const userDataSource = new kendo.data.DataSource({
                data: resp.users
            });
            const ddlTargetUserId = this.alertManager.ddlTargetUserId;
            ddlTargetUserId.enable(true);
            ddlTargetUserId.setDataSource(userDataSource);
            ddlTargetUserId.select(0);
            if (resp.users.length <= 1) {
                this.alertUserId = 0;
                $(".alert-who").addClass("hide");
                this.ddlViewUser.wrapper.addClass("hide");
                this.ddlViewUser.enable(false);
                return;
            }
            this.alertUserId = resp.users[0].id;
            // Update the user selector for the grid
            this.ddlViewUser.enable(true);
            this.ddlViewUser.setDataSource(userDataSource);
            this.ddlViewUser.select(0);
            this.ddlViewUser.wrapper.removeClass("hide");
            // Update the user selector for the editor
            //ddlTargetUserId.wrapper.removeClass("hide");
            $(".alert-who").removeClass("hide");
        });
    }
    updateTargetUserId() {
        this.alertUserId = parseInt(this.ddlViewUser.value());
        this.refreshConfiguredAlerts();
    }
    getEnabledColumnTemplate() {
        return `<span class="remember-me">#if(enabled == 1) { # ON # } else { # OFF # } # </span> `;
    }
    getAlertTriggerColumnTemplate() {
        return "#if(alertId == 1) { # Less than # } else { # Greater than # } #";
    }
    getAlertThresholdColumnTemplate() {
        return "<strong>#if(percentageThreshold != null) { # #= percentageThreshold #% # } else { # #= countThreshold # units # } # </strong>";
    }
    getChannelColumnTemplate() {
        return "<strong>#if(destinationId == 1) {# Email # } else if(destinationId == 2) { # SMS # } else { # Telegram # } #  </strong>";
    }
    getSentToColumnTemplate() {
        return "<strong>#if(destinationId == 1) {# #= email # # } else if(destinationId == 2) { # #= sms # # } else { # #= telegram # # } #  </strong>";
    }
    promptDeletion(event) {
        const row = $(event.currentTarget).closest("tr");
        const dataItem = this.grdAlert.dataItem(row);
        this.alertIdToDelete = dataItem.id;
        this.dlgDelete.open();
    }
    deleteAlert() {
        if (this.alertIdToDelete === 0) {
            return false;
        }
        this.alertManager.deleteAlert(this.alertIdToDelete).then(() => {
            this.alertIdToDelete = 0;
            this.refreshConfiguredAlerts();
        });
        return true;
    }
    openEditAlertForm(event) {
        event.preventDefault();
        const row = $(event.currentTarget).closest("tr");
        const dataItem = this.grdAlert.dataItem(row);
        const editAlertURL = this.alertManager.alertsURL + "?alertId=" + dataItem.get("id") + "&AlertUserId=" + dataItem.get("userId");
        this.get(editAlertURL).then((resp) => {
            this.alertManager.openEditAlertForm(resp.alerts[0]);
        });
    }
    refreshConfiguredAlerts() {
        this.toggleBusy(true);
        let url = this.alertManager.alertsURL;
        if (this.alertUserId > 0) {
            url += "?alertUserId=" + this.alertUserId;
        }
        this.get(url).then((resp) => {
            const alertMap = AlertCategories.AlertList.reduce((a, x) => (Object.assign(Object.assign({}, a), { [x.id]: x.name })), {});
            const destinationMap = AlertCategories.DestinationList.reduce((a, x) => (Object.assign(Object.assign({}, a), { [x.id]: x.name })), {});
            resp.alerts.forEach(x => {
                x.destination = destinationMap[x.destinationId];
                x.alert = alertMap[x.alertId];
            });
            this.populateGrid(resp.alerts);
        });
    }
    populateGrid(alerts) {
        const dataSource = new kendo.data.DataSource({
            data: alerts,
            pageSize: 20
        });
        this.grdAlert.setDataSource(dataSource);
        this.toggleBusy(false);
    }
    showNewAlertForm() {
        this.alertManager.showNewAlertForm();
        return false;
    }
    closeNewAlertWindow() {
        this.alertManager.closeNewAlertWindow();
    }
    setAlert() {
        const createAlertData = this.alertManager.getCreateAlertData();
        if (!this.alertManager.isValid(createAlertData)) {
            return;
        }
        const alertId = parseInt($("#userAlertId").val());
        $(".loading-spinner").addClass("active");
        const saveURL = alertId ? this.alertManager.updateAlertURL : this.alertManager.createAlertURL;
        this.post(saveURL, createAlertData).then((resp) => {
            $(".loading-spinner").removeClass("active");
            if (resp.success) {
                this.closeNewAlertWindow();
                this.refreshConfiguredAlerts();
            }
            else {
                $("#alert-save-error").text(resp.message);
                $("#alert-save-errors").removeClass("hide");
            }
        });
    }
}

class CurrentPerformance extends OptiFleetPage {
    constructor() {
        super();
        this.sitesUrl = "/sites";
        this.installedMinersUrl = "../../Content/Miners/MinerView.aspx?siteId=";
        this.nonHashingUrl = "../../Content/Dashboard/Drilldown.aspx?view=nonhashing&siteId=";
        this.pendingRmaUrl = "../../Content/Dashboard/Drilldown.aspx?view=pendingrma&siteId=";
        this.lowHashingUrl = "../../Content/Dashboard/Drilldown.aspx?view=lowhashing&siteId=";
        this.rmaUrl = "../../Content/Dashboard/Drilldown.aspx?view=rma&siteId=";
        this.init();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
    }
    handleCompanyFilterChanged(companyId) {
        if (!this.hasMiners(companyId)) {
            this.showNullState("There aren't any miners setup yet.");
            return;
        }
        this.hideNullState();
        this.hashrateChart.chart.companyFilter = this.getSelectedCompanyId();
        this.poolHashrateChart.chart.companyFilter = this.getSelectedCompanyId();
        this.getUnsupportedModels()
            .then((models) => {
            this.handleUnsupportedModelsWarning(models);
        });
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(companyId) {
        this.reload(true);
        this.wireAudio();
    }
    init() {
        this.hashrateStat = new HashrateStat();
        this.repairStat = new RepairStat();
        this.installedStat = new InstalledStat();
        this.nonHashingStat = new NonHashingStat();
        this.lowHashingStat = new LowHashingStat();
        this.pendingRepairStat = new PendingRepairStat();
        this.hashrateGauge = new HashrateGauge(true);
        this.hashrateGauge.chart.companyFilter = this.getSelectedCompanyId();
        this.hashrateGauge.chart.selectedInterval = GraphIntervals.LAST_15_MINUTES;
        this.hashrateGauge.chart.extraOptions.height = 400;
        this.hashrateGauge.chart.init();
        this.hashrateChart = new MinersHashrate();
        this.hashrateChart.chart.selectedInterval = GraphIntervals.LAST_24_HOURS;
        this.poolHashrateChart = new PoolHashrate();
        this.poolHashrateChart.chart.selectedInterval = GraphIntervals.LAST_24_HOURS;
    }
    wireAudio() {
        $(".audio-tooltip").parent().hover(event => {
            $(event.currentTarget).children("i").html("volume_up");
            $(event.currentTarget).on("click", e => {
                $(e.target).siblings('audio').get(0).play();
            });
        }, event => {
            $(event.currentTarget).children("i").html("info");
            $(event.currentTarget).off("click");
        });
    }
    reload(companyChanged) {
        const ddl = $("#ddlSites").data("kendoDropDownList");
        const siteId = companyChanged ? -1 : parseInt(ddl.value());
        this.setDrillDownLinks(siteId);
        this.hashrateChart.chart.load([["siteId", siteId]]);
        this.poolHashrateChart.chart.load([["siteId", siteId]]);
        this.hashrateStat.load(siteId);
        this.repairStat.load(siteId);
        this.installedStat.load(siteId);
        this.nonHashingStat.load(siteId);
        this.lowHashingStat.load(siteId);
        this.pendingRepairStat.load(siteId);
        this.hashrateGauge.load(siteId);
    }
    setDrillDownLinks(siteId) {
        $("#installedMinersLink").attr("href", `${this.installedMinersUrl}${siteId}`);
        $("#nonHashingLink").attr("href", `${this.nonHashingUrl}${siteId}`);
        $("#pendingRmaLink").attr("href", `${this.pendingRmaUrl}${siteId}`);
        $("#lowHashingLink").attr("href", `${this.lowHashingUrl}${siteId}`);
        $("#rmaLink").attr("href", `${this.rmaUrl}${siteId}`);
    }
    handleUnsupportedModelsWarning(models) {
        if (models.length === 0) {
            return;
        }
        $(".warning-banner").removeClass("hide");
    }
}

class MiningPool extends OptiFleetPage {
    constructor() {
        super();
        this.minute = 60 * 1000;
        this.init();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
    }
    init() {
        new TotalHashrateStat();
        new PendingBalanceStat();
        new OverallEfficiencyStat();
        new DailyRevenueStat();
        new TotalRevenueStat();
        this.buildIntervals();
        this.currentHashrateChart = new ComputeNorthCurrentHashrate();
        this.currentHashrateChart.chart.selectedInterval = GraphIntervals.LAST_24_HOURS;
        this.hashrateChart = new ComputeNorthHashrate();
        this.hashrateChart.chart.selectedInterval = this.selectedInterval;
        this.hashrateVarianceGrid = new HashrateVarianceGrid();
        this.workerPayoutsGrid = new WorkerPayoutsGrid();
        this.historicalPoolStats = new HistoricalPoolStats();
    }
    handleCompanyFilterChanged(companyId) {
        this.hashrateChart.chart.companyFilter = this.getSelectedCompanyId();
        this.hashrateChart.chart.load();
        this.currentHashrateChart.chart.load();
        this.hashrateVarianceGrid.load();
        this.workerPayoutsGrid.load();
        this.historicalPoolStats.load();
    }
    buildIntervals() {
        let interval = parseInt(localStorage.getItem("graphInterval"));
        if (!interval) {
            interval = (this.minute * 5);
        }
        this.selectedInterval = interval;
        const allIntervals = GraphIntervals.getIntervals();
        const oneDayForward = GraphIntervals.getIntervals().slice(7, allIntervals.length - 1);
        $("#intervalList").kendoDropDownList({
            dataTextField: "text",
            dataValueField: "value",
            dataSource: oneDayForward,
            height: 200,
            autoWidth: true,
            change: this.onIntervalChanged.bind(this),
            value: interval.toString()
        });
        const intervalList = $("#intervalList").data("kendoDropDownList");
        $(".intervalLabel").text(intervalList.text());
    }
    onIntervalChanged() {
        const interval = $("#intervalList").data("kendoDropDownList");
        this.selectedInterval = parseInt(interval.value());
        $(".intervalLabel").text(interval.text());
        this.hashrateChart.chart.selectedInterval = this.selectedInterval;
        this.hashrateChart.chart.load();
        this.hashrateVarianceGrid.load();
        this.historicalPoolStats.load();
    }
    toggleGrid(sender, selector) {
        $(sender).addClass("selected");
        $(sender).siblings(".header-toggle").removeClass("selected");
        $(selector).addClass("active");
        $(selector).siblings(".grid-wrapper").removeClass("active");
    }
    exportToExcel() {
        const gridToExport = $(".worker-panel").hasClass("active") ? "#workerGrid" : "#payoutGrid";
        const exportTitle = $(".worker-panel").hasClass("active") ? "Workers" : "Payouts";
        event.preventDefault();
        const header = $(gridToExport).find(".k-grid-header th").get();
        const rows = $(gridToExport).find(".k-grid-content tr").get();
        ExcelUtility.exportToExcel(header, rows, exportTitle);
    }
    exportToCsv() {
        const gridToExport = $(".worker-panel").hasClass("active") ? "#workerGrid" : "#payoutGrid";
        const exportTitle = $(".worker-panel").hasClass("active") ? "Workers" : "Payouts";
        event.preventDefault();
        const header = $(gridToExport).find(".k-grid-header th").get();
        const rows = $(gridToExport).find(".k-grid-content tr").get();
        ExcelUtility.exportToCSV(header, rows, exportTitle);
    }
}

class CustomerResources extends OptiFleetPage {
    constructor() {
        super();
        this.releaseNotes = new ReleaseNotes();
    }
    selectTab(sender, contentSelector) {
        $(sender).siblings().removeClass("selected");
        $(sender).addClass("selected");
        $(`.${contentSelector}`).siblings().removeClass("active");
        $(`.${contentSelector}`).addClass("active");
    }
}

class Feedback extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true, });
        this.feedbackUrl = "/Feedback";
    }
    toggleSubmitButton() {
        const suggestion = $("#txtFeedback").val();
        const hasSuggestion = suggestion.length > 0;
        if (!hasSuggestion) {
            $("#btnSendFeedback").attr("disabled", "disabled");
            return;
        }
        $("#btnSendFeedback").removeAttr("disabled");
    }
    sendFeedback() {
        const feedback = $("#txtFeedback").val();
        this.toggleBusy(true);
        this.post(this.feedbackUrl, { feedback: feedback })
            .then((resp) => {
            this.toggleBusy(false);
            this.showSuccess();
            $("#txtFeedback").val("");
        });
    }
    showSuccess() {
        $(".save-success").removeClass("hide");
        setTimeout(() => {
            $(".save-success").addClass("hide");
        }, 4000);
    }
}

class CustomerDashboard extends CdMaster {
    constructor() {
        super();
        this.hashingInventoryUrl = "/HashingInventory";
        this.keyMetricsUrl = "/CustomerKeyMetrics";
        this.scheduledShutdownsUrl = "/ScheduledShutdowns";
        this.minute = 60 * 1000;
        this.currentInterval = KEY_METRICS_INTERVAL.HOUR;
        this.hashingType = 1;
        this.onSiteFilterChanged = this.refresh.bind(this);
        this.excusedEventsGrid = new ExcusedEventsGrid();
        this.initCharts();
    }
    initCharts() {
        this.siteUtilizationChart = new LineChart(null);
        this.siteUtilizationChart.overrideOptions = PERCENT_CHART_OPTIONS;
        this.uptimeChart = new LineChart(null);
        this.uptimeChart.overrideOptions = PERCENT_CHART_OPTIONS;
        this.hashrateChart = new MinersHashrate(HASHRATE_CHART_OPTIONS);
        this.siteUtilizationChart.elementSelector = "siteUtilizationChart";
        this.uptimeChart.elementSelector = "uptimeChart";
        this.datePicker = new DatePicker("#datePicker", this.loadCharts.bind(this));
        this.siteUtilizationChart.render();
        this.uptimeChart.render();
    }
    refresh(siteId) {
        this.siteId = parseInt(siteId);
        const params = this.datePicker.getParams();
        this.toggleBusy(true);
        const data = {
            siteId,
            start: params.start,
            end: params.end
        };
        Promise.all([
            this.loadHashingInventory(parseInt(siteId)),
            this.loadCharts(params, this.siteId),
            this.excusedEventsGrid.refresh(data),
        ]).then(() => {
            this.toggleBusy(false);
        });
    }
    loadHashingInventory(siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!siteId) {
                siteId = parseInt(yield this.getSiteId());
            }
            const url = siteId !== -1 ? `${this.hashingInventoryUrl}?siteId=${siteId}` : this.hashingInventoryUrl;
            const resp = yield this.get(url);
            const totalMinerSlots = resp.positionCount;
            resp.totalCount;
            const totalActiveOrUnreachableCount = resp.totalActiveOrUnreachableCount;
            const minersWithLocations = resp.minerCountWithLocations;
            const reservedLocationCount = resp.reservedLocationCount;
            const minersHashing = resp.hashingCount;
            resp.lowHashingCount;
            resp.notHashingCount;
            const emptySlots = totalMinerSlots - minersWithLocations - reservedLocationCount;
            // formats a floating point number to a readable percentage
            // e.g. formatPercentage(0.06) -> 6.1%
            function formatPercentage(num, decimalPlaces = 1) {
                const rounded = MathUtil.round(num * 100, decimalPlaces);
                // fix all nums to one decimal point e.g. 9 -> "9.0"
                const formatted = rounded.toFixed(decimalPlaces);
                return `${formatted}%`;
            }
            // formats a floating point number to a capped percentage
            // e.g. fomatBarWidth(1.2) -> 100.0%
            function formatPercentageCapped(num) {
                // ensure num is not greater than 1
                const capped = Math.min(num, 1);
                return formatPercentage(capped);
            }
            /* SITE UTILIZATION */
            {
                const filledCount = minersWithLocations + reservedLocationCount;
                const filledPercentage = MathUtil.divide(filledCount, totalMinerSlots);
                const barWidth = formatPercentageCapped(filledPercentage);
                const spacesFilledPercentage = formatPercentage(filledPercentage);
                $("#siteUtilizationBar").css("width", barWidth);
                $("#siteUtilizationBarVal").text(filledCount);
                $("#siteUtilizationTotalSpaces").text(totalMinerSlots);
                $("#siteUtilizationPercentValue").text(spacesFilledPercentage);
                $("#numEmptySlots").text(emptySlots < 0 ? 0 : emptySlots);
                $("#numUnassignedMiners").text(Math.abs(totalActiveOrUnreachableCount - minersWithLocations));
            }
            /* SITE UTILIZATION */
            /* UPTIME */
            {
                const filledPercentage = MathUtil.divide(minersHashing, totalActiveOrUnreachableCount);
                const barWidth = formatPercentageCapped(filledPercentage);
                const uptimePercentage = formatPercentage(filledPercentage);
                $("#uptimeBar").css("width", barWidth);
                $("#uptimeBarVal").text(minersHashing);
                $("#uptimeTotalMiners").text(totalActiveOrUnreachableCount);
                $("#uptimePercentValue").text(uptimePercentage);
            }
            /* UPTIME */
            /* HASH RATE */
            {
                const normalizedSiteHashrate = HashrateUtil.normalizeHashrate(resp.siteHashrate, resp.siteHashrateUnit, resp.siteExpectedHashrateUnit);
                const normalizedExpectedHashrate = HashrateUtil.normalizeHashrate(resp.siteExpectedHashrate, resp.siteExpectedHashrateUnit, resp.siteExpectedHashrateUnit);
                const filledPercentage = MathUtil.divide(normalizedSiteHashrate.hashesPerSecond, normalizedExpectedHashrate.hashesPerSecond);
                const barWidth = formatPercentageCapped(filledPercentage);
                const efficiencyPercentage = formatPercentage(filledPercentage);
                $("#hashRateBar").css("width", barWidth);
                $("#hashRateBarVal").text(normalizedSiteHashrate.value);
                $("#hashRateBarValUnits").text(normalizedSiteHashrate.unit);
                $("#hashRatePotential").text(normalizedExpectedHashrate.value);
                $("#hashRatePotentialUnits").text(normalizedExpectedHashrate.unit);
                $("#hashratePercentValue").text(efficiencyPercentage);
            }
            /* HASH RATE */
        });
    }
    loadCharts(params, siteId) {
        this.hashrateChart.chart.currentQueryParams = params;
        return Promise.all([
            this.loadEfficiencyCharts(params, siteId),
            this.hashrateChart.chart.load([["siteId", siteId]])
        ]).then(() => {
            if (this.keyMetricData.scheduledShutdowns.length > 0) {
                this.filterHashrateData();
            }
        });
    }
    loadEfficiencyCharts(params, siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!siteId) {
                siteId = parseInt(yield this.getSiteId());
            }
            this.toggleBusy(true);
            const resp = yield this.get(`${this.keyMetricsUrl}?siteId=${siteId}&interval=${params.step}&step=${params.step}&start=${params.start}&end=${params.end}`);
            this.keyMetricData = resp;
            this.fillStats(resp);
            this.populateChartLabels(resp);
            const baseline = this.getBaselineDatapoints(resp);
            this.siteUtilizationChart.series = [{ name: "Actual", data: resp.siteUtilization.data.result[0].values }, baseline];
            this.uptimeChart.series = [{ name: "Actual", data: resp.uptime.data.result[0].values }, baseline];
            this.siteUtilizationChart.render();
            this.uptimeChart.render();
            this.toggleBusy(false);
        });
    }
    populateChartLabels(data) {
        const [siteUtilStart, siteUtilEnd] = this.getChartLabels(data.siteUtilization.data.result[0].values);
        $("#siteUtilizationStartLabel").text(siteUtilStart);
        $("#siteUtilizationEndLabel").text(siteUtilEnd);
        const [uptimeStart, uptimeEnd] = this.getChartLabels(data.uptime.data.result[0].values);
        $("#uptimeStartLabel").text(uptimeStart);
        $("#uptimeEndLabel").text(uptimeEnd);
        const [hashrateStart, hashrateEnd] = this.getChartLabels(data.hashrateEfficiency.data.result[0].values);
        $("#hashrateStartLabel").text(hashrateStart);
        $("#hashrateEndLabel").text(hashrateEnd);
    }
    getChartLabels(data) {
        const last = data.length - 1;
        const start = window.moment(new Date(data[0][0]));
        const end = window.moment(new Date(data[last][0]));
        const startDate = start.format("MM-DD-YYYY");
        const startTime = start.format("HH:mm");
        const endDate = end.format("MM-DD-YYYY");
        const endTime = end.format("HH:mm");
        return [
            `${startDate}\n${startTime}`,
            `${endDate}\n${endTime}`
        ];
    }
    fillStats(data) {
        $("#hashrateEfficiencyAvg").text(`${data.averageHashrateEfficiency}%`);
        $("#uptimeAvg").text(`${data.averageUptime}%`);
        $("#siteUtilizationAvg").text(`${data.averageSiteUtilization}%`);
    }
    /**
     * Updates the hashrate chart to default to the baseline during an excused event
     */
    filterHashrateData() {
        let eeCursor = new ExcusedEventsCursor(this.keyMetricData.scheduledShutdowns);
        let currentEvent = eeCursor.getCurrentEvent();
        const [actual, baseline] = this.hashrateChart.chart.series;
        let filteredSeries = this.hashrateChart.chart.series;
        for (let i = 0; i < actual.data.length; i++) {
            if (currentEvent) {
                const datapointUnixTime = actual.data[i][0];
                const currentEventStartUnixTime = new Date(currentEvent.start).getTime();
                const currentEventEndUnixTime = currentEventStartUnixTime + (currentEvent.duration * 1000);
                if (datapointUnixTime >= currentEventStartUnixTime && datapointUnixTime <= currentEventEndUnixTime) {
                    filteredSeries[0].data[i] = baseline.data[i];
                    continue;
                }
                if (i == actual.data.length) {
                    break;
                }
                const nextDatapointUnixTime = actual.data[i + 1][0];
                if (nextDatapointUnixTime > currentEventEndUnixTime) {
                    currentEvent = eeCursor.nextEvent();
                }
            }
        }
        this.hashrateChart.chart.series = filteredSeries;
        this.hashrateChart.chart.render();
    }
    /**
     * calculates the average efficiency metrics excluding data during excused events
     * @param data
     * @returns
     */
    filterExcusedEvents(data) {
        let eeCursor = new ExcusedEventsCursor(data.scheduledShutdowns);
        let currentEvent = eeCursor.getCurrentEvent();
        let siteUtilSum = 0;
        let uptimeSum = 0;
        let hrSum = 0;
        let count = 0;
        for (let i = 0; i < data.uptime.data.result[0].values.length; i++) {
            if (currentEvent) {
                const datapointUnixTime = data.uptime.data.result[0].values[i][0];
                const currentEventStartUnixTime = new Date(currentEvent.start).getTime();
                const currentEventEndUnixTime = currentEventStartUnixTime + (currentEvent.duration * 1000);
                if (datapointUnixTime >= currentEventStartUnixTime && datapointUnixTime <= currentEventEndUnixTime) {
                    continue;
                }
                if (i == data.uptime.data.result[0].values.length) {
                    break;
                }
                const nextDatapointUnixTime = data.uptime.data.result[0].values[i + 1][0];
                if (nextDatapointUnixTime > currentEventEndUnixTime) {
                    currentEvent = eeCursor.nextEvent();
                }
            }
            siteUtilSum += parseFloat(data.siteUtilization.data.result[0].values[i][1]) || 0.0;
            uptimeSum += parseFloat(data.uptime.data.result[0].values[i][1]) || 0.0;
            hrSum += parseFloat(data.hashrateEfficiency.data.result[0].values[i][1]) || 0.0;
            count++;
        }
        return {
            avgSiteUtilization: siteUtilSum / count,
            avgUptime: uptimeSum / count,
            avgHashrateEff: hrSum / count
        };
    }
    getBaselineDatapoints(data) {
        const datapoints = data.hashrateEfficiency.data.result[0].values.map(v => [v[0], "100.0"]);
        return {
            name: "Baseline",
            data: datapoints
        };
    }
    exportChartData() {
        const hashrateSeries = this.hashrateChart.chart.series[0].data;
        const hreSeries = this.keyMetricData.hashrateEfficiency.data.result[0].values;
        const header = ["Time", "Hash Rate (Hs)", "Hash Rate Efficiency (%)", "Uptime (%)", "Site Utilization (%)", "\r\n"].join(',');
        const rows = hreSeries.map(([time, hre], index) => {
            return [
                window.moment(new Date(time)).format("MM-DD-YYYY HH:mm:ss"),
                hashrateSeries[index][1] || 0.0,
                parseFloat(hre) || 0.0,
                parseFloat(this.keyMetricData.uptime.data.result[0].values[index][1]) || 0.0,
                parseFloat(this.keyMetricData.siteUtilization.data.result[0].values[index][1]) || 0.0,
                "\r\n"
            ].join(",");
        });
        const csv = [header, ...rows].join("");
        const siteName = this.getSiteName();
        ExcelUtility.exportFromCsvData(csv, `Customer Dashboard (${siteName})`);
    }
    exportExcusedEventsGrid() {
        this.excusedEventsGrid.exportExcel();
    }
}
const CHART_LINE_COLORS = ["#00E67E", "#66736D"];
const PERCENT_CHART_OPTIONS = {
    chart: {
        animations: {
            enabled: false
        },
        type: "line",
        stacked: false,
        height: "122px",
        zoom: {
            enabled: false,
        },
        toolbar: {
            show: false,
            tools: {
                zoom: false
            }
        }
    },
    colors: CHART_LINE_COLORS,
    grid: {
        yaxis: {
            lines: {
                show: false
            }
        }
    },
    dataLabels: {
        enabled: false
    },
    noData: {
        text: 'No data is available for this time range'
    },
    stroke: {
        colors: CHART_LINE_COLORS,
        dashArray: [0, 2],
        curve: 'smooth',
        width: 1.5
    },
    legend: {
        show: false,
        labels: {
            colors: CHART_LINE_COLORS
        }
    },
    xaxis: {
        show: false,
        type: 'numeric',
        labels: {
            show: false,
            maxHeight: 5,
            minHeight: 5,
            hideOverlappingLabels: true,
            formatter: (value, timestamp, opts) => {
                const m = window.moment(new Date(value));
                return m.format("YYYY-MM-DD HH:mm");
            },
            style: {
                colors: '#aab2af',
                fontFamily: "var(--font-family)",
                fontSize: "12px",
                fontWeight: 400,
                cssClass: "chart-text"
            },
            trim: false,
        },
        tooltip: {
            enabled: false
        },
        tickAmount: 0,
        axisTicks: {
            show: false
        },
        axisBorder: {
            show: false,
            color: "#3b403e",
            borderType: "1px solid",
            offsetX: 0
        }
    },
    yaxis: {
        showAlways: true,
        //forceNiceScale: true,
        labels: {
            show: true,
            minWidth: 0,
            maxWidth: 30,
            style: {
                colors: '#aab2af',
                fontFamily: "var(--font-family)",
                fontSize: "12px",
                fontWeight: 400,
                cssClass: "chart-text"
            },
            formatter: (value) => { return `${Math.round(value)}%`; }
        },
        min: 0,
        //max: 105,
        tickAmount: 1,
    }
};
const HASHRATE_CHART_OPTIONS = {
    chart: {
        animations: {
            enabled: false
        },
        type: "line",
        stacked: false,
        height: "122px",
        zoom: {
            enabled: false,
        },
        toolbar: {
            show: false,
            tools: {
                zoom: false
            }
        }
    },
    colors: CHART_LINE_COLORS,
    grid: {
        yaxis: {
            lines: {
                show: false
            }
        }
    },
    dataLabels: {
        enabled: false
    },
    noData: {
        text: 'No data is available for this time range'
    },
    stroke: {
        colors: CHART_LINE_COLORS,
        dashArray: [0, 2],
        curve: 'smooth',
        width: 1.5
    },
    legend: {
        show: false,
        labels: {
            colors: CHART_LINE_COLORS
        }
    },
    xaxis: {
        show: false,
        type: 'numeric',
        labels: {
            show: false,
            maxHeight: 5,
            minHeight: 5,
            hideOverlappingLabels: true,
            formatter: (value, timestamp, opts) => {
                const m = window.moment(new Date(value));
                return m.format("YYYY-MM-DD HH:mm");
            },
            style: {
                colors: '#aab2af',
                fontFamily: "var(--font-family)",
                fontSize: "12px",
                fontWeight: 400,
                cssClass: "chart-text"
            },
            trim: false,
        },
        tooltip: {
            enabled: false
        },
        tickAmount: 0,
        axisTicks: {
            show: false
        },
        axisBorder: {
            show: false,
            color: "#3b403e",
            borderType: "1px solid",
            offsetX: 0
        }
    },
    yaxis: {
        showAlways: true,
        //forceNiceScale: true,
        labels: {
            show: true,
            minWidth: 0,
            maxWidth: 65,
            style: {
                colors: '#aab2af',
                fontFamily: "var(--font-family)",
                fontSize: "12px",
                fontWeight: 400,
                cssClass: "chart-text"
            },
            formatter: (value) => { return HashrateUtil.parseHashrate(value, 1); }
        },
        min: 0,
        //max: 105,
        tickAmount: 1,
    }
};
class ExcusedEventsCursor {
    constructor(events) {
        this.events = events;
        this.cursor = 0;
    }
    getCurrentEvent() {
        return this.events[this.cursor];
    }
    // get next cursor whose endtime is greater than the previous cursors endtime
    nextEvent() {
        if (this.events.length <= this.cursor + 1)
            return;
        const nextCursor = this.cursor + 1;
        const currentEvent = this.events[this.cursor];
        const nextEvent = this.events[nextCursor];
        const currentEventEnd = new Date(currentEvent.start).getTime() / 1000 + currentEvent.duration;
        const nextEventEnd = new Date(nextEvent.start).getTime() / 1000 + nextEvent.duration;
        this.cursor = nextCursor;
        if (nextEventEnd > currentEventEnd) {
            return nextEvent;
        }
        return this.nextEvent();
    }
}

class ForgotPassword extends OptiFleetService {
    constructor() {
        super();
        this.securityQuestionUrl = "/SecurityQuestion";
        this.resetPassUrl = "/ResetPass";
    }
    toggleNextButton() {
        const email = $("#email").val().length;
        if (email > 0) {
            $("#nextButton").removeAttr("disabled");
            return;
        }
        $("#nextButton").attr("disabled", "disabled");
    }
    toggleResetPassword() {
        const answer = $("#answer").val().length;
        if (answer > 0) {
            $("#submit").removeAttr("disabled");
            return;
        }
        $("#submit").attr("disabled", "disabled");
    }
    recoverAccount() {
        $(".invalid-email").addClass("hide");
        $("#invalidUserNameEmail").addClass("hide");
        const email = $("#email").val();
        const emailRegex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/;
        if (!emailRegex.test(email)) {
            $(".invalid-email").removeClass("hide");
            return;
        }
        const forgotPassData = {
            username: email
        };
        this.toggleLoginBusy(true);
        this.post(this.securityQuestionUrl, forgotPassData)
            .then((response) => {
            this.toggleLoginBusy(false);
            if (response.success) {
                this.showSecurityQuestion(response.question);
                return;
            }
            $("#invalidUserNameEmail").removeClass("hide");
        });
    }
    showSecurityQuestion(question) {
        $(".account-info").removeClass("active");
        $(".security-question-panel").addClass("active");
        $(".security-question").text(question);
    }
    toggleLoginBusy(isBusy) {
        if (!isBusy) {
            $(".login-busy").removeClass("active");
            return;
        }
        $(".login-busy").addClass("active");
    }
    resetPassword() {
        const email = $("#email").val();
        $("#username").val();
        const answer = $("#answer").val();
        const forgotPassData = {
            username: email,
            email: email,
            answer: answer
        };
        this.toggleLoginBusy(true);
        this.post(this.resetPassUrl, forgotPassData)
            .then((response) => {
            this.toggleLoginBusy(false);
            if (response.success) {
                this.showSuccess();
                return;
            }
            $("#invalidAnswer").removeClass("hide");
        });
    }
    showSuccess() {
        $(".security-question-panel").removeClass("active");
        $(".success-panel").addClass("active");
    }
}

class ResetPass extends OptiFleetService {
    constructor() {
        super();
        this.resetPassUrl = "/ResetUserPass";
    }
    toggleChangePassword() {
        const password = $("#password").val();
        const confirmPass = $("#confirmPass").val();
        if (password.length > 0 && confirmPass.length > 0) {
            $("#changePass").removeAttr("disabled");
            return;
        }
        $("#changePass").attr("disabled", "disabled");
    }
    complete() {
        if (!this.isValid()) {
            return;
        }
        const nonce = window.location.search.replace("?nonce=", "");
        const password = $("#password").val();
        const resetPassData = {
            nonce: nonce,
            password: btoa(password)
        };
        this.post(this.resetPassUrl, resetPassData)
            .then((resp) => {
            if (!resp.success) {
                this.showError();
                return;
            }
            window.location.href = "/Content/Login/Start.aspx";
        });
    }
    showError() {
        //todo
    }
    isValid() {
        const password = $("#password").val();
        const confirmPass = $("#confirmPass").val();
        if (password !== confirmPass) {
            $(".passwords-dont-match").removeClass("hide");
            return false;
        }
        const symbols = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]+/;
        const hasSymbols = symbols.test(password);
        const hasNumbers = password.match(/^[^0-9]+$/) ? false : true;
        const hasChars = password.match(/^[^a-zA-Z]+$/) ? false : true;
        if (password.length < 8 || !hasSymbols || !hasNumbers || !hasChars) {
            $(".password-too-short").removeClass("hide");
            return;
        }
        return true;
    }
}

class MinerView extends OptiFleetPage {
    constructor() {
        super();
        this.service = new MinerViewService();
        this.initGrid();
        this.loadMiners();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
    }
    handleCompanyFilterChanged(companyId) {
        this.loadMiners();
        this.getUnsupportedModels().then((models) => {
            this.handleUnsupportedModelsWarning(models);
        });
    }
    handleUnsupportedModelsWarning(models) {
        if (models.length === 0) {
            $(".unsupported-models").removeClass("active");
            return;
        }
        $(".unsupported-models").addClass("active");
    }
    loadMiners() {
        let siteId = -1;
        try {
            siteId = parseInt(window.location.search.split("=")[1]);
        }
        catch (_a) {
            //eat
        }
        this.toggleBusy(true);
        this.service.getMiners(this.getSelectedCompanyId(), siteId)
            .then((resp) => {
            if (resp.miners.length === 0) {
                this.showNullState("There aren't any miners setup yet.");
                this.toggleBusy(false);
                return;
            }
            this.hideNullState();
            this.populateMinersGrid(resp.miners);
        });
    }
    initGrid() {
        this.toggleBusy(true);
        $("#minerList").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20,
                group: {
                    field: "companyName",
                    dir: "asc"
                }
            },
            pageable: {
                numeric: false,
                previousNext: false,
            },
            scrollable: {
                virtual: true
            },
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            columns: [
                { command: { text: "View Stats", click: this.showDetails.bind(this) }, title: " ", width: "150px" },
                { field: "name", title: "Name", filterable: { extra: false, search: true }, width: "200px" },
                { field: "model", title: "Model", filterable: { multi: true }, width: "165px" },
                { field: "ipAddress", title: "IP Address", filterable: { extra: false, search: true }, width: "145px" },
                { field: "expectedHashrateString", title: "Expected Hash Rate", width: "185px" },
                { field: "currentHashRateString", title: "Hash Rate", width: "125px" },
                { field: "serialNumber", title: "Serial Number", filterable: { extra: false, search: true }, width: "180px" },
                { field: "locationName", title: "Location", width: 150, filterable: { extra: false, search: true } },
                { field: "status", title: "Status", width: 110, filterable: { multi: true } },
                { field: "onlineDateFormatted", title: "Install Date", width: 130, filterable: { multi: true } },
                //{ field: "contractWatts", title: "Contracted Watts", width: 175, filterable: { multi: true } },
                //{ field: "contractEndDateFormatted", title: "Contracted End Date", width: 195, filterable: { multi: true } },
                //{ field: "monthlyRate", title: "Monthly Rate", width: 150, filterable: { multi: true } },
                //{ field: "kwhRate", title: "KWh Rate", width: 130, filterable: { multi: true } },
                { field: "companyName", title: "Company", hidden: true }
            ],
            dataBound: (e) => {
                this.styleHashrate(e);
            }
        });
    }
    styleHashrate(e) {
        const rows = e.sender.tbody.children();
        for (var i = 0; i < rows.length; i++) {
            const row = $(rows[i]);
            const dataItem = e.sender.dataItem(row);
            if (!dataItem) {
                continue;
            }
            const columnIdx = this.getSelectedCompanyId() > 0 ? 5 : 6;
            const hashrateCell = row.children().eq(columnIdx);
            const expectedHashrate = dataItem.get("expectedHashRate");
            const currentHashrate = dataItem.get("currentHashRate");
            const performance = (currentHashrate / expectedHashrate) * 100;
            if (performance >= 95) {
                hashrateCell.addClass("good-hashrate");
            }
            else if (performance >= 85) {
                hashrateCell.addClass("ok-hashrate");
            }
            else if (performance > 0 && performance < 85) {
                hashrateCell.addClass("bad-hashrate");
            }
        }
    }
    showDetails(e) {
        e.preventDefault();
        const grid = $("#minerList").data("kendoGrid");
        const row = $(e.currentTarget).closest("tr");
        const dataItem = grid.dataItem(row);
        if (window.location.href.indexOf("OptiFleet.Portal") > -1) {
            window.open(`/OptiFleet.Portal/Content/Miners/IndividualMiner.aspx?id=${dataItem.get("id")}`, "_blank");
            return;
        }
        window.open(`/Content/Miners/IndividualMiner.aspx?id=${dataItem.get("id")}`, "_blank");
    }
    populateMinersGrid(miners) {
        this.miners = miners;
        const grid = $("#minerList").data("kendoGrid");
        if (this.getSelectedCompanyId() <= 0) {
            const dataSource = new self.kendo.data.DataSource({
                data: miners,
                pageSize: 20,
                group: {
                    field: "companyName",
                    dir: "asc"
                }
            });
            grid.setDataSource(dataSource);
            this.toggleBusy(false);
            return;
        }
        const dataSource = new self.kendo.data.DataSource({
            data: miners,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
        this.toggleBusy(false);
    }
    exportToExcel() {
        event.preventDefault();
        const headers = $("#minerList").find(".k-grid-header th").get();
        const startIdx = this.getSelectedCompanyId() > 0 ? 1 : 2;
        const trimmedHeaders = headers.slice(startIdx, headers.length - 1);
        let trimmedRows = [];
        this.miners.forEach((miner) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart <= trimmedHeaders.length; cellStart++) {
                newRow.append(this.getMinerPropertyAsCell(miner, cellStart));
            }
            trimmedRows.push(newRow);
        });
        $("#minerViewActionsDropdown").attr("aria-hidden", "true");
        ExcelUtility.exportToExcel(trimmedHeaders, trimmedRows, "miners");
    }
    exportToCsv() {
        event.preventDefault();
        const headers = $("#minerList").find(".k-grid-header th").get();
        const startIdx = this.getSelectedCompanyId() > 0 ? 1 : 2;
        const trimmedHeaders = headers.slice(startIdx, headers.length - 1);
        let trimmedRows = [];
        this.miners.forEach((miner) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart <= trimmedHeaders.length; cellStart++) {
                newRow.append(this.getMinerPropertyAsCell(miner, cellStart));
            }
            trimmedRows.push(newRow);
        });
        $("#minerViewActionsDropdown").attr("aria-hidden", "true");
        ExcelUtility.exportToCSV(trimmedHeaders, trimmedRows, "miners");
    }
    getMinerPropertyAsCell(miner, index) {
        let prop = "";
        switch (index) {
            case 1:
                prop = miner.name;
                break;
            case 2:
                prop = miner.model;
                break;
            case 3:
                prop = miner.ipAddress;
                break;
            case 4:
                prop = miner.expectedHashrateString;
                break;
            case 5:
                prop = miner.currentHashRateString;
                break;
            case 6:
                prop = miner.serialNumber;
                break;
            case 7:
                prop = miner.locationName;
                break;
            case 8:
                prop = miner.status;
                break;
            case 9:
                prop = miner.onlineDateFormatted;
                break;
        }
        const cell = document.createElement("td");
        cell.innerText = prop;
        return cell;
    }
}

class DailyPerformanceReport extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: false });
        this.loadStatsURL = "/DailyPerformanceReport";
        this.subscribeURL = "/EmailSubscription";
        this.isBusy = false;
        this.init();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
    }
    init() {
        $("#datePicker").kendoDatePicker(this.getDatePickerOptions());
        $("#btnRunReport").on('click', this.reload.bind(this));
        $("#switch").kendoSwitch({
            change: this.subscribe.bind(this),
        });
        $(document).on("siteFilterChanged", (siteId) => {
            this.refreshSubscriptionToggle();
        });
    }
    handleCompanyFilterChanged() {
        this.siteCache.loadSites().then(() => __awaiter(this, void 0, void 0, function* () {
            this.refreshSubscriptionToggle();
        }));
    }
    refreshSubscriptionToggle() {
        return __awaiter(this, void 0, void 0, function* () {
            this.get(`${this.subscribeURL}?siteId=${yield this.siteCache.getSiteId()}`).then(resp => {
                $("#switch").data("kendoSwitch").check(resp.subscribed);
            });
        });
    }
    getDatePickerOptions() {
        return {
            start: "month",
            depth: "month",
            min: new Date(2020, 0),
            max: new Date(),
            format: "dd MMMM yyyy",
            dateInput: false,
            value: new Date(),
        };
    }
    busy(toggle) {
        if (toggle) {
            if (this.isBusy) {
                throw "Already busy";
            }
            this.isBusy = true;
            $(".daily-content-container .m-grid").addClass("blurry");
            $(".spinner").removeClass("hide");
        }
        else {
            $(".daily-content-container .m-grid").removeClass("blurry");
            $(".spinner").addClass("hide");
            this.isBusy = false;
        }
    }
    reload() {
        try {
            this.busy(true);
            $(".reportDate").removeClass("error");
            let selectedDate = $("#datePicker").data("kendoDatePicker").value();
            let formattedDate = window.moment(selectedDate).format("MMMM Do YYYY");
            let reportDateText = (this.getSelectedCompanyName() != null) ? this.getSelectedCompanyName() + " - " : "";
            reportDateText += formattedDate;
            $(".reportDate").text(reportDateText);
            this.get(`${this.loadStatsURL}?Date=${selectedDate.toISOString()}`)
                .then((resp) => {
                if (resp == null) {
                    $(".reportDate").text("An error has occurred running this report").addClass("error");
                    this.busy(false);
                    return;
                }
                $("#valuebox-AverageHashrate").text(HashrateUtil.parseHashrate(resp.averageHashrate, 1));
                $("#valuebox-LowestHashrate").text(HashrateUtil.parseHashrate(resp.lowestHashrate, 1));
                $("#valuebox-HighestHashrate").text(HashrateUtil.parseHashrate(resp.highestHashrate, 1));
                $("#valuebox-OnlineMiners").text(resp.onlineMiners);
                $("#valuebox-LowestNumberHashing").text(resp.lowestNumberHashing);
                $("#valuebox-HighestNumberHashing").text(resp.highestNumberHashing);
                this.busy(false);
            });
        }
        catch (ex) {
            //eat
        }
        return false;
    }
    formatWattage(value) {
        if (value < 1000) {
            return value + " Wh";
        }
        if (value < 1000000) {
            return (value / 1000).toFixed(2) + " kWh";
        }
        if (value < 1000000000) {
            return (value / 1000000).toFixed(2) + " MWh";
        }
        return value + " Wh";
    }
    subscribe(event) {
        this.siteCache.getSiteId().then(siteId => {
            const data = {
                report: "DailyPerformanceReport",
                subscribe: event.checked,
                siteId: parseInt(siteId),
            };
            this.post(this.subscribeURL, data).then(resp => {
                return resp.success;
            });
        });
    }
}

class EgaugeReport extends OptiFleetPage {
    constructor() {
        super();
        this.egaugeUrl = "/egauges";
        this.init();
    }
    init() {
        this.toggleBusy(true);
        $("#egaugeList").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20
            },
            scrollable: {
                virtual: true
            },
            filterable: false,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            save: this.onSave.bind(this),
            toolbar: [
                { name: "create", text: "Add New" },
            ],
            columns: [
                {
                    command: [
                        { name: "edit", template: "<a class='op-grid-button k-grid-edit' title='Edit'><i class='icon-pencil'>edit</i></a>" },
                    ], title: "", width: "120px"
                },
                { field: "hostname", title: "Hostname", filterable: { extra: false, search: true }, width: "250px" },
                { field: "serialNumber", title: "Serial Number", filterable: { extra: false, search: true }, width: "310px" },
                { field: "facility", title: "Facility", filterable: { extra: false, search: true }, width: "200px" },
                { field: "", title: "", template: this.getDeleteTemplate.bind(this) }
            ]
        });
        this.loadEgauges();
    }
    getDeleteTemplate(egauge) {
        return `<button type="button" onclick="e.confirmDelete(${egauge.egaugeId})" class="m-button is-secondary">delete</button>`;
    }
    confirmDelete(egaugeId) {
        const egauge = this.egauges.filter((e) => e.egaugeId == egaugeId)[0];
        const msg = `Are you sure you want to delete egauge ${egauge.hostname}?`;
        kendo.confirm(msg)
            .done(() => {
            this.toggleBusy(true);
            this.deleteEgauge(egauge)
                .then(() => {
                this.loadEgauges();
            });
        })
            .fail(() => {
            //noop
        });
    }
    deleteEgauge(egauge) {
        return this.delete(this.egaugeUrl, { egaugeId: egauge.egaugeId, hostname: egauge.hostname });
    }
    loadEgauges() {
        this.get(this.egaugeUrl)
            .then((resp) => {
            this.egauges = resp.egauges;
            this.populateEgauges(resp.egauges);
            this.toggleBusy(false);
        });
    }
    populateEgauges(egauges) {
        const grid = $("#egaugeList").data("kendoGrid");
        const dataSource = new self.kendo.data.HierarchicalDataSource({
            data: egauges,
            pageSize: 20,
            schema: {
                model: {
                    id: "egaugeId",
                    fields: {
                        egaugeId: { editable: false, nullable: true },
                        hostname: { validation: { required: true } },
                        serialNumber: { validation: { required: true } },
                        facility: { validation: { required: true } }
                    }
                }
            }
        });
        grid.setDataSource(dataSource);
    }
    onSave(e) {
        e.preventDefault();
        const saveData = this.getEgaugeData(e.model);
        this.post(this.egaugeUrl, { egauge: saveData })
            .then((resp) => {
            if (!resp.success) {
                this.toggleBusy(false);
                this.showErrorMessage("Something went wrong while saving the egauge record.");
                return;
            }
            this.showSuccessMessage("Saved!");
            this.loadEgauges();
        });
    }
    getEgaugeData(model) {
        return {
            egaugeId: model.egaugeId,
            facility: model.facility,
            hostname: model.hostname,
            serialNumber: model.serialNumber
        };
    }
    exportToExcel() {
        event.preventDefault();
        const headers = $("#egaugeList").find(".k-grid-header th").get();
        headers.shift();
        headers.pop();
        let rows = [];
        this.egauges.forEach((egauge) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart < headers.length + 1; cellStart++) {
                newRow.append(this.getMinerPropertyAsCell(egauge, cellStart));
            }
            rows.push(newRow);
        });
        ExcelUtility.exportToExcel(headers, rows, "Egauges");
    }
    exportToCsv() {
        event.preventDefault();
        const headers = $("#egaugeList").find(".k-grid-header th").get();
        headers.shift();
        headers.pop();
        let rows = [];
        this.egauges.forEach((egauge) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart < headers.length + 1; cellStart++) {
                newRow.append(this.getMinerPropertyAsCell(egauge, cellStart));
            }
            rows.push(newRow);
        });
        ExcelUtility.exportToCSV(headers, rows, "Egauges");
    }
    getMinerPropertyAsCell(egauge, index) {
        let prop = "";
        switch (index) {
            case 1:
                prop = egauge.hostname;
                break;
            case 2:
                prop = egauge.serialNumber;
                break;
            case 3:
                prop = egauge.facility;
                break;
        }
        const cell = document.createElement("td");
        cell.innerText = prop;
        return cell;
    }
}

class EnergyReport extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: true, elemId: "ddlSites" });
        this.sitesUrl = "/sites";
        this.energyUrl = "/energyreport?siteId=";
        this.isInitialLoad = true;
        this.isBusy = false;
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        this.consumptionGraph = new ConsumptionGraph();
        this.meteredGraph = new EgaugeGraph();
        this.ercotGraph = new ErcotGraph();
        this.curtailmentPanel = new CurtailmentEventsPanel();
        this.datePicker = new DatePicker("#datePicker", this.reload.bind(this));
    }
    handleCompanyFilterChanged(companyId) {
        if (companyId == -1) {
            this.toggleSelectCompany(true);
            return;
        }
        this.toggleSelectCompany(false);
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(siteId) {
        const params = this.datePicker.getParams();
        this.reload(params, siteId);
    }
    reload(params, siteId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.toggleChartsBusy();
            $("#ddlSites").data("kendoDropDownList");
            const start = window.moment.utc(params.start * 1000).toISOString();
            const end = window.moment.utc(params.end * 1000).toISOString();
            const url = `${this.energyUrl}${siteId}&start=${start}&end=${end}&step=${params.step}`;
            params.siteId = parseInt(siteId);
            const resp = yield this.get(url);
            this.populateEnergyData(resp);
            this.toggleChartsBusy();
        });
    }
    populateEnergyData(resp) {
        this.consumptionGraph.populateChartData([resp.derivedConsumption, resp.meteredConsumption]);
        this.meteredGraph.populateChartData(resp.egaugeData);
        this.ercotGraph.populateChartData(resp.ercotData);
        this.curtailmentPanel.populateEvents(resp.siteCurtailments);
        this.populateErcotStat(resp.ercotData);
        this.populateMeteredStat(resp.meteredConsumption);
        this.populateDerivedStat(resp.derivedConsumption);
    }
    populateErcotStat(ercotData) {
        const westLoadZone = ercotData.data.result.filter((value) => {
            return value.metric.location === "LZ_WEST";
        })[0];
        if (!westLoadZone) {
            $("#priceStat").text("N/A");
            return;
        }
        const idx = westLoadZone.values.length - 1;
        const lastData = westLoadZone.values[idx];
        $("#priceStat").text(`$${lastData[1]}`);
    }
    populateMeteredStat(meteredConsumption) {
        if (meteredConsumption.data.result.length === 0) {
            $("#meteredStat").text("N/A");
            $("#meteredUnit").text("");
            return;
        }
        const idx = meteredConsumption.data.result[0].values.length - 1;
        const lastData = meteredConsumption.data.result[0].values[idx];
        const load = PowerConverter.getPowerScaled(lastData[1], 1);
        const unit = PowerConverter.getPowerUnit(lastData[1]);
        $("#meteredStat").text(load);
        $("#meteredUnit").text(unit);
    }
    populateDerivedStat(derivedConsumption) {
        if (derivedConsumption.data.result.length === 0) {
            $("#estimatedStat").text("N/A");
            $("#estimatedUnit").text("");
            return;
        }
        const idx = derivedConsumption.data.result[0].values.length - 1;
        const lastData = derivedConsumption.data.result[0].values[idx];
        const load = PowerConverter.getPowerScaled(lastData[1], 1);
        const unit = PowerConverter.getPowerUnit(lastData[1]);
        $("#estimatedStat").text(load);
        $("#estimatedUnit").text(unit);
    }
    toggleChartsBusy() {
        this.isBusy = !this.isBusy;
        this.consumptionGraph.chart.toggleGraphBusy(this.isBusy);
        this.meteredGraph.chart.toggleGraphBusy(this.isBusy);
        this.ercotGraph.chart.toggleGraphBusy(this.isBusy);
    }
}

const DEFAULT_GRID_OPTIONS = {
    dataSource: {
        data: [],
        pageSize: 100,
    },
    pageable: {
        numeric: true,
        previousNext: true,
    },
    excel: {
        allPages: true
    },
    scrollable: {
        virtual: false
    },
    noRecords: {
        template: "<div class=\"no-records\">You haven't run a report yet.</div>"
    },
    filterable: false,
    groupable: false,
    sortable: true,
    resizable: true,
    editable: "inline",
};
class ExceptionsReport extends OptiFleetPage {
    constructor() {
        super();
        this.exceptionReportUrl = "/MinerExceptionReport?Report=4";
        this.initGrid();
        this.loadExceptionReport();
    }
    initGrid() {
        $("#reportList").kendoGrid(Object.assign(Object.assign({}, DEFAULT_GRID_OPTIONS), { columns: [
                { field: "companyName", title: "Company", filterable: { multi: true }, width: "140px" },
                { field: "minerName", title: "Miner Name", filterable: { multi: true }, width: "240px" },
                { field: "ipAddress", title: "Ip Address", filterable: { extra: false, search: true }, width: "120px" },
                { field: "worker", title: "Worker", filterable: { extra: false, search: true }, width: "150px" },
            ] }));
    }
    loadExceptionReport() {
        this.toggleGridBusy(true);
        this.get(this.exceptionReportUrl)
            .then((resp) => {
            this.populateGrid(resp.reportData);
            this.toggleGridBusy(false);
        });
    }
    toggleGridBusy(isBusy) {
        if (!isBusy) {
            $(".grid-busy").removeClass("active");
            return;
        }
        $(".grid-busy").addClass("active");
    }
    populateGrid(data) {
        const grid = $("#reportList").data("kendoGrid");
        if (data.length === 0) {
            $(".no-records").text("Good news! There isn't any exceptions that need fixing.");
            const dataSource = new self.kendo.data.HierarchicalDataSource({
                data: [],
                pageSize: 20
            });
            grid.setDataSource(dataSource);
            return;
        }
        const dataSource = new self.kendo.data.HierarchicalDataSource({
            data: data,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
    }
    exportToExcel() {
        const grid = $("#reportList").data("kendoGrid");
        grid.saveAsExcel();
    }
}

class MinerFeesReport extends OptiFleetPage {
    constructor() {
        super();
        this.minerFeesUrl = "/MinerFees";
        this.init();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
    }
    init() {
        this.initMonthPicker();
        this.initGrid();
    }
    initMonthPicker() {
        $("#rdpStart").kendoDatePicker({
            depth: "month",
            format: "MM/dd/yyyy",
            value: new Date()
        });
        $("#rdpEnd").kendoDatePicker({
            depth: "month",
            format: "MM/dd/yyyy",
            value: new Date()
        });
    }
    initGrid() {
        $("#minerList").kendoGrid({
            pageable: false,
            scrollable: true,
            height: "100%",
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: false,
            columns: [
                { field: "serialNumber", title: "Serial Number", filterable: { extra: false, search: true }, width: "105px" },
                { field: "model", title: "Model", filterable: { multi: true }, width: "195px" },
                { field: "onlineDateFormatted", title: "Online Date", filterable: false, width: "120px" },
                { field: "facility", title: "Facility", filterable: false, width: "120px" },
                { field: "usageFee", title: "Accrued Fee", filterable: false, width: "120px", format: "{0:c2}" },
                { field: "packageFee", title: "Package Fee", filterable: false, width: "120px", format: "{0:c2}" }
            ]
        });
    }
    runReport() {
        this.loadMinerFees();
    }
    handleCompanyFilterChanged(companyId) {
        if (this.getSelectedCompanyId() <= 0) {
            this.toggleSelectCompany(true);
            return;
        }
        this.toggleSelectCompany(false);
        this.loadMinerFees();
    }
    loadMinerFees() {
        const rdpStart = $("#rdpStart").data("kendoDatePicker");
        const startDate = rdpStart.value();
        const rdpEnd = $("#rdpEnd").data("kendoDatePicker");
        const endDate = rdpEnd.value();
        if (!startDate || !endDate || startDate > endDate) {
            return;
        }
        this.toggleBusy(true);
        this.get(this.minerFeesUrl + `?start=${startDate.toISOString()}&end=${endDate.toISOString()}`)
            .then((resp) => {
            this.minerFees = resp.minerFees;
            this.populateMinerList(resp.minerFees);
        });
    }
    populateMinerList(minerFees) {
        const grid = $("#minerList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: minerFees
        });
        grid.setDataSource(dataSource);
        this.toggleBusy(false);
    }
    exportToExcel() {
        event.preventDefault();
        const header = $("#minerList").find(".k-grid-header th").get();
        const rows = $("#minerList").find(".k-grid-content tr").get();
        ExcelUtility.exportToExcel(header, rows);
    }
    exportToCsv() {
        event.preventDefault();
        const header = $("#minerList").find(".k-grid-header th").get();
        const rows = $("#minerList").find(".k-grid-content tr").get();
        ExcelUtility.exportToCSV(header, rows);
    }
}

var POOL_REPORT;
(function (POOL_REPORT) {
    POOL_REPORT[POOL_REPORT["REPORTED_POOLS"] = 1] = "REPORTED_POOLS";
    POOL_REPORT[POOL_REPORT["POOL_CONFIGS"] = 2] = "POOL_CONFIGS";
    POOL_REPORT[POOL_REPORT["EXCEPTIONS"] = 3] = "EXCEPTIONS";
    POOL_REPORT[POOL_REPORT["UNAPPROVED"] = 4] = "UNAPPROVED";
    POOL_REPORT[POOL_REPORT["ACCOUNTS"] = 5] = "ACCOUNTS";
})(POOL_REPORT || (POOL_REPORT = {}));
class MiningPoolsReport extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: true, elemId: "ddlSites" });
        this.minerPoolUrl = "/MinerPools";
        this.selectedReport = POOL_REPORT.REPORTED_POOLS;
        this.bootstrapReportDropDown();
        this.renderChart(true);
        this.onCompanyFilterChanged = this.handleCompanyChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
    }
    bootstrapReportDropDown() {
        const reports = [{
                name: "Active Pools",
                id: POOL_REPORT.REPORTED_POOLS
            }, {
                name: "Pool Configurations",
                id: POOL_REPORT.POOL_CONFIGS
            }, {
                name: "Pool Accounts",
                id: POOL_REPORT.ACCOUNTS
            }, {
                name: "Unapproved Pools",
                id: POOL_REPORT.UNAPPROVED
            }
        ];
        $("#ddlReportPicker").kendoDropDownList({
            dataTextField: "name",
            dataValueField: "id",
            dataSource: reports,
            height: 200,
            autoWidth: true,
            change: (e) => {
                this.selectedReport = parseInt(e.sender.value());
                this.renderChart();
                this.loadReport();
            }
        });
    }
    renderChart(init = false) {
        var cols = [
            { command: { text: "View Stats", click: this.showDetails.bind(this) }, title: " ", width: "120px" },
            { field: "model", title: "Model", filterable: { multi: true }, width: "165px" },
            { field: "ipAddress", title: "IP Address", filterable: { extra: false, search: true }, width: "145px" },
            { field: "siteName", title: "Site", filterable: { multi: true }, width: "145px" },
            { field: "pool", title: "Pool", filterable: { multi: true }, width: "185px" },
            { field: "worker", title: "Worker", filterable: { extra: false, search: true }, width: "125px" }
        ];
        switch (this.selectedReport) {
            // already set above
            case POOL_REPORT.REPORTED_POOLS:
                break;
            case POOL_REPORT.POOL_CONFIGS:
                cols = [
                    { command: { text: "View Stats", click: this.showDetails.bind(this) }, title: " ", width: "120px" },
                    { field: "model", title: "Model", filterable: { multi: true }, width: "165px" },
                    { field: "ipAddress", title: "IP Address", filterable: { extra: false, search: true }, width: "145px" },
                    { field: "siteName", title: "Site", filterable: { multi: true }, width: "145px" },
                    { field: "pool1", title: "Pool 1", filterable: { multi: true }, width: "185px" },
                    { field: "worker1", title: "Worker 1", filterable: { extra: false, search: true }, width: "125px" },
                    { field: "pool2", title: "Pool 2", filterable: { multi: true }, width: "185px" },
                    { field: "worker2", title: "Worker 2", filterable: { extra: false, search: true }, width: "125px" },
                    { field: "pool3", title: "Pool 3", filterable: { multi: true }, width: "185px" },
                    { field: "worker3", title: "Worker 3", filterable: { extra: false, search: true }, width: "125px" }
                ];
                break;
            case POOL_REPORT.ACCOUNTS:
                cols = [
                    { field: "pool", title: "Pool", filterable: { multi: true }, width: "185px" },
                    { field: "account", title: "Account", filterable: { multi: true }, width: "120px" },
                    { field: "poolIndex", title: "Index", filterable: { multi: true }, width: "100px" },
                    { field: "minerCount", title: "Miner Count", filterable: { multi: false }, width: "165px" },
                ];
                break;
            case POOL_REPORT.UNAPPROVED:
                cols = [
                    { command: { text: "View Stats", click: this.showDetails.bind(this) }, title: " ", width: "120px" },
                    { field: "model", title: "Model", filterable: { multi: true }, width: "165px" },
                    { field: "ipAddress", title: "IP Address", filterable: { extra: false, search: true }, width: "145px" },
                    { field: "siteName", title: "Site", filterable: { multi: true }, width: "145px" },
                    { field: "poolIndex", title: "Index", filterable: { multi: true }, width: "85px" },
                    { field: "pool", title: "Reported Pool", filterable: { multi: true }, width: "185px" },
                    { field: "wallet", title: "Account", filterable: { extra: false, search: true }, width: "125px" }
                ];
                break;
        }
        if (init) {
            this.initGrid(cols);
            this.initPieCharts();
        }
        else {
            this.updateGrid(cols);
        }
    }
    initGrid(columns) {
        $("#poolList").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20
            },
            pageable: {
                numeric: false,
                previousNext: false,
            },
            excel: {
                allPages: true
            },
            scrollable: {
                virtual: true
            },
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            columns: columns,
        });
    }
    initPieCharts() {
        const options = {
            series: [],
            chart: {
                width: 650,
                height: 250,
                type: 'donut',
            },
            labels: [],
            plotOptions: {
                pie: {
                    donut: {
                        labels: {
                            show: true,
                            color: "var(--color-text-default)",
                            total: {
                                show: true
                            }
                        }
                    }
                }
            },
            responsive: [{
                    breakpoint: 480,
                    options: {
                        chart: {
                            width: 200
                        },
                        legend: {
                            show: false
                        }
                    }
                }],
            legend: {
                position: 'right',
                offsetY: 0,
            }
        };
        const poolDistributionPie = new self.ApexCharts(document.querySelector("#poolDistributionPie"), options);
        poolDistributionPie.render();
        this.poolDistributionPie = poolDistributionPie;
    }
    updateGrid(columns) {
        $("#poolList").data("kendoGrid").setOptions({ columns });
    }
    loadReport() {
        return __awaiter(this, void 0, void 0, function* () {
            this.toggleBusy(true);
            this.get(`${this.minerPoolUrl}?report=${this.selectedReport}&siteId=${yield this.siteCache.getSiteId()}`)
                .then((resp) => {
                this.populateMinerPoolList(resp);
                this.buildPoolDistributionPie(resp);
                this.toggleBusy(false);
            });
        });
    }
    showDetails(e) {
        e.preventDefault();
        const grid = $("#poolList").data("kendoGrid");
        const row = $(e.currentTarget).closest("tr");
        const dataItem = grid.dataItem(row);
        if (window.location.href.indexOf("OptiFleet.Portal") > -1) {
            window.open(`/OptiFleet.Portal/Content/Miners/IndividualMiner.aspx?id=${dataItem.get("id")}`, "_blank");
            return;
        }
        window.open(`/Content/Miners/IndividualMiner.aspx?id=${dataItem.get("id")}`, "_blank");
    }
    handleCompanyChanged() {
        this.siteCache.loadSites();
        if (this.getSelectedCompanyId() === -1) {
            this.toggleSelectCompany(true);
            return;
        }
        this.toggleSelectCompany(false);
    }
    handleSiteFilterChanged(siteId) {
        this.loadReport();
    }
    populateMinerPoolList(response) {
        const grid = $("#poolList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: response.miners,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
        this.miners = response.miners;
    }
    buildPoolDistributionPie(resp) {
        if (this.selectedReport !== POOL_REPORT.REPORTED_POOLS) {
            return;
        }
        this._buildPoolDistributionPie(resp, "pool");
    }
    _buildPoolDistributionPie(resp, labelField) {
        const poolUsagePercentages = [];
        const distinctPools = resp.miners.map(item => item[labelField] || "null")
            .filter((value, index, self) => self.indexOf(value) === index);
        const totalMiners = resp.miners.length;
        distinctPools.forEach((pool) => {
            const minersUsingPool = resp.miners.filter((miner) => {
                return (miner[labelField] || "null") === pool;
            }).length;
            poolUsagePercentages.push({
                pool: pool,
                usage: minersUsingPool,
                total: totalMiners
            });
        });
        this.populatePoolDistributionPie(poolUsagePercentages);
    }
    populatePoolDistributionPie(poolUsagePercentages) {
        const options = {
            series: poolUsagePercentages.map((val) => val.usage),
            labels: poolUsagePercentages.map((val) => val.pool)
        };
        this.poolDistributionPie.updateOptions(options);
    }
    export() {
        $("#poolList")
            .data("kendoGrid")
            .saveAsExcel();
    }
}

class PowerUsageReport extends OptiFleetPage {
    constructor() {
        super();
        this.powerUsageUrl = "/PowerUsageReport";
        this.init();
    }
    init() {
        this.initMonthPicker();
        this.initGrid();
    }
    initMonthPicker() {
        $("#rdpStart").kendoDatePicker({
            depth: "month",
            format: "MM/dd/yyyy",
            value: new Date()
        });
        $("#rdpEnd").kendoDatePicker({
            depth: "month",
            format: "MM/dd/yyyy",
            value: new Date()
        });
    }
    initGrid() {
        $("#reportList").kendoGrid({
            pageable: false,
            scrollable: true,
            height: "100%",
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: false,
            columns: [
                { field: "usageDate", title: "Date", width: "105px", template: '#= usageDate ? kendo.toString(new Date(usageDate) ,"MM/dd/yyyy") : "" #' },
                { field: "facility", title: "Facility", filterable: { extra: false, search: true }, width: "105px" },
                { field: "hashrateFormatted", title: "Consumed Hash Rate", width: "105px" },
                { field: "consumptionKw", title: "Derived Consumption (kw)", width: "105px", format: "{0:n0}" }
            ]
        });
    }
    runReport() {
        this.loadUsage();
    }
    loadUsage() {
        const rdpStart = $("#rdpStart").data("kendoDatePicker");
        const startDate = rdpStart.value();
        const rdpEnd = $("#rdpEnd").data("kendoDatePicker");
        const endDate = rdpEnd.value();
        if (!startDate || !endDate || startDate > endDate) {
            return;
        }
        this.toggleBusy(true);
        this.get(`${this.powerUsageUrl}?start=${startDate.toISOString()}&end=${endDate.toISOString()}`)
            .then((resp) => {
            this.populateMinerList(resp.powerUsages);
        });
    }
    populateMinerList(powerUsage) {
        const grid = $("#reportList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: powerUsage
        });
        grid.setDataSource(dataSource);
        this.toggleBusy(false);
    }
    exportToExcel() {
        event.preventDefault();
        const header = $("#reportList").find(".k-grid-header th").get();
        const rows = $("#reportList").find(".k-grid-content tr").get();
        ExcelUtility.exportToExcel(header, rows);
    }
    exportToCsv() {
        event.preventDefault();
        const header = $("#reportList").find(".k-grid-header th").get();
        const rows = $("#reportList").find(".k-grid-content tr").get();
        ExcelUtility.exportToCSV(header, rows);
    }
}

class ProjectedBTC extends OptiFleetPage {
    constructor() {
        super();
        this.projectedBTCURL = "/ProjectedBTC";
        this.exportFilename = "ProjectedBTC";
        [this.dpSelectedMonth, this.gridBTCExport] = this.init();
        $("#btnRunReport").click(this.runReport.bind(this));
        $("#btnExport").click(this.toggleDropdownMenu("projectedBTCExportDropdown"));
        $("#csvExport").click(this.exportToCsv.bind(this));
        $("#xlsExport").click(this.exportToExcel.bind(this));
    }
    init() {
        const dpSelectedMonth = $("#selectedMonth").kendoDatePicker({
            depth: "year",
            format: "MMMM",
            start: "year",
            value: new Date(),
            max: new Date(),
        }).data("kendoDatePicker");
        const gridBTCExport = $("#projectedBTCExportList").kendoGrid({
            dataSource: {
                data: []
            },
            pageable: false,
            scrollable: true,
            height: "500px",
            filterable: false,
            groupable: false,
            sortable: true,
            resizable: true,
            noRecords: {
                template: "Select a month to load the report....."
            },
            columns: [
                {
                    field: "date", title: "Day", width: "13%",
                    template: '#= window.moment.utc(date*1000).format("MMMM DD, YYYY") #',
                },
                {
                    field: "value", title: "Estimated BTC", width: "87%",
                    template: '#= value.substring(0,7) #',
                },
            ]
        }).data("kendoGrid");
        return [dpSelectedMonth, gridBTCExport];
    }
    setGridBusy(busy) {
        if (busy) {
            $(".grid-busy").removeClass("hide");
            $("#projectedBTCExportList .k-grid-norecords").addClass("hide");
            $("#projectedBTCExportList").addClass("blurry");
        }
        else {
            $(".grid-busy").addClass("hide");
            $("#projectedBTCExportList .k-grid-norecords").removeClass("hide");
            $("#projectedBTCExportList").removeClass("blurry");
        }
    }
    loadProjectedBTC() {
        const value = this.dpSelectedMonth.value();
        this.setGridBusy(true);
        $("#btnExport").prop("disabled", true);
        this.get(this.projectedBTCURL + `?month=${value.toISOString()}`)
            .then((resp) => {
            this.setGridBusy(false);
            if (!resp.success) {
                return;
            }
            $("#btnExport").prop("disabled", false);
            const dataSource = new kendo.data.DataSource({
                data: resp.results
            });
            this.gridBTCExport.setDataSource(dataSource);
        });
    }
    runReport() {
        try {
            this.loadProjectedBTC();
        }
        catch (_a) {
            return false;
        }
        return false;
    }
    exportToExcel() {
        event.preventDefault();
        const header = $("#projectedBTCExportList").find(".k-grid-header th").get();
        const rows = $("#projectedBTCExportList").find(".k-grid-content tr").get();
        ExcelUtility.exportToExcel(header, rows, this.exportFilename);
    }
    exportToCsv() {
        event.preventDefault();
        const header = $("#projectedBTCExportList").find(".k-grid-header th").get();
        const rows = $("#projectedBTCExportList").find(".k-grid-content tr").get();
        ExcelUtility.exportToCSV(header, rows, this.exportFilename);
    }
}

class SensorPushReport extends OptiFleetPage {
    constructor() {
        super();
        this.sensorPushUrl = "/SensorPush";
        this.init();
    }
    init() {
        this.toggleBusy(true);
        $("#sensorList").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20
            },
            scrollable: {
                virtual: true
            },
            height: "100%",
            filterable: false,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            save: this.onSave.bind(this),
            toolbar: [
                { name: "create", text: "Add New" },
            ],
            columns: [
                {
                    command: [
                        { name: "edit", template: "<a class='op-grid-button k-grid-edit' title='Edit'><i class='icon-pencil'>edit</i></a>" },
                    ], title: "", width: "120px"
                },
                { field: "sensorName", title: "Sensor Name", filterable: { extra: false, search: true }, width: "250px" },
                { field: "facility", title: "Facility", filterable: { extra: false, search: true }, width: "200px" },
                { field: "", title: "", template: this.getDeleteTemplate.bind(this) }
            ]
        });
        this.loadSensors();
    }
    getDeleteTemplate(sensor) {
        return `<button type="button" onclick="e.confirmDelete(${sensor.sensorPushId})" class="m-button is-secondary">delete</button>`;
    }
    confirmDelete(sensorPushId) {
        const sensor = this.sensors.filter((s) => s.sensorPushId == sensorPushId)[0];
        const msg = `Are you sure you want to delete sensor ${sensor.sensorName}?`;
        kendo.confirm(msg)
            .done(() => {
            this.toggleBusy(true);
            this.deleteSensor(sensor)
                .then(() => {
                this.loadSensors();
            });
        })
            .fail(() => {
            //noop
        });
    }
    deleteSensor(sensor) {
        return this.delete(this.sensorPushUrl, { sensorPushId: sensor.sensorPushId, sensorName: sensor.sensorName });
    }
    loadSensors() {
        this.get(this.sensorPushUrl)
            .then((resp) => {
            this.sensors = resp.sensors;
            this.populateEgauges(resp.sensors);
            this.toggleBusy(false);
        });
    }
    populateEgauges(sensors) {
        const grid = $("#sensorList").data("kendoGrid");
        const dataSource = new self.kendo.data.HierarchicalDataSource({
            data: sensors,
            pageSize: 20,
            schema: {
                model: {
                    id: "sensorPushId",
                    fields: {
                        sensorPushId: { editable: false, nullable: true },
                        sensorName: { validation: { required: true } },
                        facility: { validation: { required: true } }
                    }
                }
            }
        });
        grid.setDataSource(dataSource);
    }
    onSave(e) {
        e.preventDefault();
        const saveData = this.getSensorData(e.model);
        this.post(this.sensorPushUrl, { sensor: saveData })
            .then((resp) => {
            if (!resp.success) {
                this.toggleBusy(false);
                this.showErrorMessage("Something went wrong while saving the egauge record.");
                return;
            }
            this.showSuccessMessage("Saved!");
            this.loadSensors();
        });
    }
    getSensorData(model) {
        return {
            sensorPushId: model.sensorPushId,
            facility: model.facility,
            sensorName: model.sensorName
        };
    }
    exportToExcel() {
        event.preventDefault();
        const headers = $("#sensorList").find(".k-grid-header th").get();
        headers.shift();
        headers.pop();
        let rows = [];
        this.sensors.forEach((sensor) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart < headers.length + 1; cellStart++) {
                newRow.append(this.getMinerPropertyAsCell(sensor, cellStart));
            }
            rows.push(newRow);
        });
        ExcelUtility.exportToExcel(headers, rows, "SensorPush");
    }
    exportToCsv() {
        event.preventDefault();
        const headers = $("#sensorList").find(".k-grid-header th").get();
        headers.shift();
        headers.pop();
        let rows = [];
        this.sensors.forEach((sensor) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart < headers.length + 1; cellStart++) {
                newRow.append(this.getMinerPropertyAsCell(sensor, cellStart));
            }
            rows.push(newRow);
        });
        ExcelUtility.exportToCSV(headers, rows, "SensorPush");
    }
    getMinerPropertyAsCell(egauge, index) {
        let prop = "";
        switch (index) {
            case 1:
                prop = egauge.sensorName;
                break;
            case 2:
                prop = egauge.facility;
                break;
        }
        const cell = document.createElement("td");
        cell.innerText = prop;
        return cell;
    }
}

class TicketRotationReport extends OptiFleetPage {
    constructor() {
        super();
        this.ticketRotationUrl = "/TicketRotation";
        this.init();
    }
    init() {
        this.toggleBusy(true);
        $("#ticketRotationList").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20
            },
            scrollable: {
                virtual: true
            },
            height: "100%",
            filterable: false,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            save: this.onSave.bind(this),
            toolbar: [
                { name: "create", text: "Add New" },
            ],
            columns: [
                {
                    command: [
                        { name: "edit", template: "<a class='op-grid-button k-grid-edit' title='Edit'><i class='icon-pencil'>edit</i></a>" },
                    ], title: "", width: "120px"
                },
                { field: "facility", title: "Facility", filterable: { extra: false, search: true }, width: "150px" },
                { field: "userName", title: "User", filterable: { extra: false, search: true }, width: "350px" },
                { field: "enabled", title: "Enabled", template: this.getEnabledTemplate.bind(this), width: "200px" },
                { field: "", title: "", template: this.getDeleteTemplate.bind(this) }
            ]
        });
        this.loadTicketRotation();
    }
    getEnabledTemplate(ticketRotation) {
        return ticketRotation.enabled ? "Yes" : "No";
    }
    getDeleteTemplate(ticketRotation) {
        return `<button type="button" onclick="e.confirmDelete(${ticketRotation.ticketRotationId})" class="m-button is-secondary">delete</button>`;
    }
    confirmDelete(ticketRotationId) {
        const ticketRotation = this.ticketRotations.filter((tr) => tr.ticketRotationId == ticketRotationId)[0];
        const msg = `Are you sure you want to delete ticket roation for ${ticketRotation.userName}?`;
        kendo.confirm(msg)
            .done(() => {
            this.toggleBusy(true);
            this.deleteTicketRotation(ticketRotation.ticketRotationId)
                .then(() => {
                this.loadTicketRotation();
            });
        })
            .fail(() => {
            //noop
        });
    }
    deleteTicketRotation(ticketRotationId) {
        return this.delete(this.ticketRotationUrl, { ticketRotationId: ticketRotationId });
    }
    loadTicketRotation() {
        this.get(this.ticketRotationUrl)
            .then((resp) => {
            this.ticketRotations = resp.ticketRotations;
            this.populateEgauges(resp.ticketRotations);
            this.toggleBusy(false);
        });
    }
    populateEgauges(ticketRotations) {
        const grid = $("#ticketRotationList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: ticketRotations,
            pageSize: 20,
            schema: {
                model: {
                    id: "ticketRotationId",
                    fields: {
                        ticketRotationId: { editable: false, nullable: true },
                        facility: { validation: { required: true } },
                        userName: { validation: { required: true } },
                        enabled: { validation: { required: false }, type: "boolean" }
                    }
                }
            }
        });
        grid.setDataSource(dataSource);
    }
    onSave(e) {
        e.preventDefault();
        const saveData = this.getTicketRotationData(e.model);
        this.post(this.ticketRotationUrl, { ticketRotation: saveData })
            .then((resp) => {
            if (!resp.success) {
                this.toggleBusy(false);
                this.showErrorMessage("Something went wrong while saving the egauge record.");
                return;
            }
            this.showSuccessMessage("Saved!");
            this.loadTicketRotation();
        });
    }
    getTicketRotationData(model) {
        return {
            ticketRotationId: model.ticketRotationId,
            facility: model.facility,
            userName: model.userName,
            enabled: model.enabled
        };
    }
    exportToExcel() {
        event.preventDefault();
        const headers = $("#ticketRotationList").find(".k-grid-header th").get();
        headers.shift();
        headers.pop();
        let rows = [];
        this.ticketRotations.forEach((ticketRotation) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart < headers.length + 1; cellStart++) {
                newRow.append(this.getMinerPropertyAsCell(ticketRotation, cellStart));
            }
            rows.push(newRow);
        });
        ExcelUtility.exportToExcel(headers, rows, "TicketRotation");
    }
    exportToCsv() {
        event.preventDefault();
        const headers = $("#ticketRotationList").find(".k-grid-header th").get();
        headers.shift();
        headers.pop();
        let rows = [];
        this.ticketRotations.forEach((ticketRotation) => {
            const newRow = document.createElement("tr");
            for (let cellStart = 1; cellStart < headers.length + 1; cellStart++) {
                newRow.append(this.getMinerPropertyAsCell(ticketRotation, cellStart));
            }
            rows.push(newRow);
        });
        ExcelUtility.exportToCSV(headers, rows, "TicketRotation");
    }
    getMinerPropertyAsCell(ticketRotation, index) {
        let prop = "";
        switch (index) {
            case 1:
                prop = ticketRotation.facility;
                break;
            case 2:
                prop = ticketRotation.userName;
                break;
            case 3:
                prop = ticketRotation.enabled ? "Yes" : "No";
                break;
        }
        const cell = document.createElement("td");
        cell.innerText = prop;
        return cell;
    }
}

class UsageReport extends OptiFleetPage {
    constructor() {
        super();
        this.usageUrl = "/GetUsageReport";
        this.usageDetailUrl = "/GetUsageDetails";
        this.init();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
    }
    init() {
        $("#rdpMonthPicker").kendoDatePicker({
            start: "year",
            depth: "year",
            format: "MMMM yyyy",
            max: new Date(),
            value: new Date(),
            change: () => { this.loadUsage(); }
        });
        $("#hashrateList").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20
            },
            scrollable: {
                virtual: true
            },
            height: "100%",
            noRecords: {
                template: "<div class=\"no-records\">No data is available for the selected month.</div>"
            },
            filterable: false,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            columns: this.getColumns(true)
        });
        $("#hashrateDetailsList").kendoGrid({
            dataSource: {
                data: [],
                pageSize: 20
            },
            pageable: {
                numeric: true,
                previousNext: true,
            },
            scrollable: true,
            height: "100%",
            filterable: true,
            groupable: false,
            sortable: true,
            resizable: true,
            editable: "inline",
            columns: [
                { command: { text: "View Stats", click: this.viewStats.bind(this) }, title: " ", width: "150px" },
                { field: "name", title: "Name" },
                { field: "ip", title: "IP Address" },
                { field: "hashrate", title: "Hash Rate" }
            ],
            detailInit: this.detailInit.bind(this)
        });
    }
    handleCompanyFilterChanged() {
        if (this.getSelectedCompanyId() <= 0) {
            this.toggleSelectCompany(true);
            return;
        }
        this.toggleSelectCompany(false);
        this.loadUsage();
    }
    loadUsage() {
        this.toggleBusy(true);
        const datepicker = $("#rdpMonthPicker").data("kendoDatePicker");
        const value = datepicker.value();
        this.get(this.usageUrl + `?month=${value.toISOString()}`)
            .then((resp) => {
            this.populateHistoryList(resp.hashrateByModel);
            this.toggleBusy(false);
        });
    }
    detailInit(e) {
        $("<div/>").appendTo(e.detailCell).kendoGrid({
            dataSource: e.data.hourlyUsage,
            pageable: false,
            scrollable: true,
            sortable: true,
            height: "400px",
            columns: [
                { field: "hourDateTime", title: "Usage Date" },
                { field: "hashrate", title: "Hash Rate" }
            ]
        });
    }
    viewStats(e) {
        e.preventDefault();
        const grid = $("#hashrateDetailsList").data("kendoGrid");
        const row = $(e.currentTarget).closest("tr");
        const dataItem = grid.dataItem(row);
        window.open(`/Content/Miners/IndividualMiner.aspx?id=${dataItem.get("id")}`, "_blank");
    }
    getColumns(enableLock) {
        let days = 0;
        let startDay = window.moment();
        const datepicker = $("#rdpMonthPicker").data("kendoDatePicker");
        const value = datepicker.value();
        if (value.getMonth() !== new Date().getMonth()) {
            days = this.getDaysInMonth(value.getMonth(), value.getFullYear());
            startDay = window.moment(value).add(new Date().getDate() * -1, "days").add(days, "days");
        }
        else {
            days = new Date().getDate();
            startDay = window.moment();
        }
        let columns = [];
        columns.push({
            field: `day0`, title: `${startDay.format("YYYY-MM-DD")}`, width: 110,
            template: `<span class='hashrate-link' onclick='ur.showDetails(this)'>#=(typeof(day0) !== 'undefined') ? day0 : '' #</span>`,
        });
        for (var i = 1; i < days; i++) {
            const day = startDay.add(-1, "days");
            columns.push({
                field: `day${i}`, title: `${day.format("YYYY-MM-DD")}`, width: 110,
                template: `<span class='hashrate-link' onclick='ur.showDetails(this)'>#=(typeof(day${i}) !== 'undefined') ? day${i} : '' #</span>`,
            });
        }
        columns.reverse();
        columns.push({ field: "name", title: "Model", width: 200, locked: enableLock });
        return columns.reverse();
    }
    getDaysInMonth(month, year) {
        return new Date(year, month + 1, 0).getDate();
    }
    populateHistoryList(hashrateByModel) {
        const grid = $("#hashrateList").data("kendoGrid");
        const dataSource = new self.kendo.data.HierarchicalDataSource({
            data: hashrateByModel,
            pageSize: 20
        });
        grid.setOptions({
            columns: this.getColumns(true)
        });
        grid.setDataSource(dataSource);
    }
    dismissDetails() {
        $(".hashrate-details").removeClass("slide-up");
    }
    showDetails(cellTemplate) {
        const cell = cellTemplate.parentElement;
        const row = cell.parentElement;
        const grid = $("#hashrateList").data("kendoGrid");
        const dataItem = grid.dataItem(row);
        const model = dataItem.get("name");
        const column = grid.columns[cell.cellIndex + 1];
        $(".hashrate-detail-title").text(`${column.title} - ${model}`);
        this.loadUsageDetails(model, column.title);
    }
    loadUsageDetails(model, day) {
        this.toggleBusy(true);
        $(".hashrate-details").addClass("slide-up");
        this.post(this.usageDetailUrl, { model: model, usageDate: day })
            .then((resp) => {
            this.populateDetailList(resp.usageDetails);
            this.toggleBusy(false);
        });
    }
    populateDetailList(lineItems) {
        const grid = $("#hashrateDetailsList").data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: lineItems,
            pageSize: 20
        });
        grid.setDataSource(dataSource);
    }
    exportToExcel() {
        event.preventDefault();
        this.unlockModelColumn();
        const header = $("#hashrateList").find(".k-grid-header th").get();
        const rows = $("#hashrateList").find(".k-grid-content tr").get();
        ExcelUtility.exportToExcel(header, rows, "HashRates");
        this.lockModelColumn();
    }
    exportToCsv() {
        event.preventDefault();
        this.unlockModelColumn();
        const header = $("#hashrateList").find(".k-grid-header th").get();
        const rows = $("#hashrateList").find(".k-grid-content tr").get();
        ExcelUtility.exportToCSV(header, rows, "HashRates");
        this.lockModelColumn();
    }
    unlockModelColumn() {
        const grid = $("#hashrateList").data("kendoGrid");
        grid.setOptions({
            columns: this.getColumns(false)
        });
    }
    lockModelColumn() {
        const grid = $("#hashrateList").data("kendoGrid");
        grid.setOptions({
            columns: this.getColumns(true)
        });
    }
}

class UserProfile extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.notificationURL = "/NotificationContacts";
        this.securityQuestionUrl = "/SecurityQuestions";
        $(`#${self.controls.securityAnswer}`).attr("type", "password");
        this.loadSecurityQuestions();
        const phoneNumberInput = $(`#${self.controls.phone}`);
        phoneNumberInput.kendoMaskedTextBox({
            mask: "(000) 000-0000",
            unmaskOnPost: true
        });
    }
    loadSecurityQuestions() {
        this.get(this.securityQuestionUrl)
            .then((resp) => {
            this.populateQuestionDropDown(resp.questions);
        });
    }
    populateQuestionDropDown(questions) {
        this.securityQuestionId = $(`#${self.controls.securityQuestion}`).val();
        $("#ddlSecurityQuestions").kendoDropDownList({
            dataTextField: "question",
            dataValueField: "id",
            dataSource: questions,
            height: 100,
            autoWidth: true,
            value: this.securityQuestionId.toString(),
        });
    }
    toggleSecurityQuestionVisibility() {
        const type = $(`#${self.controls.securityAnswer}`).attr("type");
        const eyeIcon = $("#eye-icon");
        if (type === "text") {
            eyeIcon.attr("name", "eye");
            $(`#${self.controls.securityAnswer}`).attr("type", "password");
            return;
        }
        eyeIcon.attr("name", "eye-off");
        $(`#${self.controls.securityAnswer}`).attr("type", "text");
    }
    changePassword() {
        $(".change-link").removeClass("active");
        $(".change-password-inputs").addClass("active");
    }
    cancelChangePw() {
        $(".change-link").addClass("active");
        $(".change-password-inputs").removeClass("active");
    }
    submitPasswordChange() {
        this.clearValidation();
        if (!this.isValidPassword()) {
            return;
        }
        this.toggleBusy(true);
        const password = $(`#${self.controls.password}`).val();
        this.post("/ChangePassword", {
            password: btoa(password)
        }).then((resp) => {
            this.toggleBusy(false);
            if (!resp.success) ;
            $(`#${self.controls.lastPwChangeDate}`).text(window.moment().format("MM/DD/YYYY hh:mm A"));
            this.cancelChangePw();
        });
    }
    clearValidation() {
        $(".passwords-dont-match").addClass("hide");
        $(".password-too-short").addClass("hide");
    }
    isValidPassword() {
        const password = $(`#${self.controls.password}`).val();
        const confirmPass = $(`#${self.controls.confirmPass}`).val();
        if (password !== confirmPass) {
            $(".passwords-dont-match").removeClass("hide");
            return false;
        }
        const symbols = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]+/;
        const hasSymbols = symbols.test(password);
        const hasNumbers = password.match(/^[^0-9]+$/) ? false : true;
        const hasChars = password.match(/^[^a-zA-Z]+$/) ? false : true;
        if (password.length < 8 || !hasSymbols || !hasNumbers || !hasChars) {
            $(".password-too-short").removeClass("hide");
            return;
        }
        return true;
    }
    saveProfile() {
        const firstName = $(`#${self.controls.fName}`).val();
        const lastName = $(`#${self.controls.lName}`).val();
        const questions = $("#ddlSecurityQuestions").data("kendoDropDownList");
        const questionId = questions.value();
        const answer = $(`#${self.controls.securityAnswer}`).val();
        const phone = $(`#${self.controls.phone}`).val().replace(/\D/g, '');
        const telegram = $(`#${self.controls.telegram}`).val();
        if (!this.isValid()) {
            return;
        }
        this.toggleBusy(true);
        this.post("/UpdateProfile", {
            firstName: firstName,
            lastName: lastName,
            questionId: questionId,
            answer: answer,
            phone: phone,
            telegram: telegram
        }).then((resp) => {
            this.toggleBusy(false);
            if (!resp.success) ;
            $(`#${self.controls.securityAnswer}`).attr("type", "password");
            this.showSuccess();
        });
    }
    showSuccess() {
        $(".save-success").removeClass("hide");
        setTimeout(() => {
            $(".save-success").addClass("hide");
        }, 4000);
    }
    isValid() {
        $(".invalid-answer").addClass("hide");
        $(".invalid-phone").addClass("hide");
        let isValid = true;
        const answer = $(`#${self.controls.securityAnswer}`).val();
        if (answer.length === 0) {
            $(".invalid-answer").removeClass("hide");
            isValid = false;
        }
        const phoneNumberInput = $(`#${self.controls.phone}`);
        const phoneNumber = phoneNumberInput.val().replace(/[-\s()]/g, '').trim();
        if (!/^([1-9][0-9]{9,14})?$/.test(phoneNumber)) {
            $(".invalid-phone").removeClass("hide");
            isValid = false;
        }
        return isValid;
    }
}

class MinerAdminSearchFields {
    constructor() {
        this.Fields = [
            {
                field: "minerName",
                title: "Miner Name",
                searchType: "Contains",
                value: null
            }, {
                field: "modelName",
                title: "Model",
                searchType: "Contains",
                value: null
            }, {
                field: "serialNumber",
                title: "Serial Number",
                searchType: "Contains",
                value: null
            }, {
                field: "siteAgentName",
                title: "Site Agent",
                searchType: "Contains",
                value: null
            }, {
                field: "locationName",
                title: "Location ID",
                searchType: "Contains",
                value: null
            }, {
                field: "ipAddress",
                title: "IP Address",
                searchType: "Contains",
                value: null
            }, {
                field: "pool",
                title: "Pool",
                searchType: "Contains",
                value: null
            }, {
                field: "account",
                title: "Account",
                searchType: "Contains",
                value: null
            }, {
                field: "worker",
                title: "Worker",
                searchType: "Contains",
                value: null
            }
        ];
        //noop
    }
}
MinerAdminSearchFields.SearchOptions = [
    "Contains", "Is", "Is Not", "Is Empty", "Is Not Empty"
];
MinerAdminSearchFields.SEARCH_ITEM = `
            <div class="m-menu">
                <div class="search-inputs" id="{{field}}SearchInputWrapper">
                    <div class="search-filter">
                        <input id="ddl{{field}}Options" />
                    </div>
                    <div class="search-values" id="{{field}}searchValues">
                        <div class="multi-search-input op-input" id="rms{{field}}Values" data-values="">
                            <div class="list-search-input-wrapper" id="rms{{field}}InputWrapper">
                                <input id="rms{{field}}SearchInput" class="search-input"
                                    onkeyup="ma.searchPanel.search(this, '{{field}}')"
                                    oninput="this.size = this.value.length" />
                            </div>
                        </div>
                        <div id="rms{{field}}Result" class="multi-search-result">
                            <div id="rms{{field}}ResultItem" class="multi-search-input" onclick="ma.searchPanel.select(this, '{{field}}')"></div>
                        </div>
                    </div>
                </div>
            </div>
        `;
MinerAdminSearchFields.SEARCH_ITEM_WITH_DATASOURCE = `
            <div class="m-menu">
                <div class="search-inputs" id="{{field}}SearchInputWrapper">
                    <div class="search-filter">
                        <input id="ddl{{field}}Options" />
                    </div>
                    <div class="search-values">
                        <input id="ms{{field}}" />
                    </div>
                </div>
            </div>
        `;
MinerAdminSearchFields.SEARCH_PANEL_ITEM = `
            <div class="m-menu-item">
                <span class="search-property">{{title}}:</span>
                <span class="search-property-value">{{value}}</span>
                <i class="icon-x dismiss-search-item" onclick="ma.searchPanel.removeSearchItem(this, '{{field}}')"></i>
            </div>
        `;
MinerAdminSearchFields.BULK_SEARCH_PANEL_ITEM = `
            <div class="m-menu-item">
                <span class="search-property">Bulk Search:</span>
                <span class="search-property-value">{{value}}</span>
                <i class="icon-x dismiss-search-item" onclick="ma.clearBulkSearch(this)"></i>
            </div>
        `;
MinerAdminSearchFields.NOTES_SEARCH_PANEL_ITEM = `
            <div class="m-menu-item">
                <span class="search-property">Notes Search:</span>
                <span class="search-property-value">{{value}}</span>
                <i class="icon-x dismiss-search-item" onclick="ma.clearNotesSearch(this)"></i>
            </div>
        `;

const tableColumns = {
    "Email": "email",
    "Date Invited": "invited"
};
class PendingUsersPanel extends OptiFleetPage {
    constructor() {
        super();
        this.pendingUrl = "/Users/Pending";
        this.revokeUrl = "/Users/RevokeInvitation";
        this.emailSortOrder = "desc"; // username column
        this.invitedSortOrder = "desc"; // date invited column
        this.selectedUserIds = [];
        this.init();
    }
    init() {
        this.toggleBusy(true);
        this.getInvitations();
        this.revokeInvitesModal = new OpConfirmationModal("RevokeInvitesModal", this.confirmRevokeInvites.bind(this));
        this.toggleBusy(false);
    }
    getInvitations() {
        this.get(this.pendingUrl).then(res => {
            this.pendingUsers = res.users.filter((user, index) => {
                return res.users.findIndex(obj => obj.email === user.email) === index;
            });
            this.renderUserList();
            $("#pendingCount").empty().text(this.pendingUsers.length);
        });
    }
    renderUserList() {
        if (!this.pendingUsers || this.pendingUsers.length === 0) {
            $("#pendingList").empty().append('<div>There are no pending invitations at this time.</div>');
            return;
        }
        const mustache = window.Mustache;
        const templateData = {
            users: this.pendingUsers
        };
        const el = mustache.to_html(UserTemplatesNew.PENDING_LIST, templateData);
        $("#pendingList").empty().append(el);
    }
    handleUserClick(id) {
        const index = this.selectedUserIds.indexOf(id);
        if (index !== -1) {
            this.selectedUserIds.splice(index, 1);
        }
        else {
            this.selectedUserIds.push(id);
        }
        const revokeBtn = $("#revokeBtn");
        if (this.selectedUserIds.length !== 0) {
            revokeBtn.addClass("is-destructive").removeAttr("disabled");
        }
        else {
            revokeBtn.removeClass("is-destructive").attr("disabled", "true");
        }
    }
    promptRevokeInvitesConfirmation() {
        window.event.preventDefault();
        this.revokeInvitesModal.open({ primaryText: "Are you sure you wish to revoke the intitations for the selected user(s)?" });
    }
    sortColumn(col) {
        const [el, title, newOrder] = SortUtil.getColumnSortInfo(col, tableColumns);
        this.pendingUsers = this.pendingUsers.sort(SortUtil.dynamicSort(title, newOrder));
        this.renderUserList();
        $(`#${title}Column`).append(el);
    }
    confirmRevokeInvites() {
        this.patch(this.revokeUrl, { userIds: this.selectedUserIds })
            .then(res => {
            if (!res.success) {
                this.showErrorMessage("Failed to revoke invitations, please try again later");
                return;
            }
            this.getInvitations();
            this.showSuccessMessage("User successfully deleted");
        });
    }
}

class UserTemplatesNew {
}
UserTemplatesNew.USER_DETAILS = `
            <div class="m-stack has-space-l">
                <div>
                    <h4 class="m-heading is-size-2xl">{{fullName}}</h4>
                    <p class="m-text is-tertiary">{{username}}</p>
                </div>
                <div class="m-form-control m-stack has-space-xs">
                    <label class="m-label" for="role">Role: </label>
                    <div class="m-stack has-space-xs">
                        {{#roles}}
                            <div class="m-radio">
                                <input type="radio" id="{{name}}" value="{{name}}" name="role" {{{checked}}} {{{disabled}}} />
                                <label for="{{name}}" class="m-label">{{name}}</label>
                            </div>
                        {{/roles}}
                    </div>
                </div>
                <div class="m-form-control">
                    <label for="team" class="m-label">Team:</label>
                    <div class="m-select team-select">
                        <select name="team" id="teamSelect">
                            <option value=""></option>
                            {{#teams}}
                                    <option value="{{id}}" {{{selected}}} {{{disabled}}}>{{name}}</option>
                            {{/teams}}
                        </select>
                    </div>
                </div>
                <div class="m-form-control m-stack has-space-xs">
                    <label class="m-label" for="companies">Company:</label>
                    {{#companies}}
                        <div class="m-checkbox">
                            <input type="checkbox" name="companies" id="{{name}}" {{{checked}}} {{{disabled}}} company-name="{{name}}"  />
                            <label class="m-label" for="{{name}}">{{name}}</label>
                        </div>
                    {{/companies}}
                </div>

                <div class="m-stack is-horizontal has-space-between">
                        <button type="button" id="saveChangesBtn" class="m-button is-primary" disabled>
                        Save Changes
                    </button>
                    <button type="button" {{{deleteBtnAttrs}}}
                        onclick="u.promptDeleteUserConfirmation();">
                        Delete
                    </button>
                </div>
            </div>
        `;
UserTemplatesNew.USER_LIST = `
            <div>
                <table class="usersListSection m-table is-variant-ghost">
                    <thead class="m-table-header">
                        <tr class="m-table-row">
                            <th class="m-table-cell m-table-column-header-cell" onclick="u.sortColumn(this);">
                                <div class="m-stack is-horizontal">
                                    <span>Name</span>
                                    <span class="column-icon" id="lastNameColumn"></span>
                                </div>
                            </th>
                            <th class="m-table-cell m-table-column-header-cell" onclick="u.sortColumn(this);">
                                <div class="m-stack is-horizontal">
                                    <span>Role</span>
                                    <span class="column-icon" id="roleColumn"></span>
                                </div>
                            </th>
                            <th class="m-table-cell m-table-column-header-cell" id="teamName" onclick="u.sortColumn(this);">
                                <div class="m-stack is-horizontal">
                                    <span>Team</span>
                                    <span class="column-icon" id="teamNameColumn"></span>
                                </div>
                            </th>
                            <th class="m-table-cell m-table-column-header-cell"  id="lastLogin" onclick="u.sortColumn(this);">
                                <div class="m-stack is-horizontal">
                                    <span>Last Login</span>
                                    <span class="column-icon" id="lastLoginColumn"></span>
                                </div>
                            </th>
                        </tr>
                    </thead>
                    <tbody class="m-table-body">
                        {{#users}}
                            <tr user-id="{{id}}" class="user m-table-row" onclick="u.handleUserClick({{id}});">
                                <td class="m-table-cell">{{{textElemUsername}}}</td>
                                <td class="m-table-cell">{{{textElemRole}}}</td>
                                <td class="m-table-cell">{{{textElemTeamName}}}</td>
                                <td class="m-table-cell">{{{textElemLastLogin}}}</td>
                            </tr>
                        {{/users}}
                    </tbody>
                </table>
            </div>
        `;
UserTemplatesNew.PENDING_LIST = `
                <table class="m-table is-variant-ghost" id="pendingUsersList">
                    <thead class="m-table-header">
                        <tr class="m-table-row">
                        <th class="m-table-cell m-table-column-header-cell" id="selectColumn">
                            </th>
                            <th class="m-table-cell m-table-column-header-cell" onclick="u.pendingUsersPanel.sortColumn(this);">
                                <div class="m-stack is-horizontal">
                                    <span>Email</span>
                                    <span class="column-icon" id="emailColumn"></span>
                                </div>
                            </th>
                            <th class="m-table-cell m-table-column-header-cell" onclick="u.pendingUsersPanel.sortColumn(this);">
                                <div class="m-stack is-horizontal">
                                    <span>Date Invited</span>
                                    <span class="column-icon" id="invitedColumn"></span>
                                </div>
                            </th>
                        </tr>
                    </thead>
                    <tbody class="m-table-body">
                        {{#users}}
                            <tr user-id="{{{id}}}" class="user m-table-row">
                                <td class="m-table-cell">
                                    <div class="m-checkbox">
                                        <input type="checkbox" id="{{{id}}}" onclick="u.pendingUsersPanel.handleUserClick({{{id}}});" />
		                                <label class="m-label" for="{{{id}}}"></label>
                                    </div>
                                </td>
                                <td class="m-table-cell">{{{email}}}</td>
                                <td class="m-table-cell">{{{invited}}}</td>
                            </tr>
                        {{/users}}
                    </tbody>
                </table>
        `;
UserTemplatesNew.ADD_USER = `
            <div class="m-stack has-space-l">
                <div>
                    <h4 class="m-heading is-size-2xl">New User</h4>
                </div>
                <div class="m-form-control">
                    <label for="emailInput" class="m-label">Email:</label>
                    <input id="emailInput" class="m-input" data-form-type="other" />
                    <span class="m-help-text is-error" id="invalidEmailAddress" style="display: none;">Invalid email address.</span>
                </div>
                <div class="m-form-control m-stack has-space-xs">
                    <label class="m-label" for="role">Role: </label>
                    {{#roles}}
                        <div class="m-stack is-horizontal">
                            <div class="m-radio">
                                <input type="radio" id="{{name}}" value="{{name}}" name="role" />
                                <label for="role" class="m-label">{{name}}</label>
                            </div>
                        </div>
                    {{/roles}}
                </div>
                <div class="m-form-control m-stack has-space-xs">
                    <label class="m-label" for="companies" required>Company:</label>
                    {{#companies}}
                        <div class="m-checkbox">
                            <input type="checkbox" id="{{name}}" name="companies" company-name="{{name}}" />
                            <label class="m-label" for="{{name}}">{{name}}</label>
                        </div>
                    {{/companies}}

                    <span class="m-help-text is-error" id="invalidCompany" style="display: none;">You must select at least one company.</span>
                </div>

                <div class="m-stack is-horizontal has-space-between">
                    <button type="button" class="m-button is-secondary" onclick="u.closeAddUserPanel();">
                        Cancel
                    </button>
                    <button type="button" id="inviteUserBtn" class="m-button is-primary" disabled>
                        Invite User
                    </button>
                </div>
            </div>
        `;
UserTemplatesNew.ICON_DOWN = `<m-icon name="arrow-down"></m-icon>`;
UserTemplatesNew.ICON_UP = `<m-icon name="arrow-up"></m-icon>`;

class SortUtil {
    // sort an array of objects based on a given property value
    // add - to beginning of property to change sort order
    static dynamicSort(property, order = "asc") {
        const sortOrder = order.toLowerCase() === "asc" ? 1 : -1;
        const prop = property.replace(/^-/, "");
        return (a, b) => {
            const valueA = a[prop];
            const valueB = b[prop];
            if (typeof valueA === "string" && typeof valueB === "string") {
                const dateA = new Date(valueA);
                const dateB = new Date(valueB);
                if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
                    if (dateA < dateB) {
                        return -1 * sortOrder;
                    }
                    if (dateA > dateB) {
                        return 1 * sortOrder;
                    }
                    return 0;
                }
            }
            if (valueA < valueB) {
                return -1 * sortOrder;
            }
            if (valueA > valueB) {
                return 1 * sortOrder;
            }
            return 0;
        };
    }
    static getColumnSortInfo(col, columnHeaders) {
        const mustache = window.Mustache;
        const columnTitle = col.textContent.trim();
        const title = columnHeaders[columnTitle];
        const currentOrder = this[`${title}SortOrder`];
        const newOrder = currentOrder === "desc" ? "asc" : "desc";
        this[`${title}SortOrder`] = newOrder;
        $(".column-icon").empty();
        const template = newOrder === "desc" ? UserTemplatesNew.ICON_DOWN : UserTemplatesNew.ICON_UP;
        const el = mustache.to_html(template);
        return [el, title, newOrder];
    }
    static alphaNumericSort(a, b) {
        const regex = /(\d+(?:\.\d+)?)/g;
        const aNum = typeof a !== "number" ? parseFloat(a.match(regex)[0]) : parseFloat(a);
        const bNum = typeof b !== "number" ? parseFloat(b.match(regex)[0]) : parseFloat(b);
        if (aNum < bNum) {
            return -1;
        }
        else if (aNum > bNum) {
            return 1;
        }
        else {
            return 0;
        }
    }
    // sorts varied units of time (seconds, hours, days)
    static variedTimeSort(a, b) {
        const regex = /(\d+(?:\.\d+)?)\s+(\w+)/;
        const aMatch = a.match(regex);
        const bMatch = b.match(regex);
        if (aMatch && bMatch) {
            const aAmount = parseFloat(aMatch[1]);
            const aUnit = aMatch[2];
            const bAmount = parseFloat(bMatch[1]);
            const bUnit = bMatch[2];
            // Convert units to milliseconds
            const aMilliseconds = this.convertToMilliseconds(aAmount, aUnit);
            const bMilliseconds = this.convertToMilliseconds(bAmount, bUnit);
            if (aMilliseconds < bMilliseconds) {
                return -1;
            }
            else if (aMilliseconds > bMilliseconds) {
                return 1;
            }
            else {
                return 0;
            }
        }
        // If the strings don't match the expected format, return 0
        return 0;
    }
    static convertToMilliseconds(amount, unit) {
        switch (unit.toLowerCase()) {
            case "milliseconds":
                return amount;
            case "seconds":
                return amount * 1000;
            case "minutes":
                return amount * 60 * 1000;
            case "hours":
                return amount * 60 * 60 * 1000;
            case "days":
                return amount * 24 * 60 * 60 * 1000;
            default:
                return 0;
        }
    }
}

class AssetFormView {
    constructor(Id, parentEl) {
        this.Id = Id;
        this.parentEl = parentEl;
        this.assetTypesUrl = "/Assets";
        this.mustache = window.Mustache;
        this.httpService = new OptiFleetService();
        this.initForm();
    }
    title() { return null; }
    // set display to true for view content
    show() { this.form.css("display", "flex"); }
    // set display to none for view content
    hide() { this.form.css("display", "none"); }
    // called on modal init. Should make http GET to initialize for fields
    load(data) {
        if (!data)
            return;
        this.assetId = data.asset.assetId;
        this.data = data;
        this.populateFields();
    }
    confirm(submitCallback) { submitCallback && submitCallback(); }
    // validate form fields
    validate() {
        let success = true;
        // Name Validation
        const nameInput = this.form.find(".name-input").first();
        const nameError = this.form.find(".name-invalid").first();
        if (nameInput.val().length == 0) {
            nameError.show();
            success = false;
        }
        else {
            nameError.hide();
        }
        // City Validation
        //const cityInput = this.form.find(".city-input").first();
        //const cityError = this.form.find(".city-invalid").first();
        //if (cityInput.val().trim().length == 0) {
        //    cityError.show();
        //    success = false;
        //} else {
        //    cityError.hide();
        //}
        //// State Validation
        //const stateInput = this.form.find(".state-input").first();
        //const stateError = this.form.find(".state-invalid").first();
        //if (stateInput.val().trim().length == 0) {
        //    stateError.show();
        //    success = false;
        //} else {
        //    stateError.hide();
        //}
        //// Address Validation
        //const addressInput = this.form.find(".address-input").first();
        //const addressError = this.form.find(".address-invalid").first();
        //if (addressInput.val().trim().length == 0) {
        //    addressError.show();
        //    success = false;
        //} else {
        //    addressError.hide();
        //}
        return success;
    }
    // reset form values if not saved
    reset() {
        this.form.find(".name-input").first().val("");
        this.form.find(".description-input").first().val("");
        this.form.find(".consumable-input").first().prop("checked", false);
    }
    // add key/value pairs to the object passed in
    updateSubmitData(dataObj) {
        const name = this.form.find(".name-input").first().val();
        const manufacturerId = this.manufacturerInput.value();
        const modelId = this.modelInput.value();
        const serialNumber = this.form.find(".serial-number-input").first().val();
        const warrantyDate = this.warrantyDateInput.value();
        const statusId = this.statusInput.value();
        const assetTypeId = this.assetTypeInput.value();
        this.form.find(".city-input").first().val();
        this.form.find(".state-input").first().val();
        this.form.find(".address-input").first().val();
        let asset = {};
        if (this.assetId) {
            asset['assetId'] = this.assetId;
        }
        asset['assetName'] = name;
        asset['manufacturerId'] = Number(manufacturerId);
        asset['manufacturerModelId'] = Number(modelId);
        asset['serialNumber'] = serialNumber;
        asset['warrantyDateUnixSeconds'] = Math.floor(warrantyDate.getTime() / 1000);
        asset['statusId'] = Number(statusId);
        asset['assetTypeId'] = Number(assetTypeId);
        //asset['city'] = city;
        //asset['state'] = state;
        //asset['address'] = address;
        dataObj['assets'] = [asset];
    }
    initForm() {
        const data = {
            elementId: this.Id,
        };
        this.form = $(this.mustache.to_html(FORM_TEMPLATE, data));
        this.parentEl.append(this.form);
        const handleMfrChange = this.handleManufacturerChange.bind(this);
        this.manufacturerInput = this.form.find(".manufacturer-input").first().kendoDropDownList({
            dataTextField: "name",
            dataValueField: "id",
            height: 200,
            autoWidth: true,
            change: handleMfrChange,
        }).data("kendoDropDownList");
        this.modelInput = this.form.find(".model-input").first().kendoDropDownList({
            dataTextField: "name",
            dataValueField: "id",
            height: 200,
            autoWidth: true,
        }).data("kendoDropDownList");
        this.warrantyDateInput = this.form.find(".warranty-date-input").kendoDatePicker({}).data("kendoDatePicker");
        this.statusInput = this.form.find(".status-input").first().kendoDropDownList({
            dataTextField: "status",
            dataValueField: "id",
            height: 200,
            autoWidth: true,
        }).data("kendoDropDownList");
        this.assetTypeInput = this.form.find(".asset-type-input").first().kendoDropDownList({
            dataTextField: "name",
            dataValueField: "id",
            height: 200,
            autoWidth: true,
        }).data("kendoDropDownList");
    }
    // ** UTILS **
    populateFields() {
        const data = this.data;
        this.form.find(".name-input").first().val(data.asset.assetName);
        const { manufacturers, models } = this.separateManufacturersAndModels(data);
        const targetModels = models[manufacturers.findIndex((manufacturer) => manufacturer.id === data.asset.manufacturerId)];
        this.handleManufacturerChange.bind(this);
        this.manufacturerInput.setDataSource(new kendo.data.DataSource({
            data: manufacturers,
        }));
        this.manufacturerInput.value(data.asset.manufacturerId.toString());
        this.modelInput.setDataSource(new kendo.data.DataSource({
            data: targetModels,
        }));
        this.modelInput.value(data.asset.manufacturerModelId.toString());
        this.form.find(".serial-number-input").first().val(data.asset.serialNumber);
        this.warrantyDateInput.value(new Date());
        this.statusInput.setDataSource(new kendo.data.DataSource({
            data: data.statusList,
        }));
        this.statusInput.value(data.asset.statusId.toString());
        this.assetTypeInput.setDataSource(new kendo.data.DataSource({
            data: data.assetTypes,
        }));
        this.assetTypeInput.value(data.asset.assetTypeId.toString());
        //this.form.find(".city-input").first().val(data.asset.city);
        //this.form.find(".state-input").first().val(data.asset.state);
        //this.form.find(".address-input").first().val(data.asset.address);
    }
    handleManufacturerChange(val) {
        const newId = parseInt(val.sender.value());
        const targetManufacturerAndModels = this.data.manufacturerModels.find(x => x.manufacturer.id == newId);
        console.log($(".model-input"));
        const ds = new kendo.data.DataSource({
            data: targetManufacturerAndModels.models,
        });
        this.modelInput.setDataSource(ds);
        this.modelInput.value(targetManufacturerAndModels.models[0].id.toString());
    }
    separateManufacturersAndModels(data) {
        const manufacturers = [];
        const models = [];
        data.manufacturerModels.forEach((manufacturerModel) => {
            manufacturers.push(manufacturerModel.manufacturer);
            models.push(manufacturerModel.models);
        });
        return { manufacturers, models };
    }
}
const FORM_TEMPLATE = `
        <div id="{{elementId}}" class="asset-types-form" style="display: none;">
            <div class="m-stack" style="width: 100%">
                <div class="m-form-control">
                    <p class="m-label">Name</p>
                    <input class="m-input name-input" type="text" maxlength="100" placeholder="e.g Miner"/>
                    <p class="m-help-text is-error error-msg name-invalid" style="display: none;">Asset name required</p>
                </div>
                <div class="m-form-control">
                    <p class="m-label">Asset Type</p>
                    <input class="m-input asset-type-input" />
                </div>
                <div class="m-form-control">
                    <p class="m-label">Manufacturer</p>
                    <input class="m-input manufacturer-input" />
                </div>
                <div class="m-form-control">
                    <p class="m-label">Model</p>
                    <input class="m-input model-input" />
                </div>
                <div class="m-form-control">
                    <p class="m-label">Serial Number</p>
                    <input class="m-input serial-number-input" type="text" maxlength="50" placeholder="e.g FAXDZA31B..."/>
                </div>
                <div class="m-form-control">
                    <p class="m-label">Warranty Expiration Date</p>
                    <input class="m-input warranty-date-input" />
                </div>
                <div class="m-form-control">
                    <p class="m-label">Status</p>
                    <input class="m-input status-input" />
                </div>
                <!--
                <div class="m-form-control">
                    <p class="m-label">State</p>
                    <input class="m-input state-input" type="text" maxlength="100" placeholder="e.g NY "/>
                    <p class="m-help-text is-error error-msg state-invalid" style="display: none;">State required</p>
                </div>
                 <div class="m-form-control">
                    <p class="m-label">City</p>
                    <input class="m-input city-input" type="text" maxlength="100" placeholder="e.g Pittsford"/>
                    <p class="m-help-text is-error error-msg city-invalid" style="display: none;">City required</p>
                </div>
                <div class="m-form-control">
                    <p class="m-label">Street Address</p>
                    <input class="m-input address-input" type="text" maxlength="100" placeholder="e.g 1100 Pittsford Victor Rd"/>
                    <p class="m-help-text is-error error-msg address-invalid" style="display: none;">Address required</p>
                </div>
                -->
            </div>
        </div>
    `;

class DatePicker {
    /**
     * creates a datepicker
     * @param elemId: the html id where the datepicker will be set
     * @param trigger: the function to be called when the datepicker selection is changed, must take DatePickerQueryParams as a parameter
     * @param initParams: (optional) start and end times for the date picker
     * @param stepOverride: (optional) preferred step for data, will override all defaults
     */
    constructor(elemId, trigger, initParams, stepOverride, configOverride) {
        var _a;
        this.elemId = "#reportrange";
        if (stepOverride)
            this.stepOverride = stepOverride;
        if (configOverride)
            this.configOverride = configOverride;
        let startTime;
        let endTime;
        let chosenLabel = "Custom Range";
        if (initParams) {
            startTime = initParams.start;
            endTime = initParams.end;
            chosenLabel = initParams.label ? initParams.label : "Custom Range";
        }
        else {
            try {
                var lastSelection = JSON.parse(localStorage.getItem("LastDatePickerSelection"));
                startTime = lastSelection.chosenLabel ? DatePicker.DEFAULT_CONFIG.ranges[lastSelection.chosenLabel][0] : window.moment(lastSelection.range.start);
                endTime = lastSelection.chosenLabel ? DatePicker.DEFAULT_CONFIG.ranges[lastSelection.chosenLabel][1] : window.moment(lastSelection.range.end);
                chosenLabel = (_a = lastSelection.chosenLabel) !== null && _a !== void 0 ? _a : "Custom Range";
            }
            catch (_b) {
                startTime = window.moment().subtract(15, "minutes");
                endTime = window.moment();
                chosenLabel = "Last 15 minutes";
            }
        }
        const startSecs = this.formatDate(startTime.toDate().getTime());
        const endSecs = this.formatDate(endTime.toDate().getTime());
        this.params = {
            start: startSecs,
            end: endSecs,
            step: this.getStep(startSecs, endSecs)
        };
        this.trigger = trigger;
        const template = self.Mustache.to_html(DatePicker.TEMPLATE);
        $(elemId).append(template);
        const config = this.getConfig();
        $(this.elemId).daterangepicker(Object.assign({ startDate: startTime, endDate: endTime }, config), this.handleSelection.bind(this));
        this.handleSelection(startTime, endTime, chosenLabel);
    }
    /**
     * returns the current parameters
     * @returns
     */
    getParams() {
        return this.params;
    }
    /**
     * returns an updated set of parameters for the current time split
     * call this after checking isAbsoluteRange to refresh a set time range
     * @returns DatePickerQueryParams
     */
    refreshParams() {
        const amountOfTime = this.params.end - this.params.start;
        this.params = {
            start: this.formatDate(window.moment().toDate().getTime()) - amountOfTime,
            end: this.formatDate(window.moment().toDate().getTime()),
            step: this.params.step
        };
        return this.params;
    }
    /**
     * converts milliseconds to seconds
     * @returns number
     */
    formatDate(milliseconds) {
        return Math.round(milliseconds / 1000);
    }
    /**
     * returns the appropriate step given the amount of time to be shown
     * @returns step number
     */
    getStep(start, end) {
        if (this.stepOverride)
            return this.stepOverride;
        const amountOfTime = end - start;
        const thirtyDays = window.moment.duration(30, "days").asSeconds();
        const sevenDays = window.moment.duration(7, "days").asSeconds();
        const twoDays = window.moment.duration(2, "days").asSeconds();
        const oneDay = window.moment.duration(1, "days").asSeconds();
        const twelveHours = window.moment.duration(12, "hours").asSeconds();
        if (amountOfTime >= thirtyDays) {
            return window.moment.duration(30, "minutes").asSeconds();
        }
        else if (amountOfTime >= sevenDays) {
            return window.moment.duration(5, "minutes").asSeconds();
        }
        else if (amountOfTime >= twoDays) {
            return window.moment.duration(2, "minutes").asSeconds();
        }
        else if (amountOfTime >= oneDay) {
            return window.moment.duration(1, "minutes").asSeconds();
        }
        else if (amountOfTime >= twelveHours) {
            return window.moment.duration(30, "seconds").asSeconds();
        }
        else {
            return window.moment.duration(15, "seconds").asSeconds();
        }
    }
    /**
     * handler function for the date picker, formats data and calls the trigger func
     * @param start: start time for data selection
     * @param end: end time for data selection
     * @param chosenLabel: label from the datepicker, used to tell if absolute range
     */
    handleSelection(start, end, chosenLabel) {
        let selection;
        if (chosenLabel && chosenLabel != "Custom Range") {
            this.isAbsoluteRange = false;
            $(this.elemId).find(".text").text(chosenLabel);
            end = window.moment();
            selection = { chosenLabel: chosenLabel };
        }
        else {
            this.isAbsoluteRange = true;
            $(this.elemId).find(".text").text(start.format('MMMM D, YYYY h:mma') + ' - ' + end.format('MMMM D, YYYY h:mma'));
            selection = { range: { start: start.toISOString(), end: end.toISOString() } };
        }
        localStorage.setItem("LastDatePickerSelection", JSON.stringify(selection));
        const startSecs = this.formatDate(start.toDate().getTime());
        const endSecs = this.formatDate(end.toDate().getTime());
        this.params = {
            start: startSecs,
            end: endSecs,
            step: this.getStep(startSecs, endSecs)
        };
        this.trigger(this.params);
    }
    getConfig() {
        let config = DatePicker.DEFAULT_CONFIG;
        for (let k in this.configOverride) {
            config[k] = this.configOverride[k];
        }
        return config;
    }
}
DatePicker.DEFAULT_CONFIG = {
    ranges: {
        'Last 15 minutes': [window.moment().subtract(15, "minutes"), window.moment()],
        'Last 30 minutes': [window.moment().subtract(30, "minutes"), window.moment()],
        'Last 1 Hour': [window.moment().subtract(1, "hours"), window.moment()],
        'Last 4 Hours': [window.moment().subtract(4, "hours"), window.moment()],
        'Last 24 Hours': [window.moment().subtract(1, "days"), window.moment()],
        'Last 7 Days': [window.moment().subtract(7, "days"), window.moment()],
        'Last 30 Days': [window.moment().subtract(30, "days"), window.moment()]
    },
    timePicker: true,
    alwaysShowCalendars: true,
    autoUpdateInput: false,
    parentEl: "#datePickerParent",
    opens: "left",
    maxSpan: {
        "days": 31
    },
    timePickerIncrement: 5,
    locale: {
        direction: 'ltr',
        format: "MM/DD/YYYY h:mma",
        separator: ' - ',
        applyLabel: 'Apply',
        cancelLabel: 'Cancel',
        weekLabel: 'W',
        customRangeLabel: 'Custom Range',
        daysOfWeek: window.moment.weekdaysMin(),
        monthNames: window.moment.monthsShort(),
        firstDay: window.moment.localeData().firstDayOfWeek()
    },
    maxDate: window.moment()
};
DatePicker.TEMPLATE = `
        <div id="datePickerParent" style="position: relative">
            <div id="reportrange" class="m-box" style="max-width: 22rem; padding: .4rem">
                <div class="m-stack is-horizontal is-align-center has-space-between">
                    <m-icon name="calendar"></m-icon>
                    <span class="text m-text is-accent"></span>
                    <m-icon name="chevron-down" class="button-caret-down"></m-icon>
                </div>
            </div>
        </div>
    `;

function asyncSleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

class HashratePerformanceTableFilters extends OptiFleetPage {
    constructor(page) {
        super();
        this.page = page;
        this.storedFiltersSelector = "hashratePerformanceTableFilters";
        this.minerNameFilter;
        this.modelNameFilter;
        this.serialNumberFilter;
        this.locationIdFilter;
        this.ipAddressFilter;
        this.macAddressFilter;
        // show means the filter is visible in the filter section
        this.filters = [
            { label: "Miner Name", id: "minerName", show: true, options: [] },
            { label: "Model", id: "modelName", show: false, options: [] },
            { label: "Serial Number", id: "serialNumber", show: false, options: [] },
            { label: "Slot ID", id: "locationName", show: false, options: [] },
            { label: "IP Address", id: "ipAddress", show: false, options: [] },
            { label: "MAC Address", id: "macAddress", show: false, options: [] },
        ];
        this.activeFilters = {
            minerName: "",
            modelName: "",
            serialNumber: "",
            siteName: "",
            locationId: "",
            ipAddress: "",
            statusName: "",
            autoPool: "",
        };
        this.init();
    }
    init() {
        this.initFilters();
        let opFilters = [];
        this.filters.forEach(filter => {
            const filterName = `${filter.id}Filter`;
            this[filterName] = new OpFilter(filter.id, this.filterMiners.bind(this), this.clearFilter.bind(this), filter.options);
            opFilters.push(this[filterName]);
            if (!filter.show) {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
        });
        new SelectFilters("moreFilters", this.filters, this.changeActiveFilters.bind(this));
        new ClearFilters("clearFilters", opFilters);
    }
    initFilters() {
        const storedFiltersStr = localStorage.getItem(this.storedFiltersSelector);
        let storedFilters;
        try {
            storedFilters = JSON.parse(storedFiltersStr);
        }
        catch (e) {
            return;
        }
        if (!storedFilters) {
            return;
        }
        storedFilters.forEach(storedFilter => {
            // if is filter
            if (storedFilter.hasOwnProperty("id") && storedFilter.hasOwnProperty("label") && storedFilter.hasOwnProperty("show")) {
                var filter = this.filters.find((filter) => filter.id === storedFilter.id);
                if (filter) {
                    filter.show = storedFilter.show;
                }
            }
        });
    }
    filterMiners(formVal, propertyVal) {
        this.activeFilters[propertyVal] = formVal;
        let filteredMiners = this.page.miners;
        if (!filteredMiners) {
            return;
        }
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (!formVal || formVal === "" || formVal.length === 0) {
                return;
            }
            if (isTextInput) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        this.page.populateGrid(filteredMiners);
    }
    applyFilters() {
        let filteredMiners = this.page.miners;
        this.filters.forEach(filter => {
            const searchValue = this.activeFilters[filter.id];
            const isCheckbox = Array.isArray(searchValue);
            const isTextInput = typeof searchValue === "string";
            if (isTextInput) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    return property.includes(searchValue.toLowerCase().trim());
                });
            }
            if (isCheckbox) {
                filteredMiners = filteredMiners.filter(miner => {
                    const property = miner[filter.id] ? miner[filter.id].toString().toLowerCase() : "";
                    let isMatch = false;
                    searchValue.forEach(option => {
                        if (property === option.label.toLowerCase()) {
                            isMatch = true;
                        }
                    });
                    return isMatch;
                });
            }
        });
        this.page.populateGrid(filteredMiners);
    }
    clearFilter(id) {
        this.activeFilters[id] = "";
        this.filterMiners(id, "");
    }
    changeActiveFilters(newFilters) {
        this.filters = newFilters;
        this.filters.forEach(filter => {
            let filterRemoved = false;
            // If the filter is active and it's being remove
            if ($(`[c-id=${filter.id}]`).hasClass("active") && filter.show === false) {
                // Then clear the active state and remove the filting on the miner grid
                this[`${filter.id}Filter`].deactivateFilter();
                this.activeFilters[filter.id] = "";
                filterRemoved = true;
            }
            if (filter.show) {
                $(`[c-id=${filter.id}]`).removeClass("hide");
            }
            else {
                $(`[c-id=${filter.id}]`).addClass("hide");
            }
            if (filterRemoved) {
                this.filterMiners("", "");
            }
        });
        localStorage.setItem(this.storedFiltersSelector, JSON.stringify(this.filters));
    }
}

class HashratePerformanceReport extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: false, elemId: "ddlSites" });
        this.minerGrid = $("#minerGrid");
        this.initGrid();
        this.filters = new HashratePerformanceTableFilters(this);
        this.datePicker = new DatePicker("#datePicker", this.load.bind(this), null, null, {
            opens: "right",
            parentEl: "body"
        });
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
        window.onresize = () => {
            this.repaintGrid();
        };
    }
    handleCompanyFilterChanged(companyId) {
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged() {
        const dpParams = this.datePicker.getParams();
        this.load(dpParams);
    }
    repaintGrid() {
        setTimeout(() => {
            this.minerGrid.data("kendoGrid").refresh();
        }, 200);
    }
    initGrid() {
        this.minerGrid.kendoGrid({
            pageable: {
                pageSizes: [10, 100, 500, 1000, 5000],
                buttonCount: 5
            },
            height: "100%",
            sortable: true,
            mobile: true,
            resizable: true,
            scrollable: true,
            persistSelection: true,
            excel: {
                allPages: true
            },
            change: function (e) {
                $(".miners-selected").text(`${e.sender.selectedKeyNames().length} miners(s) selected`);
            },
            excelExport: function (e) {
                let selectedIds = e.sender.selectedKeyNames();
                if (selectedIds.length == 0) {
                    return;
                }
                e.workbook.sheets[0].rows = [e.workbook.sheets[0].rows[0]];
                let rows = e.sender.dataSource.data();
                for (let i = 0; i < rows.length; i++) {
                    if (selectedIds.includes(rows[i].minerId.toString())) {
                        e.workbook.sheets[0].rows.push({
                            type: "data",
                            cells: [
                                { "value": rows[i].serialNumber },
                                { "value": rows[i].modelName },
                                { "value": rows[i].ipAddress },
                                { "value": rows[i].locationName },
                                { "value": rows[i].minerName },
                                { "value": rows[i].macAddress },
                                { "value": rows[i].performance }
                            ]
                        });
                    }
                }
            },
            columns: [
                { selectable: true, width: "55px" },
                { template: this.getElipsisTemplate(), width: "55px" },
                { field: "serialNumber", title: "Serial Number" },
                { field: "modelName", title: "Model" },
                { field: "ipAddress", title: "IP Address", template: (miner) => `<a class=\"m-link is-size-s\" href=\"http://${miner.ipAddress}\" target=\"_blank\">${miner.ipAddress}</a>` },
                { field: "locationName", title: "Slot ID" },
                { field: "minerName", title: "Miner Name" },
                { field: "macAddress", title: "MAC Address" },
                { field: "performance", title: "Hash Rate Performance", template: (miner) => `${Math.round(miner.performance * 100 * 10) / 10}%` }
            ]
        });
        $("#minerSlotMenu").kendoContextMenu({
            target: "#minerGrid",
            filter: ".menu-wrapper",
            animation: {
                open: { effects: "fadeIn" },
            },
            showOn: "click",
            open: this.onMinerContextMenuOpen.bind(this),
            select: this.onContextMenuSelect.bind(this),
        });
    }
    onMinerContextMenuOpen(e) {
        const minerId = parseInt($(e.target).attr("data-miner-id"));
        if (isNaN(minerId) || !minerId) {
            e.preventDefault();
            return;
        }
        const miner = this.getMiner(minerId);
        if (!miner) {
            e.preventDefault();
            return;
        }
        this.selectedMinerId = String(minerId);
        $("#slotMenuMinerName").text(miner.minerName);
        $("#slotMenuIp").text(miner.ipAddress);
    }
    getMiner(minerId) {
        return this.miners.filter((miner) => {
            return miner.minerId === minerId;
        })[0];
    }
    onContextMenuSelect(e) {
        const targetMinerId = this.selectedMinerId;
        const item = $(e.item);
        const action = item.attr("action");
        if (typeof action === "undefined" || !targetMinerId) {
            return;
        }
        switchMap(action, {
            "MINER_VIEW": () => OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${targetMinerId}`),
        });
    }
    getElipsisTemplate() {
        return `<div class="menu-wrapper" data-miner-id="#=minerId#">
                <m-icon size="xl" name="more-vertical"></m-icon>
            </div>`;
    }
    load(datePickerParams) {
        this.toggleBusy(true);
        return this.getPerformanceMetrics(datePickerParams).then(metrics => {
            this.miners = metrics;
            this.populateGrid(metrics);
            this.filters.applyFilters();
            this.toggleBusy(false);
            this.repaintGrid();
        });
    }
    getPerformanceMetrics(datePickerParams) {
        return __awaiter(this, void 0, void 0, function* () {
            let start = new Date(datePickerParams.start * 1000).toISOString();
            let end = new Date(datePickerParams.end * 1000).toISOString();
            return this.get(`/HashratePerformanceReport?siteId=${yield this.siteCache.getSiteId()}&start=${start}&end=${end}`);
        });
    }
    populateGrid(inventoryItems) {
        const grid = this.minerGrid.data("kendoGrid");
        const dataSource = new self.kendo.data.DataSource({
            data: inventoryItems,
            pageSize: 100,
            schema: {
                model: {
                    id: "minerId"
                }
            }
        });
        grid.setDataSource(dataSource);
    }
    export() {
        this.minerGrid.data("kendoGrid").saveAsExcel();
    }
}

class AgentDetails extends OptiFleetPage {
    constructor() {
        super(false, { hideSiteLabel: true });
        this.tabs = {
            "Miner Discovery": $(`#tab-miner-discovery`),
            "Settings": $(`#tab-settings`),
            "Logs": $(`#tab-logs`),
            "Installation": $(`#tab-installation`),
        };
        this.tabContent = {
            "Miner Discovery": $(`#tab-content-miner-discovery`),
            "Settings": $(`#tab-content-settings`),
            "Logs": $(`#tab-content-logs`),
            "Installation": $(`#tab-content-installation`),
        };
        this.agentDetailsUrl = "/AgentDetails";
        this.agentVariablesUrl = "/AgentVariables";
        this.agentLogUrl = "/AgentCommandLogs?AgentId=";
        this.agentScanUrl = "/AgentScan";
        this.agentLogDetailUrl = "/AgentLogDetail?AgentId=";
        this.currentTab = "Miner Discovery";
        this.canEdit = $(`#${window.hfId}`).val() === "true";
        const agentId = derive(() => {
            const u = new URL(window.location.href);
            const params = u.searchParams;
            return params.get("agentId");
        });
        this.agentId = parseInt(agentId);
        this.changeTab(this.currentTab);
        this.loadAgentDetails();
    }
    loadAgentDetails() {
        this.toggleBusy(true);
        this.get(`${this.agentDetailsUrl}?AgentId=${this.agentId}`)
            .then((resp) => {
            $("#label-agent-name").text(resp.agent.agentName);
            this.populateDetails(resp);
            this.toggleBusy(false);
        });
    }
    copyCode(sender, codeType) {
        let code = "";
        switch (codeType) {
            case CODE_TYPE.ADD_REPOSITORY:
                code = $("#addRepository").text();
                break;
            case CODE_TYPE.INSTALL:
                code = $("#installAgent").text();
                break;
            case CODE_TYPE.STATUS:
                code = $("#statusAgent").text();
                break;
        }
        const copyCode = sender.getAttribute("copy-code");
        navigator.clipboard.writeText(code);
        $(`[copy-code="${copyCode}"]`).replaceWith(`<span class="m-text" copy-code=${copyCode}>Copied!</span>`);
        setTimeout(() => {
            $(`[copy-code="${copyCode}"]`).replaceWith(`
                    <button
                        class="m-button
                        is-secondary"
                        type="button"
                        onclick="pageScript.copyCode(this, ${copyCode})"
                        copy-code="${copyCode}"
                    >
                        <m-icon 
                            class="m-button-icon"
                            name="copy"
                            style="cursor: pointer; color: var(--color-text - accent);"
                        ></m-icon>
                    </button>`);
        }, 1500);
    }
    changeTab(newTab) {
        this.tabs[this.currentTab]
            .removeClass(`active`)
            .find(`.m-text`)
            .removeClass(`is-accent`);
        this.tabs[newTab]
            .addClass(`active`)
            .find(`.m-text`)
            .addClass(`is-accent`);
        this.tabContent[this.currentTab].hide();
        this.tabContent[newTab].show();
        this.currentTab = newTab;
        if (newTab === "Logs") {
            this.loadLogs();
        }
    }
    populateDetails(resp) {
        $(".existing-scan-configs").children().remove();
        $(".variable-list").children().remove();
        $("#agentName").text(resp.agent.agentName);
        resp.scanConfigs.forEach((config) => {
            config.canEdit = this.canEdit;
            const template = self.Mustache.to_html(AgentDetails.SCAN_CONFIG, config);
            $(".existing-scan-configs").append(template);
        });
        resp.variables.forEach((variable) => {
            variable.canEdit = this.canEdit;
            const template = self.Mustache.to_html(AgentDetails.AGENT_VARIABLE, variable);
            $(".variable-list").append(template);
        });
        $("#txtAgentName").val(resp.agent.agentName);
        $("#api-key").text(resp.agent.apiKey);
    }
    editScanConfig(scanConfigId) {
        $(`#scanConfig${scanConfigId}`).addClass("edit-mode");
    }
    cancelEditScanConfig(scanConfigId) {
        $(`#scanConfig${scanConfigId}`).removeClass("edit-mode");
    }
    deleteScanConfig(scanConfigId) {
        this.confirm("Delete Configuration", "Are you sure you want to delete this discovery configuration?", () => {
            this.toggleBusy(true);
            this.delete(this.agentDetailsUrl, { scanConfigId: scanConfigId })
                .then(() => {
                this.toggleBusy(false);
                this.loadAgentDetails();
            });
        });
    }
    updateScanConfig(scanConfigId) {
        //todo
    }
    addNewScanConfig() {
        $("#txtConfigName").val("");
        $("#ipRangeScanStart").val("");
        $("#ipRangeScanEnd").val("");
        $("#txtUser").val("");
        $("#txtPass").val("");
        $(".add-scan-config").removeClass("active");
        $(".add-new-scan-config").addClass("active");
    }
    cancelNewScanConfig() {
        $(".add-scan-config").addClass("active");
        $(".add-new-scan-config").removeClass("active");
    }
    saveNewScanConfig() {
        //todo
    }
    loadLogs(minDate) {
        let url = `${this.agentLogUrl}${this.agentId}`;
        if (minDate) {
            url = `${url}&LastLogDate=${minDate}`;
        }
        this.toggleBusy(true);
        this.get(url)
            .then((resp) => {
            this.toggleBusy(false);
            this.populateLogs(resp.logs);
            if (resp.lastLogDate) {
                this.lastLogDate = resp.lastLogDate;
            }
        });
    }
    populateLogs(logs) {
        logs.forEach((log, index) => {
            const logEntry = {
                event: log.commandTypeName,
                time: kendo.toString(new Date(log.dateCreated), "yyyy-MM-dd hh:mm:ss tt"),
                id: log.agentCommandId,
                altRow: index % 2 === 0,
                date: log.dateCreated
            };
            const template = self.Mustache.to_html(AgentDetails.AGENT_LOG_ITEM, logEntry);
            $(".agent-logs-wrapper").append(template);
        });
        $(".agent-logs-wrapper").find(".page-agent-logs").remove();
        $(".agent-logs-wrapper").find(".end-agent-logs").remove();
        if (logs.length > 0) {
            const template = self.Mustache.to_html(AgentDetails.AGENT_LOG_PAGE);
            $(".agent-logs-wrapper").append(template);
            return;
        }
        const template = self.Mustache.to_html(AgentDetails.AGENT_LOG_END);
        $(".agent-logs-wrapper").append(template);
    }
    loadMoreLogEvents() {
        this.loadLogs(this.lastLogDate);
    }
    loadLogDetails(sender, logId, date, event) {
        $(sender).removeClass("active");
        $(sender).siblings(".loading-log-icon").addClass("active");
        const url = `${this.agentLogDetailUrl}${this.agentId}&LogId=${logId}&LogDate=${date}&EventType=${event}`;
        this.get(url)
            .then((resp) => {
            $(sender).siblings(".loading-log-icon").removeClass("active");
            $(sender).siblings(".collapse-log-icon").addClass("active");
            $(sender).parents(".agent-log-item").siblings(".log-detail").addClass("active");
            $(sender).parents(".agent-log-item").siblings(".log-detail").text(resp.logDetail);
        });
    }
    collapseLog(sender) {
        $(sender).removeClass("active");
        $(sender).siblings(".expand-log-icon").addClass("active");
        $(sender).parents(".agent-log-item").siblings(".log-detail").removeClass("active");
    }
    saveVariables() {
        if (!this.hasValidVariables()) {
            return;
        }
        this.toggleBusy(true);
        const saveData = this.getVariables();
        this.post(this.agentVariablesUrl, saveData)
            .then((resp) => {
            this.toggleBusy(false);
            if (!resp.success) {
                this.showErrorMessage("Something went wrong saving your settings.");
                return;
            }
            this.showSuccessMessage("Settings saved!");
        });
    }
    hasValidVariables() {
        let isValid = true;
        const templates = $(".agent-variable").get();
        templates.forEach((template) => {
            $(template).find(".m-input").removeClass("is-error");
            const value = parseInt($(template).find(".m-input").val());
            const min = parseInt($(template).find(".m-input").attr("min"));
            const max = parseInt($(template).find(".m-input").attr("max"));
            if (value < min || value > max) {
                $(template).find(".m-input").addClass("is-error");
                isValid = false;
            }
        });
        return isValid;
    }
    getVariables() {
        const variables = [];
        const templates = $(".agent-variable").get();
        templates.forEach((template) => {
            const id = $(template).attr("data-variable-id");
            const value = $(template).find(".m-input").val();
            const min = $(template).find(".m-input").attr("min");
            const max = $(template).find(".m-input").attr("max");
            variables.push({
                variableId: id,
                value: value,
                minValue: min,
                maxValue: max
            });
        });
        return {
            agentId: this.agentId,
            variables: variables
        };
    }
    scanNow() {
        this.confirm("Scan For Miners", "Are you sure you want to scan for miners?", () => this.sendScanCommand());
    }
    sendScanCommand() {
        this.toggleBusy(true);
        this.post(this.agentScanUrl, { agentId: this.agentId })
            .then((resp) => {
            this.toggleBusy(false);
            if (!resp.success) {
                this.showErrorMessage(resp.message);
                return;
            }
            this.showSuccessMessage(resp.message);
        });
    }
}
AgentDetails.SCAN_CONFIG = `
            <div class="scan-config" id="scanConfig{{agentScanConfigId}}" data-id="{{agentScanConfigId}}">
                <div class="agent-property">
                    <div>
                        <div class="op-label">
                            Configuration Name
                        </div>
                        <div class="op-label-value read active">
                            {{scanName}}
                        </div>
                        <div class="op-label-value edit">
                            <input id="txtConfigName{{agentScanConfigId}}" class="op-input" type="text" data-form-type="other" value="{{scanName}}" />
                        </div>
                    </div>
                    <div>
                        <div class="read">
                        </div>
                    </div>
                </div>

                <div class="agent-property">
                    <div class="scan-type-wrapper">
                        <div class="ip-range-scan-wrapper active">
                            <div class="ip-range-scan">
                                <div class="op-label">
                                    Start
                                </div>
                                <div class="op-label-value read active">
                                    {{ipStart}}
                                </div>
                                <div class="op-label-value edit">
                                    <input id="ipRangeScanStart{{agentScanConfigId}}" class="op-input edit" value="{{ipStart}}" />
                                </div>
                            </div>
                            <div class="ip-range-scan">
                                <div class="op-label">
                                    End
                                </div>
                                <div class="op-label-value read active">
                                    {{ipEnd}}
                                </div>
                                <div class="op-label-value edit">
                                    <input id="ipRangeScanEnd{{agentScanConfigId}}" class="op-input edit" value="{{ipEnd}}" />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="miner-credentials">
                    <div class="op-label">
                        Miner Credentials
                        <div class="tooltip right edit">
                            <i class="icon-help-circle tooltip-icon"></i>
                            <span class="tooltiptext">We'll use these credentials to verify the type of Miners we discover.</span>
                        </div>
                    </div>
                    <div class="scan-credentials">
                        <div class="scan-credential">
                            <div class="op-label">
                                Username
                            </div>
                            <div class="op-label-value read active">
                                *****
                            </div>
                            <div class="op-label-value edit">
                                <input id="txtUser{{agentScanConfigId}}" type="text" class="op-input" data-form-type="other" value="{{username}}" />
                            </div>
                        </div>
                        <div class="scan-credential">
                            <div class="op-label">
                                Password
                            </div>
                            <div class="op-label-value read active">
                                *****
                            </div>
                            <div class="op-label-value edit">
                                <input id="txtPass{{agentScanConfigId}}" type="text" class="op-input" data-form-type="other" value="{{password}}" />
                            </div>
                        </div>
                    </div>
                </div>

                <div class="save-cancel edit">
                    <button class="m-button is-accent is-md is-solid" type="button" onclick="pageScript.updateScanConfig({{agentScanConfigId}});">Save</button>
                    <span class="cancel-button" onclick="pageScript.cancelEditScanConfig({{agentScanConfigId}});">Cancel</span>
                </div>
            </div>
        `;
AgentDetails.AGENT_VARIABLE = `
            <div class="agent-variable" data-variable-id="{{variableId}}">
                <div class="m-form-control">
                    <div class="m-label">
                        {{name}}
                    </div>
                    <input class="m-input" type="number" min="{{minValue}}" max="{{maxValue}}" value="{{value}}" placeholder="Value in seconds" />
                    <div class="m-help-text">
                        {{description}}
                        <i>Default {{defaultValue}}. Min {{minValue}}. Max {{maxValue}}.</i>
                    </div>
                </div>
            </div>
        `;
AgentDetails.AGENT_LOG_ITEM = `            
            {{#altRow}}
                <div class="agent-log-item-wrapper alt-row">
                    <div class="agent-log-item">
                        <div class="expand-log">
                            <i class="expand-log-icon active icon-chevron-right" onclick="pageScript.loadLogDetails(this, {{id}}, '{{date}}', '{{event}}')"></i>
                            <i class="collapse-log-icon icon-chevron-down" onclick="pageScript.collapseLog(this)"></i>
                            <i class="loading-log-icon icon-refresh-ccw"></i>
                        </div>
                        <div class="log-time">
                            {{time}}
                        </div>
                        <div class="log-type">
                            {{event}}
                        </div>
                    </div>
                    <div class="log-detail">
                        Loaded Event Details...
                    </div>
                </div>
            {{/altRow}}         
            {{^altRow}}
                <div class="agent-log-item-wrapper">
                    <div class="agent-log-item">
                        <div class="expand-log">
                            <i class="expand-log-icon active icon-chevron-right" onclick="pageScript.loadLogDetails(this, {{id}}, '{{date}}', '{{event}}')"></i>
                            <i class="collapse-log-icon icon-chevron-down" onclick="pageScript.collapseLog(this)"></i>
                            <i class="loading-log-icon icon-refresh-ccw"></i>
                        </div>
                        <div class="log-time">
                            {{time}}
                        </div>
                        <div class="log-type">
                            {{event}}
                        </div>
                    </div>
                    <div class="log-detail">
                        Loaded Event Details...
                    </div>
                </div>
            {{/altRow}}
        `;
AgentDetails.AGENT_LOG_PAGE = `
            <div class="page-agent-logs">
                <span class="link-btn" onclick="pageScript.loadMoreLogEvents()">Load more events.</span>
            </div>
        `;
AgentDetails.AGENT_LOG_END = `
            <div class="end-agent-logs">
                No older events at this window.moment.
            </div>
        `;
class CODE_TYPE {
}
CODE_TYPE.ADD_REPOSITORY = 0;
CODE_TYPE.INSTALL = 1;
CODE_TYPE.STATUS = 2;

class FirmwareReport extends OptiFleetPage {
    constructor() {
        super(false, { includeAllSites: false, elemId: "ddlSites" });
        this.reportUrl = "/FirmwareReport";
        this.init();
        this.onCompanyFilterChanged = this.handleCompanyFilterChanged.bind(this);
        this.onSiteFilterChanged = this.handleSiteFilterChanged.bind(this);
    }
    init() {
        this.minerGrid = $("#minerGrid");
        this.initGrid();
        window.onresize = () => {
            this.repaintGrid();
        };
    }
    repaintGrid() {
        setTimeout(() => {
            this.minerGrid.data("kendoGrid").refresh();
        }, 200);
    }
    initGrid() {
        this.minerGrid.kendoGrid({
            pageable: {
                pageSizes: [100, 500, 1000, 5000],
                buttonCount: 5
            },
            height: "100%",
            sortable: true,
            mobile: true,
            resizable: true,
            scrollable: true,
            persistSelection: true,
            excel: {
                allPages: true
            },
            excelExport: (e) => {
                e.workbook.fileName = `${this.siteCache.getSiteName()} Firmware List ${kendo.toString(new Date, "dd/MM/yyyy HH:mm")}`;
            },
            columns: [
                { template: this.getElipsisTemplate(), width: "55px" },
                { field: "firmware", hidden: true },
                { field: "firmwareCount", hidden: true, title: "Firmware" },
                { field: "modelName", title: "Model" },
                { field: "ipAddress", title: "IP Address", template: (miner) => `<a class=\"ip-address-link\" href=\"http://${miner.ipAddress}\" target=\"_blank\">${miner.ipAddress}</a>` },
                { field: "locationName", title: "Slot ID" },
                { field: "serialNumber", title: "Serial Number" },
                { field: "minerName", title: "Miner Name" },
                { field: "macAddress", title: "MAC Address" },
            ]
        });
        $("#minerSlotMenu").kendoContextMenu({
            target: "#minerGrid",
            filter: ".menu-wrapper",
            animation: {
                open: { effects: "fadeIn" },
            },
            showOn: "click",
            open: this.onMinerContextMenuOpen.bind(this),
            select: this.onContextMenuSelect.bind(this),
        });
    }
    onMinerContextMenuOpen(e) {
        const minerId = parseInt($(e.target).attr("data-miner-id"));
        if (isNaN(minerId) || !minerId) {
            e.preventDefault();
            return;
        }
        const miner = this.getMiner(minerId);
        if (!miner) {
            e.preventDefault();
            return;
        }
        this.selectedMinerId = String(minerId);
        $("#slotMenuMinerName").text(miner.minerName);
        $("#slotMenuIp").text(miner.ipAddress);
    }
    getMiner(minerId) {
        return this.miners.filter((miner) => {
            return miner.minerId === minerId;
        })[0];
    }
    onContextMenuSelect(e) {
        const targetMinerId = this.selectedMinerId;
        const item = $(e.item);
        const action = item.attr("action");
        if (typeof action === "undefined" || !targetMinerId) {
            return;
        }
        switchMap(action, {
            "MINER_VIEW": () => OptiFleetMaster.openTab(`Miners/IndividualMiner?id=${targetMinerId}`),
        });
    }
    getElipsisTemplate() {
        return `<div class="menu-wrapper" data-miner-id="#=minerId#">
                <m-icon size="xl" name="more-vertical"></m-icon>
            </div>`;
    }
    handleCompanyFilterChanged(companyId) {
        if (companyId == -1) {
            this.toggleSelectCompany(true);
            return;
        }
        this.toggleSelectCompany(false);
        this.siteCache.loadSites();
    }
    handleSiteFilterChanged(siteid) {
        this.loadFirmwareReport(siteid);
    }
    loadFirmwareReport(siteId) {
        const url = `${this.reportUrl}?siteId=${siteId}`;
        this.get(url)
            .then((resp) => {
            this.applyFirmwareGroupingCount(resp);
            this.miners = resp;
            this.populateGrid(resp);
        });
    }
    applyFirmwareGroupingCount(resp) {
        const firmwareGroup = resp.reduce((acc, miner) => {
            if (!acc[miner.firmware]) {
                acc[miner.firmware] = 1;
            }
            else {
                acc[miner.firmware] += 1;
            }
            return acc;
        }, {});
        for (const miner of resp) {
            miner.firmwareCount = `${miner.firmware} - ${firmwareGroup[miner.firmware]}`;
        }
    }
    populateGrid(miners) {
        const grid = this.minerGrid.data("kendoGrid");
        let data = new self.kendo.data.DataSource({
            data: miners,
            pageSize: 100,
            schema: {
                model: {
                    id: "minerId"
                }
            },
            group: [
                { field: "firmwareCount" },
            ]
        });
        grid.setDataSource(data);
        this.repaintGrid();
    }
    export() {
        this.minerGrid.data("kendoGrid").saveAsExcel();
    }
}

class Cookies {
    static deleteCookie(name) {
        // set the expiry to the past to expire the cookie instantly
        const expiry = new Date("11/11/11").toUTCString();
        const expiredCookie = `${name}=; expires=${expiry}; path=/;`;
        document.cookie = expiredCookie;
    }
    static setCookie(name, value) {
        const cookie = `${name}=${value}; path=/;`;
        document.cookie = cookie;
    }
    static getCookie(name) {
        let cookies = document.cookie.split(";");
        for (let i = 0; i < cookies.length; i++) {
            const currentCookie = cookies[i].trim();
            if (currentCookie.startsWith(name)) {
                return currentCookie.slice(name.length + 1, currentCookie.length);
            }
        }
        return "";
    }
}

/**
 * Class for the master page that all OptiFleet aspx pages inherit from
 */
class OptiFleetMaster extends OptiFleetService {
    constructor() {
        super();
        this.companiesUrl = "/Companies";
        this.sitesUrl = "/sites";
        this.initPageScript();
        if (!window.isOptiFleetMaster) {
            return;
        }
        this.sessionHandler = new SessionHandler();
        this.highlightSelectedScreen();
        this.managementMenuGroup = new MenuGroup("managementMenuGroup");
        this.reportsMenuGroup = new MenuGroup("reportsMenuGroup");
        this.adminMenuGroup = new MenuGroup("adminMenuGroup");
        this.selectedCompanyName = localStorage.getItem("selectedCompanyName");
        $(window).click((event) => {
            // If clicked element doesn't have a parent with the class "user-wrapper" and if element doesn't has the class "user-wrapper", then turn off active states for the user panel
            if (!$(event.target).parents('.user-wrapper').length && !$(event.target).hasClass("user-wrapper")) {
                $(".user-panel").removeClass("active");
                $(".user-wrapper").removeClass("active");
            }
            // If clicked element isn't a drop down, remove hidden attribute for the dropdowns
            if (!$(event.target).parents(".op-dropdown").length && !$(event.target).hasClass("op-dropdown") && !$(event.target).parents(".m-uishell-left-panel").length && !$(event.target).parents(".m-uishell-header").length) {
                $(".m-dropdown-menu").attr("aria-hidden", "true");
                $("#companySwitcherDropdown").attr("hidden", "true");
            }
            this.sessionHandler.keepSessionAlive();
        });
        $(".side-nav").on("swipeleft", () => {
            this.toggleMobileNav(true);
        });
        this.loadCompanies();
        this.toggleNav();
        if (window.innerWidth <= 768) {
            this.toggleMobileNav();
        }
        $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', (event) => {
            if (this.sessionRefresh) {
                clearInterval(this.sessionRefresh);
            }
            if (document.fullscreen) {
                // keep session alive every 5 minutes
                this.sessionRefresh = setInterval(() => {
                    this.sessionHandler.keepSessionAlive();
                }, 300000);
            }
        });
    }
    initPageScript() {
        var _a;
        // this is a weird hack to get timepicker working, but we'll be removing this timepicker really soon anyway
        if (window.isOptiFleetMaster) {
            window.timepicker = new TimePickerDropdown();
        }
        const pathNameSplit = window.location.pathname.split("/");
        const page = (_a = pathNameSplit[pathNameSplit.length - 1]) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase();
        switch (page) {
            // Administration -----------------------------
            case "agentdetails":
                window.pageScript = new AgentDetails();
                break;
            case "agents":
                window.a = new Agents();
                break;
            case "assetdefinitions":
                window.assets = new AssetDefinitions();
                break;
            case "assetmanagement":
                window.assets = new AssetManagement();
                break;
            case "companies":
                window.cv = new Companies();
                break;
            case "models":
                window.ma = new ModelsAdmin();
                break;
            case "scheduledshutdowns":
                window.ss = new ScheduledShutdowns();
                break;
            case "sitedetails":
                window.s = new SiteDetails();
                break;
            case "sites":
                window.s = new Sites();
                break;
            case "tickets":
                window.t = new Ticketing();
                break;
            case "users":
                window.uv = new UsersView();
                break;
            case "usersnew":
                window.u = new Users();
                break;
            // Alerts -------------------------------------
            case "alerts":
                window.alertsjs = new Alerts();
                break;
            // Dashboard/Miners ---------------------------
            case "list":
                window.ma = new MinerAdmin();
                break;
            case "map":
                window.sm = new SiteMapNew();
                break;
            // Dashboard ----------------------------------
            case "currentperformance":
                window.cp = new CurrentPerformance();
                break;
            case "curtailment":
                window.c = new Curtailment();
                break;
            case "drilldown":
                window.mv = new Drilldown();
                break;
            case "hashrate":
                window.pageScript = new OptiFleetPage();
                break;
            case "historical":
                window.h = new HistoricalStats();
                break;
            case "minerstats":
                window.stats = new MinerStats();
                break;
            case "pool":
                window.pool = new MiningPool();
                break;
            case "sitemapold":
                window.sm = new SiteMap();
                break;
            case "siteoverview":
                window.pageScript = new SiteOverview();
                break;
            // General ------------------------------------
            case "customerresources":
                window.cr = new CustomerResources();
                break;
            case "feedback":
                window.fb = new Feedback();
                break;
            case "releasenotes":
                window.pageScript = new OptiFleetPage(false, { hideSiteLabel: true, });
                break;
            // Issues -------------------------------------
            case "issues":
                window.issues = new Issues();
                break;
            // Login --------------------------------------
            case "activateaccount":
                window.activation = new UserActivation();
                break;
            case "forgotpassword":
                window.fp = new ForgotPassword();
                break;
            case "resetpassword":
                window.rp = new ResetPass();
                break;
            case "start":
                window.pageScript = new Login();
                break;
            // Miners -------------------------------------
            case "individualminer":
                window.im = new IndividualMiner();
                break;
            case "minerview":
                window.mv = new MinerView();
                break;
            // Reports ------------------------------------
            case "dailyperformancereport":
                window.pageScript = new DailyPerformanceReport();
                break;
            case "egauges":
                window.e = new EgaugeReport();
                break;
            case "energy":
                window.er = new EnergyReport();
                break;
            case "exceptions":
                window.er = new ExceptionsReport();
                break;
            case "hashrateperformancereport":
                window.pageScript = new HashratePerformanceReport();
                break;
            case "keymetricsreport":
                window.k = new KeyMetricsReport();
                break;
            case "minerfees":
                window.mfr = new MinerFeesReport();
                break;
            case "miningpoolsreport":
                window.mpr = new MiningPoolsReport();
                break;
            case "powerusagereport":
                window.pur = new PowerUsageReport();
                break;
            case "projectedbtc":
                window.pbtc = new ProjectedBTC();
                break;
            case "sensorpush":
                window.e = new SensorPushReport();
                break;
            case "sensors":
                window.s = new SensorsReport();
                break;
            case "ticketrotation":
                window.e = new TicketRotationReport();
                break;
            case "usagereport":
                window.ur = new UsageReport();
                break;
            case "firmwarereport":
                window.pageScript = new FirmwareReport();
                break;
            // User ---------------------------------------
            case "profile":
                window.up = new UserProfile();
                break;
            // CustomerDashboard
            case "customerdashboard":
                window.cd = new CustomerDashboard();
                break;
        }
    }
    /**
     * Adds styling to current page in nav
     * */
    highlightSelectedScreen() {
        const url = window.location.href;
        const navItems = $(".m-uishell-left-panel .m-nav-item").get();
        navItems.forEach((elem) => {
            const elemUrl = elem.href.replace(".aspx", "");
            if (url.indexOf(elemUrl) > -1) {
                $(elem).addClass("selected");
                $(elem).attr("aria-current", "true");
                return;
            }
        });
    }
    /**
     * Hamburger handler for mobile nav menu
     * @param forceClose
     */
    toggleMobileNav(forceClose) {
        if (forceClose) {
            $(".m-uishell").addClass("collapse");
            return;
        }
        if ($(".m-uishell").hasClass("collapse")) {
            $(".m-uishell").removeClass("collapse");
            return;
        }
        $(".m-uishell").addClass("collapse");
    }
    /**
     * Toggles non-mobile nav menu
     * */
    toggleNav() {
        const navOpen = JSON.parse(localStorage.getItem("navOpen"));
        this.toggleNavOpen(navOpen);
    }
    loadCompanies() {
        const OptiFleetID = localStorage.getItem("OptiFleetID");
        const storedCompanies = JSON.parse(localStorage.getItem("storedCompanies"));
        if (storedCompanies && storedCompanies.companies
            && storedCompanies.companies.length > 1 && Date.now() / 1000 - storedCompanies.lastSync < 600
            && storedCompanies.OptiFleetId === OptiFleetID) {
            this.populateCompaniesDropDown(storedCompanies.companies, storedCompanies.allowAllCompanies);
            return;
        }
        if (storedCompanies && storedCompanies.OptiFleetId !== OptiFleetID) {
            SessionHandler.clearLocalStorage();
        }
        this.get(`${this.companiesUrl}?filterActive=true`)
            .then((resp) => {
            const storedCompanies = {
                companies: resp.companies,
                lastSync: Date.now() / 1000,
                OptiFleetId: OptiFleetID,
                allowAllCompanies: resp.allowAllCompanies
            };
            if (!resp.companies || resp.companies.length === 0) {
                this.sessionHandler.logout();
                return;
            }
            localStorage.setItem("storedCompanies", JSON.stringify(storedCompanies));
            this.populateCompaniesDropDown(resp.companies, resp.allowAllCompanies);
        });
    }
    populateCompaniesDropDown(companies, allowAllCompanies) {
        let companyId, companyName, company;
        companyId = JSON.parse(localStorage.getItem("selectedCompany"));
        if (!companyId) {
            companyId = companies[0].id;
            companyName = companies[0].name;
        }
        else {
            company = companies.filter((company) => {
                return company.id == companyId;
            })[0];
            companyId = company.id;
            companyName = company.name;
        }
        const selectedCompany = { name: companyName.toString(), id: companyId };
        companies = companies.map(c => { c.id = c.id.toString(); return c; });
        // drop down is created 
        new CompanySwitcher("companySwitcher", selectedCompany, companies, this.onCompanyChanged.bind(this));
        localStorage.setItem("selectedCompany", companyId.toString());
        localStorage.setItem("selectedCompanyName", companyName);
        $(document).trigger("companyFilterChanged", companyId);
    }
    onCompanyChanged(id, name) {
        localStorage.setItem("selectedCompany", id.toString());
        localStorage.setItem("selectedCompanyName", name);
        $(document).trigger("companyFilterChanged", id);
        $("#companySwitcherLabel").text(name);
        this.post("/SelectedCompany", { selectedCompany: id });
    }
    /**
     * Toggles visibility of user panel in the page header.  Displays Profile and Logout options.
     * */
    toggleUserDropdown() {
        const elem = $("#userDropdown");
        const isHidden = elem.attr("aria-hidden");
        $(".user-wrapper").toggleClass("active");
        if (isHidden === "true") {
            elem.removeAttr("aria-hidden");
        }
        else {
            elem.attr("aria-hidden", "true");
        }
    }
    static openProfileTab() {
        this.openTab("User/Profile.aspx");
    }
    static openTab(page) {
        if (self.window.location.href.indexOf("OptiFleet.Portal") > -1) {
            window.open("/OptiFleet.Portal/Content/" + page, '_blank');
        }
        else {
            window.open("/Content/" + page, '_blank');
        }
    }
    static navigateTo(page, newTab) {
        if (self.window.location.href.indexOf("OptiFleet.Portal") > -1) {
            window.open("/OptiFleet.Portal/Content/" + page, newTab ? "_blank" : "_self");
        }
        else {
            window.open("/Content/" + page, newTab ? "_blank" : "_self");
        }
    }
    goToProfile() {
        this.goTo("User/Profile.aspx");
    }
    goToHome() {
        this.goTo("Dashboard/SiteOverview.aspx");
    }
    goTo(page) {
        if (self.window.location.href.indexOf("OptiFleet.Portal") > -1) {
            window.location.href = "/OptiFleet.Portal/Content/" + page;
        }
        else {
            window.location.href = "/Content/" + page;
        }
    }
    static goTo(page) {
        if (self.window.location.href.indexOf("OptiFleet.Portal") > -1) {
            window.location.href = "/OptiFleet.Portal/Content/" + page;
        }
        else {
            window.location.href = "/Content/" + page;
        }
    }
    toggleNavOpen(isOpen) {
        if (isOpen === false) {
            localStorage.setItem("navOpen", "false");
            $(".m-uishell").addClass("collapse");
            $(".m-uishell").addClass("expand");
            return;
        }
        window.localStorage.setItem("navOpen", "true");
        $(".m-uishell").removeClass("collapse");
        $(".m-uishell").removeClass("expand");
    }
    toggleColorMode(e) {
        const sunSVG = $("#modeToggle .lucide-sun");
        const moonSVG = $("#modeToggle .lucide-moon");
        const currentMode = $("body").attr("data-color-scheme");
        if (currentMode === "light") {
            $("body").attr("data-color-scheme", "dark");
            $(moonSVG).addClass("hide");
            $(sunSVG).removeClass("hide");
            Cookies.setCookie("colorScheme", "dark");
        }
        else {
            $("body").attr("data-color-scheme", "light");
            $(moonSVG).removeClass("hide");
            $(sunSVG).addClass("hide");
            Cookies.setCookie("colorScheme", "light");
        }
    }
    toggleSideNav() {
        $(".m-uishell-left-panel").toggleClass("is-open");
    }
    /**
     * Fades out a given element. Usage from HTML: OptiFleet.OptiFleetMaster.fadeOutElement
     * @param sender: HTMLElement
     * @param fadeDuration?: number
     */
    static fadeOutElement(sender, fadeDuration, selector) {
        if (selector) {
            $(sender).parents(selector).fadeOut(fadeDuration || 400);
            return;
        }
        $(sender).parent().fadeOut(fadeDuration || 400);
    }
}
const pathNameSplit = window.location.pathname.split("/");
window.ms = pathNameSplit[pathNameSplit.length - 1] === "" ? new CdMaster(true) : new OptiFleetMaster();

export { OptiFleetMaster };
